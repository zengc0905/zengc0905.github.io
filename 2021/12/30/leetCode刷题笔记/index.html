<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/dataphin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/dataphin.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zengc0905.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录在力扣上的刷题历程">
<meta property="og:type" content="article">
<meta property="og:title" content="leetCode刷题笔记">
<meta property="og:url" content="http://zengc0905.github.io/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="曾超の博客">
<meta property="og:description" content="记录在力扣上的刷题历程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zengc0905.github.io/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/snipaste_20220117_164246.png">
<meta property="article:published_time" content="2021-12-30T06:14:17.000Z">
<meta property="article:modified_time" content="2022-05-17T07:36:47.850Z">
<meta property="article:author" content="曾超">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zengc0905.github.io/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/snipaste_20220117_164246.png">

<link rel="canonical" href="http://zengc0905.github.io/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetCode刷题笔记 | 曾超の博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-PLK3B9Z0FG"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-PLK3B9Z0FG');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="曾超の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <!--
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>
   -->

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">曾超の博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录日常的学习与生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zengc0905.github.io/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zc1.jpg">
      <meta itemprop="name" content="曾超">
      <meta itemprop="description" content="天天经过小巷，乱花漫了高墙，贪看蜂狂蝶舞，忘了世态炎凉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曾超の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetCode刷题笔记
        </h1>

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color= 0A0A0A>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-30 14:14:17" itemprop="dateCreated datePublished" datetime="2021-12-30T14:14:17+08:00">2021-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-17 15:36:47" itemprop="dateModified" datetime="2022-05-17T15:36:47+08:00">2022-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>166k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:30</span>
            </span>
            <div class="post-description">记录在力扣上的刷题历程</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="leetcode-top100"><a href="#leetcode-top100" class="headerlink" title="leetcode top100"></a>leetcode top100</h1><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="#437 路径总和 III"></a>#437 路径总和 III</h2><p>&emsp;&emsp;给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<span id="more"></span>

<p><strong>方法一：深度优先搜索</strong></p>
<ul>
<li>时间复杂度：O(N^2^)，其中 N为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(N)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 O(N^2^)。</li>
<li>空间复杂度：O(N)，递归需要消耗栈空间</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = pathNum(root,targetSum);</span><br><span class="line">        res += pathSum(root.left,targetSum);</span><br><span class="line">        res += pathSum(root.right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须以node节点开始，路径和为targetSum的路径的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathNum</span><span class="params">(TreeNode node,<span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val == targetSum)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        count += pathNum(node.left, targetSum - node.val);</span><br><span class="line">        count += pathNum(node.right, targetSum - node.val);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<p><strong>方法二：前缀和（进阶），利用HashMap记录每个节点到根节点的路径和</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N为二叉树中节点的个数。利用前缀和只需遍历一次二叉树即可</li>
<li>空间复杂度：O(N)</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum1</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//prifexMap中记录每个节点到根节点的路径和，key为路径和,value为某个节点到根节点路径和为key的节点个数</span></span><br><span class="line">        HashMap&lt;Long, Integer&gt; prifexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        prifexMap.put(<span class="number">0L</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(root,targetSum,prifexMap,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//curprifex为当前节点node（不办含node）到根节点的路径和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> targetSum, HashMap&lt;Long, Integer&gt; prifexMap, <span class="keyword">long</span> curPrifex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        curPrifex += node.val;</span><br><span class="line">        res += prifexMap.getOrDefault(curPrifex - targetSum,<span class="number">0</span>);</span><br><span class="line">        prifexMap.put(curPrifex,prifexMap.getOrDefault(curPrifex,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        res += dfs(node.left,targetSum,prifexMap,curPrifex);</span><br><span class="line">        res += dfs(node.right,targetSum,prifexMap,curPrifex);</span><br><span class="line">        <span class="comment">//回溯，恢复prifexMap</span></span><br><span class="line">        prifexMap.put(curPrifex,prifexMap.get(curPrifex) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="#438 找到字符串中所有字母异位词"></a>#438 找到字符串中所有字母异位词</h2><blockquote>
<p>&emsp;&emsp;给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
</blockquote>
<p>解题思路：滑动窗口+数组</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">     <span class="comment">//滑动窗口 + 数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams1</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = p.length();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span>[] sCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len2; i &lt; len1; i++) &#123;</span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            sCount[s.charAt(i - len2) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">                list.add(i - len2 + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<hr>
<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="#448 找到所有数组中消失的数字"></a>#448 找到所有数组中消失的数字</h2><blockquote>
<p>&emsp;&emsp;给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
</ul>
</blockquote>
<p>解题思路：用一个哈希表记录数组nums 中的数字，由于数字范围均在1-n中，记录数字后我们再利用哈希表检查 1-n 中的每一个数是否出现，从而找到缺失的数字。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Set&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            hashSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashSet.contains(i))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<p>上述方法空间复杂度为O(N)，可利用原数组nums优化空间复杂度为O(1)。遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 1~n中，增加以后，这些数必然大于 n。最后遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数i+1。这样就找到了缺失的数字。<br>&emsp;&emsp;另外需要注意的是，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模来还原出它本来的值。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (nums[i] - <span class="number">1</span>) % n;</span><br><span class="line">            nums[temp] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div> 

<hr>
<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="#461 汉明距离"></a>#461 汉明距离</h2><p>&emsp;&emsp;两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>
<p>2^31^</p>
<ul>
<li>0 &lt;= x, y &lt;= 2^31^ - 1</li>
</ul>
<p>解题思路：</p>
<p>方法一：将x和y进行异或运算，统计异或后的数中1的个数</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((temp &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<p>方法二：Brian Kernighan 算法</p>
<p>记 f(x) 表示 x 和 x−1 进行与运算所得的结果（即f(x)=x &amp; (x−1)），那么f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            temp &amp;= temp - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<hr>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="#494 目标和"></a>#494 目标和</h2><p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的<strong>每个整数前</strong>添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<ul>
<li>1 &lt;= nums.length &lt;= 20</li>
<li>0 &lt;= nums[i] &lt;= 1000</li>
<li>0 &lt;= sum(nums[i]) &lt;= 1000</li>
<li>-1000 &lt;= target &lt;= 1000</li>
</ul>
<p>解题思路：</p>
<p>f(i,target) = f(i - 1,target + nums[i]) + f(i - 1,target - nums[i])</p>
<h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWays(nums,target,nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target || nums[i] == -target)&#123;</span><br><span class="line">                <span class="keyword">return</span> target == <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWays(nums,target - nums[i],i - <span class="number">1</span>) +</span><br><span class="line">                findTargetSumWays(nums,target + nums[i],i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(2^n^)，其中 n 是数组 nums 的长度。回溯需要遍历所有不同的表达式，共有 2^n^种不同的表达式，每种表达式计算结果需要 O(1) 的时间，因此总时间复杂度是 O(2^n^)；</li>
</ul>
<ul>
<li>空间复杂度：O(n)，其中 n 是数组 nums 的长度。空间复杂度主要取决于递归调用的栈空间，栈的深度不超过 n。</li>
</ul>
<h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>设neg为添加‘-’号的元素之和，则有sum - neg - neg = target,从而得到neg = (sum - target)/2;问题转化为从nums中选取某些元素，使得其和为neg的方式有多少种？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设neg为添加‘-’号的元素之和，则有sum - neg - neg = target,从而得到neg = (sum - target)/2;</span></span><br><span class="line">        <span class="comment">//问题转化为从nums中选取某些元素，使得其和为neg的方式有多少种？</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt; sum || target &lt; -sum || (sum - target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = (sum - target)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[neg + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = neg; j &gt;= nums[i];j--)&#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n* neg)</li>
<li>空间复杂度：O(sum - target)</li>
</ul>
<hr>
<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="#538 把二叉搜索树转换为累加树"></a>#538 把二叉搜索树转换为累加树</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。</li>
<li>节点的右子树仅包含键 大于 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p>解题思路：反序中序遍历</p>
<p>反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            sum += root.val;</span><br><span class="line">            root.val = sum;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<ul>
<li><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p>
</li>
<li><p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p>
</li>
</ul>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="#543 二叉树的直径"></a>#543 二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>深度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义一个全局变量res，记录整棵树的最大直径</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        process(root);</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> L = process(root.left);</span><br><span class="line">        <span class="comment">//计算右子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> R = process(root.right);</span><br><span class="line">        <span class="comment">//更新最大直径</span></span><br><span class="line">        res = Math.max(res,L + R + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(L,R) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O(N)，其中 N 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</li>
</ul>
<ul>
<li>空间复杂度：O(Height)，其中 Height 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 O(Height) 。</li>
</ul>
<hr>
<h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="#560 和为K的子数组"></a>#560 和为K的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
<h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; len; end++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = end; start &gt;= <span class="number">0</span> ; start--) &#123;</span><br><span class="line">                sum += nums[start];</span><br><span class="line">                <span class="keyword">if</span> (sum == k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><p>时间复杂度：O(n^2)，其中 n 为数组的长度。枚举子数组开头和结尾需要 O(n^2 ) 的时间，其中求和需要 O(1) 的时间复杂度，因此总时间复杂度为 O(n^2)。</p>
</li>
<li><p>空间复杂度：O(1)。只需要常数空间存放若干变量。</p>
</li>
</ul>
<h3 id="方法二：前缀和-哈希表"><a href="#方法二：前缀和-哈希表" class="headerlink" title="方法二：前缀和+哈希表"></a>方法二：前缀和+哈希表</h3><p>使用一个哈希表记录数组nums中以i结尾的前缀和的个数，hashmap中key为前缀和，value为出现的个数。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录数组nums中以i结尾前缀和为key的个数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;<span class="comment">//记录当前位置的前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(pre - k))&#123;</span><br><span class="line">                count += hashMap.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(pre,hashMap.getOrDefault(pre,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="#617 合并二叉树"></a>#617 合并二叉树</h2><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
</blockquote>
<h3 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        TreeNode right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<ul>
<li>时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>
</ul>
<ul>
<li>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>
</ul>
<hr>
<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="#581 最短无序连续子数组"></a>#581 最短无序连续子数组</h2><blockquote>
<p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>将原数组与排序后的数组进行比较</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组有序，直接返回0；</span></span><br><span class="line">        <span class="keyword">if</span> (isSorted(nums))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] numsSort = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,numsSort,<span class="number">0</span>,len);</span><br><span class="line">        Arrays.sort(numsSort);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[left] == numsSort[left])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[right] == numsSort[right])&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlogn)，其中 n 为给定数组的长度。我们需要 O(nlogn) 的时间进行排序，以及 O(n) 的时间遍历数组，因此总时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)，其中 n 为给定数组的长度。我们需要额外的一个数组保存排序后的数组 numsSorted。</p>
<h3 id="方法二：一次遍历（将数组分成三段）"><a href="#方法二：一次遍历（将数组分成三段）" class="headerlink" title="方法二：一次遍历（将数组分成三段）"></a>方法二：一次遍历（将数组分成三段）</h3><p>我们可以假设把这个数组分成三段，<code>左段</code>和<code>右段</code>是标准的升序数组，<code>中段</code>数组虽是无序的，但满足最小值大于<code>左段</code>的最大值，最大值小于<code>右段</code>的最小值。</p>
<p><img src="/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/snipaste_20220117_164246.png"></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>,right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//从左往右遍历，维护最大值，更新右边界</span></span><br><span class="line">            <span class="keyword">if</span> (max &gt; nums[i])&#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右往左遍历，维护最小值，更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (min &lt; nums[len - i - <span class="number">1</span>])&#123;</span><br><span class="line">                left = len - i - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                min = nums[len - i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right == -<span class="number">1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O*(*n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。</li>
<li>时间复杂度：O(1)，我们只需要常数的空间保存若干变量。</li>
</ul>
<hr>
<h2 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="#621 任务调度器"></a>#621 任务调度器</h2><blockquote>
<p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 最短时间 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= task.length &lt;= 10^4</code></li>
<li><code>tasks[i]</code> 是大写英文字母</li>
<li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
</blockquote>
<p>解题思路：</p>
<ol>
<li>不考虑冷却时间需要task长度时间；</li>
<li>找出任务量最多的若干任务，需要先占坑，剩下的填坑；</li>
<li>假如不可以把剩下的坑填满，那么就是最多数任务加上他们的冷却时间，否则输出task 总数。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//任务量最多的某个任务数量</span></span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//任务量等于maxCount的任务种类</span></span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            count[tasks[i] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (count[tasks[i] - <span class="string">&#x27;A&#x27;</span>] &gt; maxCount)&#123;</span><br><span class="line">                maxCount = count[tasks[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == maxCount) maxNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(tasks.length,(n + <span class="number">1</span>) * (maxCount - <span class="number">1</span>) + maxNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O(n), n为字符数组tasks的长度;</li>
<li>空间复杂度：O(1);</li>
</ul>
<hr>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="#647 回文子串"></a>#647 回文子串</h2><blockquote>
<p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p>
<p>回文字符串 是正着读和倒过来读一样的字符串。</p>
<p>子字符串 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><code>dp[i][j] = dp[i+1][j-1]&amp;&amp;s[i] = s[j]</code></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; chars[i] == chars[i + <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i + j &lt; len &amp;&amp; chars[i] == chars[i + j])&#123;</span><br><span class="line">                    dp[i][i + j] = dp[i + <span class="number">1</span>][i + j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][i + j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2^)</p>
<p>空间复杂度：O(n)。n为字符串s的长度。</p>
<h3 id="方法二：中心扩展法"><a href="#方法二：中心扩展法" class="headerlink" title="方法二：中心扩展法"></a>方法二：中心扩展法</h3><ul>
<li>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</li>
</ul>
<p>需要注意的是：如何有序地枚举所有可能的回文中心，我们需要考虑回文长度是奇数和回文长度是偶数的两种情况。如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。</p>
<p>一种方法是做两次循环来分别枚举奇数长度和偶数长度的回文，但这样稍显繁琐，通过仔细观察可以发现，长度为n 的字符串会生成 2n−1 组回文中心 [l_i, r_i]，其中  l_i = ⌊ 2/i⌋，r_i = l_i + (i %mod 2)。这样我们只要从 0 到 2n−2 遍历 i，就可以得到所有可能的回文中心，这样就把奇数长度和偶数长度两种情况统一起来了。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最外层循环遍历所有回文中心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//以l为回文中心左边界，r为回文中心右边界向外扩展，判断是否是回文子串</span></span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; chars[l] == chars[r]) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2^)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="# 739 每日温度"></a># 739 每日温度</h2><blockquote>
<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
</blockquote>
<h3 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; temperatures[j] &lt;= temperatures[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == len) &#123;</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = j - i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2^)</p>
<p>空间复杂度：O(1)</p>
<h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h3><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//当栈不为空并且当前元素大于栈顶元素，栈顶元素出栈，计算天数</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">                res[cur] = i - cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈为空或者当前元素小于栈顶元素，当前元素入栈</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p>
<p>空间复杂度：O(n),其中 n是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p>
<hr>
<br>

<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03.数组中重复的数字"></a>03.数组中重复的数字</h2><blockquote>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<h3 id="方法一：利用hashSet"><a href="#方法一：利用hashSet" class="headerlink" title="方法一：利用hashSet"></a>方法一：利用hashSet</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    	HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            hashSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度 O(N) ： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。<br>空间复杂度 O(N) ： HashSet 占用 O(N) 大小的额外空间。</p>
<h3 id="方法二：原地交换"><a href="#方法二：原地交换" class="headerlink" title="方法二：原地交换"></a>方法二：原地交换</h3><p>可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一个重复值并返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="comment">//原地交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[nums[i]];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。<br>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</p>
<hr>
<h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04.二维数组中的查找"></a>04.二维数组中的查找</h2><blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p><strong>限制：</strong></p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= n &lt;= <span class="number">1000</span></span><br><span class="line"><span class="symbol">0 </span>&lt;= m &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>题解：由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>
<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//n为行数，m为列数</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从右上角往左下角遍历</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到目标，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。<br>空间复杂度：O(1)。</p>
<hr>
<h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05.替换空格"></a>05.替换空格</h2><blockquote>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p>0 &lt;= s 的长度 &lt;= 10000</p>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n);</p>
<p>空间复杂度:O(n);</p>
<hr>
<h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06.从尾到头打印链表"></a>06.从尾到头打印链表</h2><blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>0 &lt;= 链表长度 &lt;= 10000</p>
</blockquote>
<p>题解: 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">  		 <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head =head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。<br>空间复杂度：O(n)。额外使用一个栈存储链表中的每个节点。</p>
<hr>
<h2 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07.重建二叉树"></a>07.重建二叉树</h2><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
</blockquote>
<p>题解：在中序遍历中定位到根节点，可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p>
<p>这样一来，就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = preorder.length;</span><br><span class="line">        TreeNode root = buildTree(preorder, <span class="number">0</span>, len - <span class="number">1</span>, inorder, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当前根节点</span></span><br><span class="line">        TreeNode currentRootNode = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="comment">//找出当前根节点在中序遍历中的索引</span></span><br><span class="line">        <span class="keyword">int</span> i = getIndexOfInorder(inorder, inStart, inEnd, preorder[preStart]);</span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(preorder, preStart + <span class="number">1</span>, preStart + i - inStart, inorder, inStart, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(preorder, preStart + i - inStart + <span class="number">1</span>, preEnd, inorder, i + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="comment">//连接左右子树</span></span><br><span class="line">        currentRootNode.left = leftNode;</span><br><span class="line">        currentRootNode.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> currentRootNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出当前根节点在中序遍历中的索引（这一步还可以优化，利用hashmap在常数时间复杂度内得到索引值）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndexOfInorder</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><p>时间复杂度：O(n),其中 n是树中的节点个数。</p>
</li>
<li><p>空间复杂度：O(m),其中m为树的高度。</p>
</li>
</ul>
<hr>
<h2 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09.用两个栈实现队列"></a>09.用两个栈实现队列</h2><blockquote>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素从此栈入</span></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    <span class="comment">//元素从此栈出</span></span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        stackIn.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackIn.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><p>时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。插入不多说，对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。</p>
</li>
<li><p>空间复杂度：O(n)。需要使用两个栈存储已有的元素。</p>
</li>
</ul>
<hr>
<h2 id="10-1斐波那契额数列"><a href="#10-1斐波那契额数列" class="headerlink" title="10.1斐波那契额数列"></a>10.1斐波那契额数列</h2><blockquote>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法一：递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; fib = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fib.add(<span class="number">0</span>);</span><br><span class="line">        fib.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fib.add(i,(fib.get(i - <span class="number">1</span>) + fib.get(i - <span class="number">2</span>))% (<span class="number">1000000007</span>));</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> fib.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法二：动态规划</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11.旋转数组的最小数字"></a>11.旋转数组的最小数字</h2><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  </p>
</blockquote>
<p>题解：排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。本题要找的旋转数组的最小值即旋转点</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                <span class="comment">//旋转点在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[right])&#123;</span><br><span class="line">                <span class="comment">//旋转点在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无法判断旋转点位置</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h2><blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<ul>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>
</ul>
</blockquote>
<p>题解：本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。</p>
<p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board,chars,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//搜索越界或者当前字符不匹配，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//匹配的字符置为空，防止重复匹配</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//全部字符匹配成功，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//递归匹配下一个字符</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//回溯，恢复现场</span></span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度 O(3^K^MN)： 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K^)；矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。<br>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 33种选择，因此方案数的复杂度为 O(3^K^) 。</li>
<li>空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</li>
</ul>
<hr>
<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h2><blockquote>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
</blockquote>
<h3 id="方法一：DFS深度优先遍历"><a href="#方法一：DFS深度优先遍历" class="headerlink" title="方法一：DFS深度优先遍历"></a>方法一：DFS深度优先遍历</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不满足条件，返回0；</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || getSum(i) + getSum(j) &gt; k || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//默认为fasle,搜素过后置为true</span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i,j + <span class="number">1</span>) + dfs(i + <span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算数位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="方法二：BFS广度优先遍历"><a href="#方法二：BFS广度优先遍历" class="headerlink" title="方法二：BFS广度优先遍历"></a>方法二：BFS广度优先遍历</h3><p>利用队列实现广度优先遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">int</span>[] ints = queue.poll();</span><br><span class="line">           <span class="keyword">int</span> i = ints[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">int</span> j = ints[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">int</span> si = getSum(i);</span><br><span class="line">           <span class="keyword">int</span> sj = getSum(j);</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">           ans++;</span><br><span class="line">           visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">           queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>,j&#125;);</span><br><span class="line">           queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j + <span class="number">1</span>&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//计算数位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O(mn)</li>
<li>空间复杂度：O(mn)</li>
</ul>
<hr>
<h2 id="14-1剪绳子"><a href="#14-1剪绳子" class="headerlink" title="14.1剪绳子"></a>14.1剪绳子</h2><blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18</p>
<ul>
<li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
</blockquote>
<p>题解：由数学推导可得：</p>
<ul>
<li>当所有绳段长度相等时，乘积最大</li>
<li>最优的绳段长度为3</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度 O(1)： 仅有求整、求余、次方运算。</li>
<li>空间复杂度O(1)</li>
</ul>
<p>进阶：答案需要取模1e9+7</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//循环取余</span></span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">                res *= <span class="number">3</span>;</span><br><span class="line">                res %= <span class="number">1000000007</span>;</span><br><span class="line">                n -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最终剩下来的肯定是2,3,4</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h1 id="剑指offer（专项突击版）"><a href="#剑指offer（专项突击版）" class="headerlink" title="剑指offer（专项突击版）"></a>剑指offer（专项突击版）</h1><h2 id="001-050"><a href="#001-050" class="headerlink" title="001-050"></a>001-050</h2><h3 id="001-整数除法"><a href="#001-整数除法" class="headerlink" title="001.整数除法"></a>001.整数除法</h3><p>给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 ‘*’、除号 ‘/‘ 以及求余符号 ‘%’ 。</p>
<p>注意：</p>
<ul>
<li>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31−1]。本题中，如果除法结果溢出，则返回 2^31 − 1</li>
</ul>
<p>减法代替除法，并使用位运算优化减法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sign = (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    a = Math.abs(a);</span><br><span class="line">    b = Math.abs(b);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 首先，右移的话，再怎么着也不会越界</span></span><br><span class="line">        <span class="comment">// 其次，无符号右移的目的是：将 -2147483648 看成 2147483648</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这里不能是 (a &gt;&gt;&gt; i) &gt;= b 而应该是 (a &gt;&gt;&gt; i) - b &gt;= 0</span></span><br><span class="line">        <span class="comment">// 这个也是为了避免 b = -2147483648，如果 b = -2147483648</span></span><br><span class="line">        <span class="comment">// 那么 (a &gt;&gt;&gt; i) &gt;= b 永远为 true，但是 (a &gt;&gt;&gt; i) - b &gt;= 0 为 false</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;&gt;&gt; i) - b &gt;= <span class="number">0</span>) &#123; <span class="comment">// a &gt;= (b &lt;&lt; i)</span></span><br><span class="line">            a -= (b &lt;&lt; i);</span><br><span class="line">            <span class="comment">// 代码优化：这里控制 res 大于等于 INT_MAX</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE - (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bug 修复：因为不能使用乘号，所以将乘号换成三目运算符</span></span><br><span class="line">    <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="002-二进制加法"><a href="#002-二进制加法" class="headerlink" title="002.二进制加法"></a>002.二进制加法</h3><p>给定两个 01 字符串 <code>a</code> 和 <code>b</code> ，请计算它们的和，并以二进制字符串的形式输出。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p>提示：</p>
<p>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。<br>1 &lt;= a.length, b.length &lt;= 10^4<br>字符串如果不是 “0” ，就都不含前导零。</p>
<p>方法一：模拟</p>
<p>借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;<span class="comment">//从最低位开始</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c != <span class="number">0</span>)&#123;<span class="comment">//未加完或者存在进位</span></span><br><span class="line">            <span class="keyword">int</span> numA = i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> numB = j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = numA + numB + c;</span><br><span class="line">            c = sum &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            sum = sum &gt;= <span class="number">2</span> ? (sum - <span class="number">2</span>) : sum;</span><br><span class="line">            res.append(sum);</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>复杂度分析</p>
<p>假设 n=max{∣a∣,∣b∣}。</p>
<p>时间复杂度：O(n)，这里的时间复杂度来源于顺序遍历 a 和 b。<br>空间复杂度：O(1)，除去答案所占用的空间，这里使用了常数个临时变量。</p>
<p>方法二：位运算</p>
<p>此方法字符串长度太长会溢出</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numa = Integer.parseInt(a, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> numb = Integer.parseInt(b,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> res = numa ^ numb;</span><br><span class="line">        <span class="keyword">int</span> carry = (numa &amp; numb) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (carry != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = res;</span><br><span class="line">            res ^= carry;</span><br><span class="line">            carry = (carry &amp; temp) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.toBinaryString(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="003-前n个数字二进制中1的个数"><a href="#003-前n个数字二进制中1的个数" class="headerlink" title="003.前n个数字二进制中1的个数"></a>003.前n个数字二进制中1的个数</h3><p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>
<p>说明 :</p>
<p>0 &lt;= n &lt;= 10^5</p>
<p>进阶:</p>
<p>给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？<br>要求算法的空间复杂度为 O(n) 。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。</p>
<p>方法一：最高有效位</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = res[i - j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：最低有效位</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = i % <span class="number">2</span> == <span class="number">0</span> ? res[i / <span class="number">2</span>] : res[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度都是O（n）</p>
<hr>
<h3 id="004-只出现一次的数字"><a href="#004-只出现一次的数字" class="headerlink" title="004.只出现一次的数字"></a>004.只出现一次的数字</h3><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 3 * 10^4<br>-2^31 &lt;= nums[i] &lt;= 2^31 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</p>
<p>进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>方法一：哈希表</p>
<p>使用哈希映射统计数组中每个元素的出现次数。对于哈希映射中的每个键值对，键表示一个元素，值表示其出现的次数。</p>
<p>在统计完成后，我们遍历哈希映射即可找出只出现一次的元素。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            freq.put(num, freq.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : freq.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey(), occ = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (occ == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 是数组的长度。</p>
<p>空间复杂度：O(n)。</p>
<p>方法二：依次确定每一个二进制位</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                total += ((num &gt;&gt; i)) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (total % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围<br>空间复杂度：O(1)</p>
<hr>
<h3 id="005-单词长度的最大乘积"><a href="#005-单词长度的最大乘积" class="headerlink" title="005.单词长度的最大乘积"></a>005.单词长度的最大乘积</h3><p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
<li><code>words[i]</code> 仅包含小写字母</li>
</ul>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用一个数组masks记录每个单词的状态</span></span><br><span class="line">        <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; masks.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                masks[i] |= (<span class="number">1</span> &lt;&lt; c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            String word1 = words[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">                String word2 = words[j];</span><br><span class="line">                <span class="comment">//masks中两元素值不相等，说明两个字符串不含有相同字符</span></span><br><span class="line">                <span class="keyword">if</span> ((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = Math.max(ans,word1.length() * word2.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2),n是字符串数组的长度</p>
<p>空间复杂度: O(n)</p>
<hr>
<h3 id="006-排序数组中两个数字之和"><a href="#006-排序数组中两个数字之和" class="headerlink" title="006.排序数组中两个数字之和"></a>006.排序数组中两个数字之和</h3><p>给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 &lt;= answer[0] &lt; answer[1] &lt; numbers.length 。</p>
<p>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p>
<p>提示：</p>
<p>2 &lt;= numbers.length &lt;= 3 * 10^4<br>-1000 &lt;= numbers[i] &lt;= 1000<br>numbers 按 递增顺序 排列<br>-1000 &lt;= target &lt;= 1000<br>仅存在一个有效答案</p>
<p>方法一：hash表</p>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(target - numbers[i]))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = hashmap.get(target - numbers[i]);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(numbers[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n);</p>
<p>空间复杂度：O(n);</p>
<p> 方法二：双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[l] + numbers[r] &lt; target)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[<span class="number">0</span>] = l;</span><br><span class="line">                res[<span class="number">1</span>] = r;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n);</p>
<p>空间复杂度：O(1);</p>
<hr>
<h3 id="007-数组中和为0的三个数"><a href="#007-数组中和为0的三个数" class="headerlink" title="007.数组中和为0的三个数"></a>007.数组中和为0的三个数</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<p>双指针法，先排序，然后从左往右遍历固定一个值，然后转化为两数之和</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		 <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] + nums[r] &gt; target)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[l] + nums[r] &lt; target)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));</span><br><span class="line">                    <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(l &lt; r &amp;&amp; nums[l] == nums[++l])) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(l &lt; r &amp;&amp; nums[r] == nums[--r])) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="008-和大于等于target的最短子数组"><a href="#008-和大于等于target的最短子数组" class="headerlink" title="008.和大于等于target的最短子数组"></a>008.和大于等于target的最短子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>提示：</p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p>滑动窗口法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = len;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; r &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; target)&#123;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span> (r &lt; len)&#123;</span><br><span class="line">                    cur += nums[r];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(r - l + <span class="number">1</span>,ans);</span><br><span class="line">                cur -= nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="009-乘积小于k的子数组"><a href="#009-乘积小于k的子数组" class="headerlink" title="009.乘积小于k的子数组"></a>009.乘积小于k的子数组</h3><p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
<p><strong>提示:</strong> </p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>0 &lt;= k &lt;= 10^6</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		  <span class="comment">//乘积小于K的子数组的个数</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//窗口左边界和右边界</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; nums.length)&#123;</span><br><span class="line">            total *= nums[r];</span><br><span class="line">            <span class="comment">//当窗口内数字乘积大于等于k时，窗口左边界向右移</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; total &gt;= k)&#123;</span><br><span class="line">                total /= nums[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有在窗口内有数字并且乘积小于k的情况下，ans累加，统计满足条件的子数组个数</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r)&#123;</span><br><span class="line">                ans += r - l + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="010-和为K的子数组"><a href="#010-和为K的子数组" class="headerlink" title="010.和为K的子数组"></a>010.和为K的子数组</h3><p>给定一个整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
<p>方法：前缀和</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            hashMap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                preSum += num;</span><br><span class="line">                res += hashMap.getOrDefault(preSum - k,<span class="number">0</span>);</span><br><span class="line">                hashMap.put(preSum,hashMap.getOrDefault(preSum,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n);</p>
<p>空间复杂度：O(n);</p>
<hr>
<h3 id="011-0和1个数相同的子数组"><a href="#011-0和1个数相同的子数组" class="headerlink" title="011.0和1个数相同的子数组"></a>011.0和1个数相同的子数组</h3><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ul>
<p>将0看作-1，问题转化为求和为0的最长连续子数组</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            preSum += nums[i] == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(preSum)) &#123;</span><br><span class="line">                res = Math.max(res, i - hashMap.get(preSum));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(preSum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n);</p>
<p>空间复杂度：O(n);</p>
<hr>
<h3 id="012-左右两边子数组的和相等"><a href="#012-左右两边子数组的和相等" class="headerlink" title="012.左右两边子数组的和相等"></a>012.左右两边子数组的和相等</h3><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p>
<p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>
<p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * cur + nums[i] == sum) <span class="keyword">return</span> i;</span><br><span class="line">            cur += nums[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="013-二维子矩阵的和"><a href="#013-二维子矩阵的和" class="headerlink" title="013.二维子矩阵的和"></a>013.二维子矩阵的和</h3><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<p>计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。<br>实现 NumMatrix 类：</p>
<p>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。</p>
<p>提示：</p>
<p>m == matrix.length<br>n == matrix[i].length<br>1 &lt;= m, n &lt;= 200<br>-105 &lt;= matrix[i][j] &lt;= 105<br>0 &lt;= row1 &lt;= row2 &lt; m<br>0 &lt;= col1 &lt;= col2 &lt; n<br>最多调用 10^4 次 sumRegion 方法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">		<span class="comment">//前缀和矩阵</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[][] sumMatrix;</span><br><span class="line">		<span class="comment">//构造器中初始化前缀和矩阵</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">            sumMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    sumMatrix[i][j] = sumMatrix[i - <span class="number">1</span>][j] + sumMatrix[i][j - <span class="number">1</span>] - sumMatrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sumMatrix[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - sumMatrix[row2 + <span class="number">1</span>][col1 ] - sumMatrix[row1][col2 + <span class="number">1</span>] + sumMatrix[row1][col1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：初始化 O(mn)，每次检索 O(1)，其中 m 和 n 分别是矩阵matrix 的行数和列数。<br>初始化需要遍历矩阵matrix 计算二维前缀和，时间复杂度是 O(mn)。<br>每次检索的时间复杂度是 O(1)。</p>
<p>空间复杂度：O(mn)，其中 m 和 n 分别是矩阵 matrix 的行数和列数。需要创建一个 m+1m+1 行 n+1n+1 列的二维前缀和数组sumMatrix。</p>
<hr>
<h3 id="014-字符串中的变位词"><a href="#014-字符串中的变位词" class="headerlink" title="014.字符串中的变位词"></a>014.字符串中的变位词</h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li>
<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>
</ul>
<p>滑动窗口法</p>
<p>由于变位词不会改变字符串中每个字符的个数，所以只有当两个字符串每个字符的个数均相等时，一个字符串才是另一个字符串的变位词。</p>
<p>根据这一性质，记 s1的长度为 n，我们可以遍历 s2中的每个长度为 n 的子串，判断子串和s1中每个字符的个数是否相等，若相等则说明该子串是s1的一个变位词。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//cnt统计字符数量</span></span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            cnt[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            cnt[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//diff统计窗口中字符串与s1中不同的字符个数</span></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diff == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len1; i &lt; len2; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>, y = s2.charAt(i - len1) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt[x] == <span class="number">0</span>) diff++;</span><br><span class="line">            cnt[x]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[x] == <span class="number">0</span>) diff--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[y] == <span class="number">0</span>) diff++;</span><br><span class="line">            cnt[y]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[y] == <span class="number">0</span>) diff--;</span><br><span class="line">            <span class="keyword">if</span> (diff == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n+m+∣Σ∣)，其中 nn 是字符串s1的长度，m 是字符串 s2的长度，Σ 是字符集，这道题中的字符集是小写字母，∣Σ∣=26。</p>
<p>空间复杂度：O(∣Σ∣)。</p>
<hr>
<h3 id="015-字符串中的所有变位词"><a href="#015-字符串中的所有变位词" class="headerlink" title="015.字符串中的所有变位词"></a>015.字符串中的所有变位词</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>变位词 指字母相同，但排列不同的字符串。</p>
<p>同14题</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li>
<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">		 List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; p.length()) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            cnt[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            cnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (diff == <span class="number">0</span>) res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p.length(); i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> l = s.charAt(i - p.length()) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == l)&#123;</span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">0</span>) res.add(i - p.length() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt[r] == <span class="number">0</span>) diff++;</span><br><span class="line">            cnt[r]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[r] == <span class="number">0</span>) diff--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[l] == <span class="number">0</span>) diff++;</span><br><span class="line">            cnt[l]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[l] == <span class="number">0</span>) diff--;</span><br><span class="line">            <span class="keyword">if</span> (diff == <span class="number">0</span>) res.add(i - p.length() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="016-不含重复字符的最长子字符串"><a href="#016-不含重复字符的最长子字符串" class="headerlink" title="016.不含重复字符的最长子字符串"></a>016.不含重复字符的最长子字符串</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长连续子字符串</strong> 的长度。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p>滑动窗口法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;<span class="comment">//窗口左端点与右端点</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];<span class="comment">//用来判断字符是否重复，也可用Hashmap</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> rightChar = s.charAt(right);</span><br><span class="line">            left = Math.max(left,ints[rightChar]);</span><br><span class="line">            maxLength = Math.max(maxLength,right - left + <span class="number">1</span>);</span><br><span class="line">            ints[rightChar] = right + <span class="number">1</span>;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="017-含所有字符的最短字符串"><a href="#017-含所有字符的最短字符串" class="headerlink" title="017.含所有字符的最短字符串"></a>017.含所有字符的最短字符串</h3><p>给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。</p>
<p>如果 s 中存在多个符合条件的子字符串，返回任意一个。</p>
<p>注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p>统计词频 + 滑动窗口</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//A~z 对应ASCII 65 ~ 122;   122 - 65 + 1 = 58，所以开辟60足够用了。</span></span><br><span class="line">        <span class="keyword">int</span>[] cnt1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">int</span>[] cnt2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length(), tLen = t.length();</span><br><span class="line">       <span class="comment">//统计出t中的词频</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            cnt1[t.charAt(i) - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//维护一个最小长度，用于判断是否更新res</span></span><br><span class="line">        <span class="keyword">int</span> minLength = sLen;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; sLen)&#123;</span><br><span class="line">            cnt2[s.charAt(right) - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="comment">//窗口内的字符包含t中的所有字符，并不断缩小左边界</span></span><br><span class="line">            <span class="keyword">while</span> (Cover(cnt1,cnt2))&#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt;= minLength)&#123;</span><br><span class="line">                    res = s.substring(left,right + <span class="number">1</span>);</span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//缩小左边界</span></span><br><span class="line">                cnt2[s.charAt(left) - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断count2是否每一个元素都大于count1,即滑动窗口内的字符是否包含t中的所有字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">Cover</span><span class="params">(<span class="keyword">int</span>[]cnt1,<span class="keyword">int</span>[]cnt2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt2[i] &lt; cnt1[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(N)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="018-有效的回文"><a href="#018-有效的回文" class="headerlink" title="018.有效的回文"></a>018.有效的回文</h3><p>给定一个字符串 <code>s</code> ，验证 <code>s</code> 是否是 <strong>回文串</strong> ，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>本题中，将空字符串定义为有效的 <strong>回文串</strong> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2 * 105</code></li>
<li>字符串 <code>s</code> 由 ASCII 字符组成</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !check(s.charAt(l)))&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !check(s.charAt(r)))&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isEquals(s.charAt(l),s.charAt(r))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//检测字符c是否为数字或字母</span></span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//忽略大小写比较两个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEquals</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c1 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c1 &lt;= <span class="string">&#x27;Z&#x27;</span>) c1 += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">if</span> (c2 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;Z&#x27;</span>) c2 += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> c1 == c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="019-最多删除一个字符得到回文"><a href="#019-最多删除一个字符得到回文" class="headerlink" title="019.最多删除一个字符得到回文"></a>019.最多删除一个字符得到回文</h3><p>给定一个非空字符串 <code>s</code>，请判断如果 <strong>最多</strong> 从字符串中删除一个字符能否得到一个回文字符串。</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p>双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 如果不相等，则分两种情况：删除左边的元素，或者右边的元素，再判断各自是否回文，满足一种即可。</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s,left + <span class="number">1</span>,right) || isPalindrome(s,left,right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断字符串 s 的 [l, r] 是否回文</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(l) != s.charAt(r)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="020-回文子字符串的个数"><a href="#020-回文子字符串的个数" class="headerlink" title="020.回文子字符串的个数"></a>020.回文子字符串的个数</h3><p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p>方法一：动态规划</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j][j + i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[j][j + i] = s.charAt(j) == s.charAt(j + i);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j][j + i] = dp[j + <span class="number">1</span>][j + i - <span class="number">1</span>] &amp;&amp; s.charAt(j) == s.charAt(j + i);</span><br><span class="line">                &#125;</span><br><span class="line">                ans += dp[j][j + i] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(N^2)</p>
<p>空间复杂度：O(N^2)</p>
<p>方法二：中心扩展法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//长度为 n 的字符串会生成 2n−1 组回文中心,遍历每一个回文中心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//回文中心的左右边界</span></span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; s.charAt(l) == s.charAt(r))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                l--;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(N^2)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="021-删除链表的倒数第n个结点"><a href="#021-删除链表的倒数第n个结点" class="headerlink" title="021.删除链表的倒数第n个结点"></a>021.删除链表的倒数第n个结点</h3><p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p>方法一：利用hashmap，一次遍历删除结点</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	   <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HashMap&lt;Integer, ListNode&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将所有结点放入hashmap</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            hashmap.put(i,node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode preNode = hashmap.get(i - n);<span class="comment">//要删除结点的前一个结点</span></span><br><span class="line">        ListNode deletNode = hashmap.get(i - n + <span class="number">1</span>);<span class="comment">//要删除的结点</span></span><br><span class="line">        ListNode nextNode = hashmap.get(i - n + <span class="number">2</span>);<span class="comment">//要删除结点的下一个结点</span></span><br><span class="line">        <span class="comment">//如果要删除的结点是头节点，返回头节点的下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (deletNode == head)&#123;</span><br><span class="line">            head.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> hashmap.get(i - n + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        deletNode.next = <span class="keyword">null</span>;</span><br><span class="line">        preNode.next = nextNode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法二：双指针（快慢指针）+ 哨兵节点，优化了空间复杂度</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//快指针</span></span><br><span class="line">        ListNode fast = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fast.next = head;</span><br><span class="line">        <span class="comment">//辅助头节点（哨兵）</span></span><br><span class="line">        head = fast;</span><br><span class="line">        <span class="comment">//慢指针</span></span><br><span class="line">        ListNode slow = fast;</span><br><span class="line">        <span class="comment">//fast指针先走n步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow指向要删除节点的前一个节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="022-链表中环的入口节点"><a href="#022-链表中环的入口节点" class="headerlink" title="022.链表中环的入口节点"></a>022.链表中环的入口节点</h3><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p>最佳方法：双指针之快慢指针</p>
<p>也可以用hashset，但与双指针解法相比需要额外的O(n)的空间复杂度</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//快指针一次走一步，慢指针一次走两步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当快指针与慢指针第一次相等时，fast回到头节点，接下来两个指针每次走一步，第二次相遇时即为入环节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="023-两个链表的第一个重合节点"><a href="#023-两个链表的第一个重合节点" class="headerlink" title="023.两个链表的第一个重合节点"></a>023.两个链表的第一个重合节点</h3><p>给定两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p>方法一：哈希表</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HashSet&lt;ListNode&gt; hashset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">            hashset.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (headB != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hashset.add(headB))&#123;</span><br><span class="line">                headB = headB.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(m + n)</p>
<p>空间复杂度：O(m + n)</p>
<p>方法二：双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode ptr1 = headA, ptr2 = headB;</span><br><span class="line">        <span class="comment">//两个链表不相交时，则两个指针会同时到达两个链表的尾节点，然后同时变成空值null，此时返回null，退出while循环</span></span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2)&#123;</span><br><span class="line">            ptr1 = ptr1 == <span class="keyword">null</span> ? headB : ptr1.next;</span><br><span class="line">            ptr2 = ptr2 == <span class="keyword">null</span> ? headA : ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(m + n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="024-反转链表"><a href="#024-反转链表" class="headerlink" title="024.反转链表"></a>024.反转链表</h3><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;= Node.val &lt;= 5000</p>
<p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p>方法一：递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode node = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法二：迭代</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre = head,cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">       <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="025-链表中的两数相加"><a href="#025-链表中的两数相加" class="headerlink" title="025.链表中的两数相加"></a>025.链表中的两数相加</h3><p>给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>提示：</p>
<p>链表的长度范围为 [1, 100]<br>0 &lt;= node.val &lt;= 9<br>输入数据保证链表代表的数字无前导 0</p>
<p>进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>
<p>使用两个辅助栈，分别将两个链表从头到尾进栈，然后每次同时出栈，就可以实现右端对齐相加。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个辅助栈</span></span><br><span class="line">	    Deque&lt;Integer&gt; stack1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个链表分别入栈</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = stack1.pop() + stack2.pop();</span><br><span class="line">        <span class="keyword">int</span> c = val / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//尾节点</span></span><br><span class="line">        ListNode cur = <span class="keyword">new</span> ListNode(val % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            <span class="keyword">int</span> b = stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            val = a + b + c;</span><br><span class="line">            c = val / <span class="number">10</span>;</span><br><span class="line">            ListNode pre = <span class="keyword">new</span> ListNode(val % <span class="number">10</span>);</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在进位，则新建头节点返回</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode head = <span class="keyword">new</span> ListNode(c);</span><br><span class="line">            head.next = cur;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(m + n)</p>
<hr>
<h3 id="026-重排链表"><a href="#026-重排链表" class="headerlink" title="026.重排链表"></a>026.重排链表</h3><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p> L0 → L1 → … → Ln-1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</p>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表的长度范围为 <code>[1, 5 * 104]</code></li>
<li><code>1 &lt;= node.val &lt;= 1000</code></li>
</ul>
<p> 方法一：线性表</p>
<p>因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。</p>
<p>因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		 List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j )&#123;</span><br><span class="line">            list.get(i).next = list.get(j);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">break</span>;</span><br><span class="line">            list.get(j).next = list.get(i);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(i).next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法二：寻找链表中点 + 链表逆序 + 合并链表</p>
<ol>
<li>找到原链表的中点</li>
<li>将原链表的右半端反转</li>
<li>将原链表的两端合并</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将原链表的两端合并</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode mid = findMidNode(head);</span><br><span class="line">        ListNode node1 = head,node2 = reverseListNode(mid);</span><br><span class="line">        ListNode temp1,temp2;</span><br><span class="line">        <span class="keyword">while</span> (node1 != node2)&#123;</span><br><span class="line">            temp1 = node1.next;</span><br><span class="line">            node1.next = node2;</span><br><span class="line">            node1 = temp1;</span><br><span class="line">            <span class="keyword">if</span> (temp1 == node2) <span class="keyword">break</span>;</span><br><span class="line">            temp2 = node2.next;</span><br><span class="line">            node2.next = temp1;</span><br><span class="line">            node2 = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到原链表的中点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMidNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原链表的右半端反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListNode</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        ListNode pre = node,cur = node.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="027-回文链表"><a href="#027-回文链表" class="headerlink" title="027.回文链表"></a>027.回文链表</h3><p>给定一个链表的 <strong>头节点</strong> <code>head</code> <strong>，</strong>请判断其是否为回文链表。</p>
<p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表 L 的长度范围为 [1, 105]</li>
<li>0 &lt;= node.val &lt;= 9</li>
</ul>
<p><strong>进阶：</strong>能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = findMidNode(head);</span><br><span class="line">        ListNode node1 = head;</span><br><span class="line">        ListNode node2 = reverseListNode(mid);</span><br><span class="line">        <span class="keyword">while</span> (node2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到原链表的中点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMidNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原链表的右半端反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListNode</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        ListNode pre = node,cur = node.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="028-展平多级双向链表"><a href="#028-展平多级双向链表" class="headerlink" title="028.展平多级双向链表"></a>028.展平多级双向链表</h3><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。</p>
<p><strong>提示：</strong></p>
<ul>
<li>节点数目不超过 <code>1000</code></li>
<li><code>1 &lt;= Node.val &lt;= 10^5</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node prev;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//记录当前节点的下一个节点</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">//如果当前节点子节点不为空，则先递归遍历子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.child != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//递归遍历子节点</span></span><br><span class="line">                Node flatten = flatten(node.child);</span><br><span class="line">                <span class="comment">//与父节点连接，父节点的子节点置空</span></span><br><span class="line">                node.child = <span class="keyword">null</span>;</span><br><span class="line">                flatten.prev = node;</span><br><span class="line">                node.next = flatten;</span><br><span class="line">                Node childEndNode = flatten;</span><br><span class="line">                <span class="comment">//遍历子节点，找到递归遍历后子层级的尾节点</span></span><br><span class="line">                <span class="keyword">while</span> (childEndNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    childEndNode = childEndNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//子层级的尾节点与父层级当前节点的下一个节点建立连接</span></span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    next.prev = childEndNode;</span><br><span class="line">                &#125;</span><br><span class="line">                childEndNode.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前节点右移</span></span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n),递归需要栈空间</p>
<hr>
<h3 id="029-排序的循环链表"><a href="#029-排序的循环链表" class="headerlink" title="029.排序的循环链表"></a>029.排序的循环链表</h3><p>给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。</p>
<p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p>
<p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p>
<p>如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p>
<p>提示：</p>
<p>0 &lt;= Number of Nodes &lt;= 5 * 10^4<br>-10^6 &lt;= Node.val &lt;= 10^6<br>-10^6 &lt;= insertVal &lt;= 10^6</p>
<p>插入点只有两种情况，在中间能找到cur.val =&lt; insertVal &lt;= cur.next.val,即在中间插入，否则必定在跳跃点插入</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要插入的节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">        <span class="comment">//列表为空，新建</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="comment">//寻找要在哪个节点之后插入新节点（cur)</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != head)&#123;</span><br><span class="line">            <span class="comment">//cur是首尾相接点（边界）</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next.val &lt; cur.val &amp;&amp; (insertVal &gt;= cur.val || insertVal &lt;= cur.next.val))&#123;</span><br><span class="line">                <span class="comment">//新插入节点的值&gt;=最大节点或者&lt;=最小节点，则在边界处插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新插入节点的值大小不在首尾交接处</span></span><br><span class="line">            <span class="keyword">if</span> (insertVal &gt;= cur.val &amp;&amp; insertVal &lt;= cur.next.val) <span class="keyword">break</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = cur.next;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="030-插入、删除和随机访问都是O-1-的容器"><a href="#030-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="030.插入、删除和随机访问都是O(1)的容器"></a>030.插入、删除和随机访问都是O(1)的容器</h3><p>设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：</p>
<p>insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。<br>remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。<br>getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。</p>
<p><strong>提示：</strong></p>
<ul>
<li>-2^31 &lt;= val &lt;= 2^31 - 1</li>
<li>最多进行 2 * 105 次 insert ， remove 和 getRandom 方法调用</li>
<li>当调用 getRandom 方法时，集合中至少有一个元素</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"><span class="comment">//list用来存储元素</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="comment">//hashMap用来存储值到列表中索引的映射</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Integer&gt; hashMap;</span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//val已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//val不存在，执行插入操作</span></span><br><span class="line">        hashMap.put(val,list.size());</span><br><span class="line">        list.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hashMap.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//要删除元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> i = hashMap.get(val);</span><br><span class="line">        <span class="comment">//list中最后位置的索引</span></span><br><span class="line">        <span class="keyword">int</span> j = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//为了getRandom方法能够随机获得元素，将i，j处的元素互换，使得每次从list集合末尾删除</span></span><br><span class="line">        list.set(i,list.get(j));</span><br><span class="line">        <span class="comment">//更新索引</span></span><br><span class="line">        hashMap.put(list.get(i),i);</span><br><span class="line">        <span class="comment">//执行删除操作</span></span><br><span class="line">        list.remove(j);</span><br><span class="line">        hashMap.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(1)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="031-最近最少使用缓存"><a href="#031-最近最少使用缓存" class="headerlink" title="031.最近最少使用缓存"></a>031.最近最少使用缓存</h3><p>运用所掌握的数据结构，设计和实现一个  LRU (Least Recently Used，最近最少使用) 缓存机制 。</p>
<p>实现 LRUCache 类：</p>
<p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p>提示：</p>
<p>1 &lt;= capacity &lt;= 3000<br>0 &lt;= key &lt;= 10000<br>0 &lt;= value &lt;= 10^5<br>最多调用 2 * 10^5 次 get 和 put</p>
<p>进阶：是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">        DlistNode pre;</span><br><span class="line">        DlistNode next;</span><br><span class="line"></span><br><span class="line">        DlistNode() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DlistNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DlistNode(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际缓存</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, DlistNode&gt; cache;</span><br><span class="line">    <span class="comment">//虚拟头节点与尾节点</span></span><br><span class="line">    <span class="keyword">private</span> DlistNode head, tail;</span><br><span class="line">    <span class="comment">//缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DlistNode();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DlistNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">//更新链表</span></span><br><span class="line">            <span class="comment">//1.删除原链表key节点</span></span><br><span class="line">            deleteNode(cache.get(key));</span><br><span class="line">            <span class="comment">//2.将key节点添加到头节点</span></span><br><span class="line">            addToHead(cache.get(key));</span><br><span class="line">            <span class="keyword">return</span> cache.get(key).val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = cache.size();</span><br><span class="line">        DlistNode node = cache.get(key);</span><br><span class="line">        <span class="comment">//cache中包含key</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.val = value;</span><br><span class="line">            cache.put(key, node);</span><br><span class="line">            <span class="comment">//更新链表</span></span><br><span class="line">            <span class="comment">//1.删除原链表key节点</span></span><br><span class="line">            deleteNode(node);</span><br><span class="line">            <span class="comment">//2.将key节点添加到头节点</span></span><br><span class="line">            addToHead(node);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//cache中不包含key</span></span><br><span class="line">            <span class="comment">//cache已满</span></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">                node = tail.pre;</span><br><span class="line">                <span class="comment">//容量达到上限</span></span><br><span class="line">                <span class="comment">//删除最久未使用的数据（链表尾节点）</span></span><br><span class="line">                deleteNode(node);</span><br><span class="line">                cache.remove(node.key);</span><br><span class="line">            &#125;</span><br><span class="line">            DlistNode dlistNode = <span class="keyword">new</span> DlistNode(key, value);</span><br><span class="line">            cache.put(key,dlistNode);</span><br><span class="line">            addToHead(dlistNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除链表中的某个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(DlistNode node)</span> </span>&#123;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将某个节点添加到链表的头部</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DlistNode node)</span> </span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next.pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="032-有效的变位词"><a href="#032-有效的变位词" class="headerlink" title="032.有效的变位词"></a>032.有效的变位词</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同且字符顺序不完全相同，则称 s 和 t 互为变位词（字母异位词）。</p>
<p>提示:</p>
<p>1 &lt;= s.length, t.length &lt;= 5 * 104<br>s and t 仅包含小写字母</p>
<p>进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">if</span> (s.length() != t.length() || s.equals(t)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ints[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            ints[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (ints[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p>进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.length() != t.length() || s.equals(t)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            map.put(t.charAt(i),map.getOrDefault(t.charAt(i),<span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(t.charAt(i)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="033-变位词组"><a href="#033-变位词组" class="headerlink" title="033.变位词组"></a>033.变位词组</h3><p>给定一个字符串数组 <code>strs</code> ，将 <strong>变位词</strong> 组合在一起。 可以按任意顺序返回结果列表。</p>
<p><strong>注意：</strong>若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 104</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">		 HashMap&lt;String, List&lt;String&gt;&gt; stringListHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="comment">//生成key，每个key指向一组变位词集合</span></span><br><span class="line">            String key = <span class="keyword">new</span> String(chars);</span><br><span class="line">            List&lt;String&gt; list = stringListHashMap.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            list.add(strs[i]);</span><br><span class="line">            stringListHashMap.put(key,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(stringListHashMap.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nklogk)</p>
<p>空间复杂度：O(nk)</p>
<hr>
<h3 id="034-外星语言是否排序"><a href="#034-外星语言是否排序" class="headerlink" title="034.外星语言是否排序"></a>034.外星语言是否排序</h3><p>某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。</p>
<p>给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。</p>
<p>提示：</p>
<p>1 &lt;= words.length &lt;= 100<br>1 &lt;= words[i].length &lt;= 20<br>order.length == 26<br>在 words[i] 和 order 中的所有字符都是英文小写字母。</p>
<p>解题思路：有序性可以传递，每次比较相邻的两个单词是否有序。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); ++i)</span><br><span class="line">            index[order.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line"></span><br><span class="line">        search: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            String word1 = words[i];</span><br><span class="line">            String word2 = words[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the first difference word1[k] != word2[k].</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Math.min(word1.length(), word2.length()); ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(k) != word2.charAt(k)) &#123;</span><br><span class="line">                    <span class="comment">// If they compare badly, it&#x27;s not sorted.</span></span><br><span class="line">                    <span class="keyword">if</span> (index[word1.charAt(k) - <span class="string">&#x27;a&#x27;</span>] &gt; index[word2.charAt(k) - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span> search;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn&#x27;t find a first difference, the</span></span><br><span class="line">            <span class="comment">// words are like (&quot;app&quot;, &quot;apple&quot;).</span></span><br><span class="line">            <span class="keyword">if</span> (word1.length() &gt; word2.length())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="035-最小时间差"><a href="#035-最小时间差" class="headerlink" title="035.最小时间差"></a>035.最小时间差</h3><p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= timePoints &lt;= 2 * 10^4</code></li>
<li><code>timePoints[i]</code> 格式为 <strong>“HH:MM”</strong></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">        Collections.sort(timePoints);</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> t0Minutes = getMinutes(timePoints.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> preMinutes = t0Minutes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timePoints.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minutes = getMinutes(timePoints.get(i));</span><br><span class="line">            ans = Math.min(ans, minutes - preMinutes); <span class="comment">// 相邻时间的时间差</span></span><br><span class="line">            preMinutes = minutes;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.min(ans, t0Minutes + <span class="number">1440</span> - preMinutes); <span class="comment">// 首尾时间的时间差</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinutes</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((t.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (t.charAt(<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>)) * <span class="number">60</span> + (t.charAt(<span class="number">3</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (t.charAt(<span class="number">4</span>) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nklogk)</p>
<p>空间复杂度：O(nk)</p>
<hr>
<h3 id="036-后缀表达式"><a href="#036-后缀表达式" class="headerlink" title="036.后缀表达式"></a>036.后缀表达式</h3><p>根据 逆波兰表示法，求该后缀表达式的计算结果。</p>
<p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>利用栈解决</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            String token = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                stk.push(Integer.parseInt(token));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = stk.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = stk.pop();</span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        stk.push(num1 + num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        stk.push(num2 - num1);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        stk.push(num2 * num1);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        stk.push(num2 / num1);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="string">&quot;+&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;-&quot;</span>.equals(token)</span><br><span class="line">                &amp;&amp; !<span class="string">&quot;*&quot;</span>.equals(token) &amp;&amp; !<span class="string">&quot;/&quot;</span>.equals(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="037-小行星碰撞"><a href="#037-小行星碰撞" class="headerlink" title="037.小行星碰撞"></a>037.小行星碰撞</h3><p>给定一个整数数组 asteroids，表示在同一行的小行星。</p>
<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>
<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>
<p>提示：</p>
<p>2 &lt;= asteroids.length &lt;= 10^4<br>-1000 &lt;= asteroids[i] &lt;= 1000<br>asteroids[i] != 0</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; asteroids.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.isEmpty() || asteroids[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stk.push(asteroids[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &gt; <span class="number">0</span> &amp;&amp; stk.peek() &lt; -asteroids[i]) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk.isEmpty() || stk.peek() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                stk.push(asteroids[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk.peek() == -asteroids[i]) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = stk.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[len - <span class="number">1</span> - i] = stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="038-每日温度"><a href="#038-每日温度" class="headerlink" title="038.每日温度"></a>038.每日温度</h3><p>请根据每日 气温 列表 temperatures ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 10^5</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
<p>方法：单调栈</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">		Deque&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stk.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> pop = stk.pop();</span><br><span class="line">                res[pop] = i - pop;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="039-直方图最大矩形面积"><a href="#039-直方图最大矩形面积" class="headerlink" title="039.直方图最大矩形面积"></a>039.直方图最大矩形面积</h3><p>给定非负整数数组 heights ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= heights.length &lt;=105</code></li>
<li><code>0 &lt;= heights[i] &lt;= 104</code></li>
</ul>
<p>方法一：利用单调栈分别求出左右边界</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stk1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stk2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//记录左边界的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//记录右边界的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk1.isEmpty() &amp;&amp; heights[stk1.peek()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = stk1.pop();</span><br><span class="line">                right[p1] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            stk1.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk1.isEmpty())&#123;</span><br><span class="line">            right[stk1.poll()] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk2.isEmpty() &amp;&amp; heights[stk2.peek()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> p2 = stk2.pop();</span><br><span class="line">                left[p2] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            stk2.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk2.isEmpty())&#123;</span><br><span class="line">            left[stk2.pop()] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> width = right[i] - left[i] - <span class="number">1</span>;</span><br><span class="line">            res = Math.max(heights[i] * width,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法二：进阶，常数时间优化，利用一个单调栈，所有元素一次入栈求出左边界，一次出栈求出右边界</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加哨兵，确保所有元素在一次遍历完后都能完成入栈出栈操作</span></span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            newHeights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//一次入栈出栈就可以确定左右边界</span></span><br><span class="line">            <span class="keyword">while</span> (newHeights[stk.peek()] &gt; newHeights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> height = newHeights[stk.pop()];</span><br><span class="line">                <span class="keyword">int</span> width = i - stk.peek() - <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res,height * width);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="040-矩阵中的最大矩形"><a href="#040-矩阵中的最大矩形" class="headerlink" title="040.矩阵中的最大矩形"></a>040.矩阵中的最大矩形</h3><p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>matrix</code> ，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<p><strong>注意：</strong>此题 <code>matrix</code> 输入格式为一维 <code>01</code> 字符串数组。</p>
<p>提示：</p>
<p>rows == matrix.length<br>cols == matrix[0].length<br>0 &lt;= row, cols &lt;= 200<br>matrix[i][j] 为 ‘0’ 或 ‘1’</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(String[] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span>[][] left = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"><span class="comment">//left[i][j] 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            String str = matrix[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(j) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    left[i][j] = (j == <span class="number">0</span> ? <span class="number">0</span> : left[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 对于每一列，使用基于柱状图的方法</span></span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt; left[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> height = left[stack.pop()][j];</span><br><span class="line">                    <span class="keyword">int</span> width = stack.isEmpty() ? i : i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                    ret = Math.max(ret,height * width);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> height = left[stack.pop()][j];</span><br><span class="line">                <span class="keyword">int</span> width = stack.isEmpty() ? m : m - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                ret = Math.max(ret,height * width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h3 id="041-滑动窗口的平均值"><a href="#041-滑动窗口的平均值" class="headerlink" title="041.滑动窗口的平均值"></a>041.滑动窗口的平均值</h3><p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p>
<p>实现 MovingAverage 类：</p>
<p>MovingAverage(int size) 用窗口大小 size 初始化对象。<br>double next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= size &lt;= 1000</code></li>
<li><code>-105 &lt;= val &lt;= 105</code></li>
<li>最多调用 <code>next</code> 方法 <code>104</code> 次</li>
</ul>
<p>利用队列实现滑动窗口</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = queue.size();</span><br><span class="line">        <span class="keyword">if</span> (len == size)&#123;</span><br><span class="line">            sum -= queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(val);</span><br><span class="line">        sum += val;</span><br><span class="line">        <span class="keyword">return</span> sum / queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj.next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="042-最近请求次数"><a href="#042-最近请求次数" class="headerlink" title="042.最近请求次数"></a>042.最近请求次数</h3><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p>
<p>请实现 RecentCounter 类：</p>
<p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= t &lt;= 10^9</code></li>
<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>
<li>至多调用 <code>ping</code> 方法 <code>10^4</code> 次</li>
</ul>
<p>队列实现</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        queue.add(t);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peek() &lt; t -<span class="number">3000</span>)&#123;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="043-往完全二叉树中添加节点"><a href="#043-往完全二叉树中添加节点" class="headerlink" title="043.往完全二叉树中添加节点"></a>043.往完全二叉树中添加节点</h3><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1 个节点）的，并且所有的节点都尽可能地集中在左侧。</p>
<p>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：</p>
<p>CBTInserter(TreeNode root) 使用根节点为 root 的给定树初始化该数据结构；<br>CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；<br>CBTInserter.get_root() 将返回树的根节点。</p>
<p>提示：</p>
<p>最初给定的树是完全二叉树，且包含 1 到 1000 个节点。<br>每个测试用例最多调用 CBTInserter.insert  操作 10000 次。<br>给定节点或插入节点的每个值都在 0 到 5000 之间。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span> </span>&#123;</span><br><span class="line"> TreeNode root;</span><br><span class="line">    Deque&lt;TreeNode&gt; deque;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CBTInserter</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">        deque = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// 利用队列层序遍历二叉树，</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">//遇到左右孩子节点不全的，加入双端队列</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.right == <span class="keyword">null</span>)</span><br><span class="line">                deque.offerLast(node);</span><br><span class="line">            <span class="comment">//层序遍历</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        TreeNode node = deque.peekFirst();</span><br><span class="line">         <span class="comment">//新加入的节点一定左右孩子节点不全，加入双端队列</span></span><br><span class="line">        deque.offerLast(<span class="keyword">new</span> TreeNode(v));</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)</span><br><span class="line">            node.left = deque.peekLast();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = deque.peekLast();</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">get_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CBTInserter obj = new CBTInserter(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.insert(v);</span></span><br><span class="line"><span class="comment"> * TreeNode param_2 = obj.get_root();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="044-二叉树每层的最大值"><a href="#044-二叉树每层的最大值" class="headerlink" title="044.二叉树每层的最大值"></a>044.二叉树每层的最大值</h3><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p>
<p><strong>提示：</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,10^4]</code></li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li>
</ul>
<p>方法：利用队列实现二叉树的层序遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//每一层维护一个变量，用于存储最大值</span></span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">//每一层元素的个数</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll = queue.poll();</span><br><span class="line">                max = Math.max(max,poll.val);</span><br><span class="line">                <span class="comment">//添加下一层元素</span></span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) queue.add(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) queue.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="045-二叉树最底层最左边的值"><a href="#045-二叉树最底层最左边的值" class="headerlink" title="045.二叉树最底层最左边的值"></a>045.二叉树最底层最左边的值</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[1,10^4]</code></li>
<li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code> </li>
</ul>
<p>方法一：层序遍历（bfs）</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> deepAndLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            deepAndLeft = queue.peek().val;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) queue.add(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) queue.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deepAndLeft;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法一：dfs</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> curDepth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        left = curDepth &gt; maxDepth ? root.val : left;</span><br><span class="line">        maxDepth = Math.max(curDepth, maxDepth); </span><br><span class="line">        dfs(root.left, curDepth + <span class="number">1</span>);</span><br><span class="line">        dfs(root.right, curDepth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="046-二叉树的右侧视图"><a href="#046-二叉树的右侧视图" class="headerlink" title="046.二叉树的右侧视图"></a>046.二叉树的右侧视图</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code> </li>
</ul>
<p>二叉树层序遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll = queue.poll();</span><br><span class="line">                right = poll.val;</span><br><span class="line">                <span class="comment">//添加下一层元素</span></span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) queue.add(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) queue.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="047-二叉树剪枝"><a href="#047-二叉树剪枝" class="headerlink" title="047.二叉树剪枝"></a>047.二叉树剪枝</h3><p>给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。</p>
<p>节点 node 的子树为 node 本身，以及所有 node 的后代。</p>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[1,200]</code></li>
<li>二叉树节点的值只会是 <code>0</code> 或 <code>1</code></li>
</ul>
<p>方法：递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(h)，h为树的高度</p>
<hr>
<h3 id="048-序列化与反序列化二叉树"><a href="#048-序列化与反序列化二叉树" class="headerlink" title="048.序列化与反序列化二叉树"></a>048.序列化与反序列化二叉树</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示：</p>
<p>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。<br>树中结点数在范围 [0, 104] 内<br>-1000 &lt;= Node.val &lt;= 1000</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="comment">//利用先序遍历序列化二叉树，空结点用“#”代替</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;# &quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            serialize(root.left);</span><br><span class="line">            serialize(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] strs = data.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        LinkedList&lt;String&gt; dataList = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(strs));</span><br><span class="line">        <span class="keyword">return</span> rdeserialize(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">rdeserialize</span><span class="params">(List&lt;String&gt; dataList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataList.get(<span class="number">0</span>).equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">            dataList.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(dataList.get(<span class="number">0</span>)));</span><br><span class="line">        dataList.remove(<span class="number">0</span>);</span><br><span class="line">        root.left = rdeserialize(dataList);</span><br><span class="line">        root.right = rdeserialize(dataList);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="049-从根节点到叶节点的路径数字之和"><a href="#049-从根节点到叶节点的路径数字之和" class="headerlink" title="049.从根节点到叶节点的路径数字之和"></a>049.从根节点到叶节点的路径数字之和</h3><p>给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。</p>
<p>每条从根节点到叶节点的路径都代表一个数字：</p>
<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>
<p>叶节点 是指没有子节点的节点。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>树的深度不超过 <code>10</code></li>
</ul>
<p>思路：深度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> prevSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = prevSum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="comment">//是叶节点时</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(root.left, sum) + dfs(root.right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    另外一种写法：</span></span><br><span class="line"><span class="comment">    class Solution &#123;</span></span><br><span class="line"><span class="comment">    	int sum = 0;</span></span><br><span class="line"><span class="comment">    int temp = 0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public int sumNumbers(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">        dfs(root);</span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public void dfs(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">        if (root == null) return;</span></span><br><span class="line"><span class="comment">        if (root.left == null &amp;&amp; root.right == null) &#123;</span></span><br><span class="line"><span class="comment">            temp = temp * 10 + root.val;</span></span><br><span class="line"><span class="comment">            sum += temp;</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        temp = temp * 10 + root.val;</span></span><br><span class="line"><span class="comment">        dfs(root.left);</span></span><br><span class="line"><span class="comment">        if (root.left != null)</span></span><br><span class="line"><span class="comment">        	//回溯</span></span><br><span class="line"><span class="comment">            temp = (temp - root.left.val) / 10;</span></span><br><span class="line"><span class="comment">        dfs(root.right);</span></span><br><span class="line"><span class="comment">        if (root.right != null)</span></span><br><span class="line"><span class="comment">            temp = (temp - root.right.val) / 10;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="050-向下的路径结点之和"><a href="#050-向下的路径结点之和" class="headerlink" title="050.向下的路径结点之和"></a>050.向下的路径结点之和</h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>
<li><code>-109 &lt;= Node.val &lt;= 109</code> </li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code> </li>
</ul>
<p>方法一：深度优先搜索</p>
<p>穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode poll = queue.poll();</span><br><span class="line">            res += pathNum(poll,targetSum);</span><br><span class="line">            <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathNum</span><span class="params">(TreeNode root,<span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == targetSum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + pathNum(root.left,targetSum - root.val) + pathNum(root.right,targetSum - root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pathNum(root.left,targetSum - root.val) + pathNum(root.right,targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(n)</p>
<p>方法二:前缀和</p>
<p>利用先序遍历二叉树，记录下根节点root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和cur 减去 targetSum。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        Map&lt;Long,Integer&gt; prefix = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        prefix.put(<span class="number">0L</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(root,targetSum,<span class="number">0</span>,prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> targetSum,<span class="keyword">long</span> cur,Map&lt;Long,Integer&gt; prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        cur += root.val;</span><br><span class="line">        res += prefix.getOrDefault(cur - targetSum,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//更新map</span></span><br><span class="line">        prefix.put(cur,prefix.getOrDefault(cur,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        res += dfs(root.left,targetSum,cur,prefix);</span><br><span class="line">        res += dfs(root.right,targetSum,cur,prefix);</span><br><span class="line">        <span class="comment">//回溯，恢复map</span></span><br><span class="line">        prefix.put(cur,prefix.getOrDefault(cur,<span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h2 id="051-…"><a href="#051-…" class="headerlink" title="051-…"></a>051-…</h2><h3 id="051-节点之和最大的路径"><a href="#051-节点之和最大的路径" class="headerlink" title="051.节点之和最大的路径"></a>051.节点之和最大的路径</h3><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 10^4]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">    <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左子节点最大贡献</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = Math.max(dfs(root.left),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//右子节点最大贡献</span></span><br><span class="line">        <span class="keyword">int</span> rightGain = Math.max(dfs(root.right),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> curSum = root.val + leftGain + rightGain;</span><br><span class="line">        maxSum = Math.max(maxSum,curSum);</span><br><span class="line">        <span class="comment">//取左右节点贡献最大的</span></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(leftGain,rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="052-展平二叉搜索树"><a href="#052-展平二叉搜索树" class="headerlink" title="052.展平二叉搜索树"></a>052.展平二叉搜索树</h3><p>给你一棵二叉搜索树，请 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的取值范围是 <code>[1, 100]</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>思路：递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode leftNode = increasingBST(root.left);</span><br><span class="line">        TreeNode rightNode = increasingBST(root.right);</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode node = leftNode;</span><br><span class="line">            <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        <span class="keyword">if</span> (leftNode == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="053-二叉搜索树中的中序后继"><a href="#053-二叉搜索树中的中序后继" class="headerlink" title="053.二叉搜索树中的中序后继"></a>053.二叉搜索树中的中序后继</h3><p>给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。</p>
<p>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 10^4]</code> 内。</li>
<li><code>-10%5 &lt;= Node.val &lt;= 10^5</code></li>
<li>树中各节点的值均保证唯一。</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录当前比 p 节点大的节点</span></span><br><span class="line">        TreeNode ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果当前节点 &gt; p，则更新当前比 p 节点大的节点 ans , 同时去左子树进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &gt; p.val)&#123;</span><br><span class="line">                ans = root;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">// 如果当前节点 &lt; p , 则到右子树进行搜索</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h3 id="054-所有大于等于节点的值之和"><a href="#054-所有大于等于节点的值之和" class="headerlink" title="054.所有大于等于节点的值之和"></a>054.所有大于等于节点的值之和</h3><p>给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数介于 <code>0</code> 和 <code>10^4</code> 之间。</li>
<li>每个节点的值介于 <code>-10^4</code> 和 <code>10^4</code> 之间。</li>
<li>树中的所有值 <strong>互不相同</strong> 。</li>
<li>给定的树为二叉搜索树。</li>
</ul>
<p>思路：按照右根左的顺序遍历二叉树，累加节点值</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//递归右子节点</span></span><br><span class="line">        TreeNode node = convertBST(root.right);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果右子节点值不为空，找到右子节点的最左子节点，将其取值累加到当前根节点</span></span><br><span class="line">            TreeNode leftNode = getLeftNode(node);</span><br><span class="line">            root.val += leftNode.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若当前根节点有左子节点，遍历找到左子节点的最右节点，将其值加上当前根节点的值，然后递归左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode rightNode = getRightNode(root.left);</span><br><span class="line">            rightNode.val += root.val;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最左子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeftNode</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最右子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRightNode</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>代码二：用一个变量sum记录累加值</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        process(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        process(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        process(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="055-二叉搜索树迭代器"><a href="#055-二叉搜索树迭代器" class="headerlink" title="055.二叉搜索树迭代器"></a>055.二叉搜索树迭代器</h3><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<p>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>int next()将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>
<p>可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<p>提示：</p>
<p>树中节点的数目在范围 [1, 105] 内<br>0 &lt;= Node.val &lt;= 106<br>最多调用 105 次 hasNext 和 next 操作</p>
<p>进阶：</p>
<p>你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。</p>
<p>思路：自定义栈，通过迭代的方式实现二叉树中序遍历，实时维护当前栈的情况</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode root;</span><br><span class="line">    Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                root = stk.pop();</span><br><span class="line">                res = root.val;</span><br><span class="line">                root = root.right;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="keyword">null</span> || !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="056-二叉搜索树中两个节点之和"><a href="#056-二叉搜索树中两个节点之和" class="headerlink" title="056.二叉搜索树中两个节点之和"></a>056.二叉搜索树中两个节点之和</h3><p>给定一个二叉搜索树的 <strong>根节点</strong> <code>root</code> 和一个整数 <code>k</code> , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 <code>k</code> 。假设二叉搜索树中节点的值均唯一。</p>
<p>提示：</p>
<p>二叉树的节点个数的范围是  [1, 10^4].<br>-10^4 &lt;= Node.val &lt;= 10^4<br>root 为二叉搜索树<br>-10^5 &lt;= k &lt;= 10^5</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (hashSet.contains(k - root.val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashSet.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> findTarget(root.left,k) || findTarget(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="057-值和下标之差都在给定的范围内"><a href="#057-值和下标之差都在给定的范围内" class="headerlink" title="057.值和下标之差都在给定的范围内"></a>057.值和下标之差都在给定的范围内</h3><p>给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足 abs(i - j) &lt;= k 。</p>
<p>如果存在则返回 true，不存在返回 false。</p>
<p>提示：</p>
<p>0 &lt;= nums.length &lt;= 2 * 10^4<br>-2^31 &lt;= nums[i] &lt;= 2^31 - 1<br>0 &lt;= k &lt;= 10^4<br>0 &lt;= t &lt;= 2^31 - 1</p>
<p>方法一：滑动窗口 + 有序集合</p>
<p>如果使用队列维护滑动窗口内的元素，由于元素是无序的，我们只能对于每个元素都遍历一次队列来检查是否有元素符合条件。如果数组的长度为 n，则使用队列的时间复杂度为 O(nk)，会超出时间限制。</p>
<p>因此我们希望能够找到一个数据结构维护滑动窗口内的元素，该数据结构需要满足以下操作：</p>
<p>支持添加和删除指定元素的操作，否则我们无法维护滑动窗口；</p>
<p>内部元素有序，支持二分查找的操作，这样我们可以快速判断滑动窗口中是否存在元素满足条件，具体而言，对于元素 x，当我们希望判断滑动窗口中是否存在某个数 y 落在区间 [x - t, x + t][x−t,x+t] 中，只需要判断滑动窗口中所有大于等于 x−t 的元素中的最小元素是否小于等于x+t 即可。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		TreeSet&lt;Long&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//查找所有大于等于 x−t 的元素中的最小元素</span></span><br><span class="line">            Long ceiling = treeSet.ceiling((<span class="keyword">long</span>) nums[i] - t);</span><br><span class="line">            <span class="comment">//判断滑动窗口中所有大于等于 x−t 的元素中的最小元素是否小于等于x+t </span></span><br><span class="line">            <span class="keyword">if</span> (ceiling != <span class="keyword">null</span> &amp;&amp; ceiling &lt;= (<span class="keyword">long</span>)nums[i] + t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            treeSet.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="comment">//集合中元素个数大于k，删除最先进入集合的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">                treeSet.remove((<span class="keyword">long</span>)nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlog(min(n,k)))</p>
<p>空间复杂度：O(min(n,k))</p>
<p>方法二：桶</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Long,Long&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//w为每个桶的大小</span></span><br><span class="line">        <span class="keyword">long</span> w = (<span class="keyword">long</span>)t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = getID(nums[i],w);</span><br><span class="line">            <span class="comment">//两个元素属于同一个桶，必然符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(id))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//两个元素属于相邻桶，需要校验这两个元素是否差值不超过 t</span></span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(id - <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - hashmap.get(id - <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(id + <span class="number">1</span>) &amp;&amp; Math.abs(nums[i] - hashmap.get(id + <span class="number">1</span>)) &lt; w)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果两个元素既不属于同一个桶，也不属于相邻桶，那么这两个元素必然不符合条件。</span></span><br><span class="line">            hashmap.put(id,(<span class="keyword">long</span>)nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">                hashmap.remove(getID(nums[i - k],w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*如w=10, 因为非负数是0~9，10~19...这种一组，而负数是-1~-10, -11~-20...这些是一组，如果-1~-10直接除以10，会被分到两组中，而不是-1这一组，所以先+1变成-0--9,与正数一致，再除以10，最后减1，正好是-1这一组，其它组也是同理*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getID</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> num / w;</span><br><span class="line">        <span class="keyword">return</span> (num + <span class="number">1</span>) / w - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(min(n,k))</p>
<hr>
<h3 id="058-日程表"><a href="#058-日程表" class="headerlink" title="058.日程表"></a>058.日程表</h3><p>请实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p>
<p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;= x &lt; end。</p>
<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p>
<p>每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p>
<p>请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p>
<p><strong>提示：</strong></p>
<ul>
<li>每个测试用例，调用 <code>MyCalendar.book</code> 函数最多不超过 <code>1000</code>次。</li>
<li><code>0 &lt;= start &lt; end &lt;= 10^9</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TreeMap&lt;Integer,Integer&gt; treeMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Integer preStart = treeMap.floorKey(start);</span><br><span class="line">        Integer nextStart = treeMap.ceilingKey(start);</span><br><span class="line">        <span class="keyword">if</span> ((preStart == <span class="keyword">null</span> || treeMap.get(preStart) &lt;= start) &amp;&amp; (nextStart == <span class="keyword">null</span> || end &lt;= nextStart))&#123;</span><br><span class="line">            treeMap.put(start,end);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCalendar obj = new MyCalendar();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.book(start,end);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="059-数据流的第k大数值"><a href="#059-数据流的第k大数值" class="headerlink" title="059.数据流的第k大数值"></a>059.数据流的第k大数值</h3><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>
<p>请实现 KthLargest 类：</p>
<p>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。<br>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; priorityQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        priorityQueue.offer(val);</span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &gt; k)&#123;</span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priorityQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlogk)</p>
<p>空间复杂度：O(k)</p>
<hr>
<h3 id="060-出现频率最高的k个数字"><a href="#060-出现频率最高的k个数字" class="headerlink" title="060.出现频率最高的k个数字"></a>060.出现频率最高的k个数字</h3><p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请返回其中出现频率前 <code>k</code> 高的元素。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10^5<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p>
<p>进阶：所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p>
<p>方法一：小根堆</p>
<p>首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。利用小根堆找出原数组的前 k 个高频元素，就相当于找出「出现次数数组」的前 k 大的值。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            hashMap.put(num,hashMap.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> hashMap.get(o1) - hashMap.get(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Integer key : hashMap.keySet()) &#123;</span><br><span class="line">            pq.add(key);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k)</span><br><span class="line">                pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlogk)</p>
<p>空间复杂度：O(n)</p>
<p>方法二：基于快速排序</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; values = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey(), count = entry.getValue();</span><br><span class="line">            values.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        qsort(values, <span class="number">0</span>, values.size() - <span class="number">1</span>, ret, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(List&lt;<span class="keyword">int</span>[]&gt; values, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] ret, <span class="keyword">int</span> retIndex, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> picked = (<span class="keyword">int</span>) (Math.random() * (end - start + <span class="number">1</span>)) + start;</span><br><span class="line">        Collections.swap(values, picked, start);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = values.get(start)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (values.get(i)[<span class="number">1</span>] &gt;= pivot) &#123;</span><br><span class="line">                Collections.swap(values, index + <span class="number">1</span>, i);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.swap(values, start, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= index - start) &#123;</span><br><span class="line">            qsort(values, start, index - <span class="number">1</span>, ret, retIndex, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= index; i++) &#123;</span><br><span class="line">                ret[retIndex++] = values.get(i)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; index - start + <span class="number">1</span>) &#123;</span><br><span class="line">                qsort(values, index + <span class="number">1</span>, end, ret, retIndex, k - (index - start + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2),平均情况下O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="061-和最小的k个数对"><a href="#061-和最小的k个数对" class="headerlink" title="061.和最小的k个数对"></a>061.和最小的k个数对</h3><p>给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。</p>
<p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。</p>
<p>请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  …  (uk,vk) 。</p>
<p>提示:</p>
<p>1 &lt;= nums1.length, nums2.length &lt;= 10^4<br>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9<br>nums1, nums2 均为升序排列<br>1 &lt;= k &lt;= 1000</p>
<p>方法：多路归并</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length, len2 = nums2.length;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; nums1[o1[<span class="number">0</span>]] + nums2[o1[<span class="number">1</span>]] - nums1[o2[<span class="number">0</span>]] - nums2[o2[<span class="number">1</span>]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (lists.size() &lt; k &amp;&amp; !pq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] poll = pq.poll();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(nums1[poll[<span class="number">0</span>]]);</span><br><span class="line">            list.add(nums2[poll[<span class="number">1</span>]]);</span><br><span class="line">            lists.add(list);</span><br><span class="line">            <span class="keyword">if</span> (poll[<span class="number">1</span>] + <span class="number">1</span> &lt; len2)</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;poll[<span class="number">0</span>],poll[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2),平均情况下O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="062-实现前缀树"><a href="#062-实现前缀树" class="headerlink" title="062.实现前缀树"></a>062.实现前缀树</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p>
<p>提示：</p>
<p>1 &lt;= word.length, prefix.length &lt;= 2000<br>word 和 prefix 仅由小写英文字母组成<br>insert、search 和 startsWith 调用次数 总计 不超过 3 * 10^4 次</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Trie[] children;<span class="comment">//子节点指针数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;<span class="comment">//表示该节点是否为字符串的结尾。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startsWith(word) &amp;&amp; searchPrefix(word).isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trie <span class="title">searchPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2),平均情况下O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="063-替换单词"><a href="#063-替换单词" class="headerlink" title="063.替换单词"></a>063.替换单词</h3><p>在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>
<p>现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>
<p>需要输出替换之后的句子。</p>
<p>提示：</p>
<p>1 &lt;= dictionary.length &lt;= 1000<br>1 &lt;= dictionary[i].length &lt;= 100<br>dictionary[i] 仅由小写字母组成。<br>1 &lt;= sentence.length &lt;= 10^6<br>sentence 仅由小写字母和空格组成。<br>sentence 中单词的总量在范围 [1, 1000] 内。<br>sentence 中每个单词的长度在范围 [1, 1000] 内。<br>sentence 中单词之间由一个空格隔开。<br>sentence 没有前导或尾随空格。</p>
<p>方法一：前缀哈希（通过）</p>
<p>思路:遍历句子中每个单词，查看单词前缀是否为词根。将所有词根 <code>roots</code> 存储到集合 <em>Set</em> 中。遍历所有单词，判断其前缀是否为词根。如果是，则使用前缀代替该单词；否则不改变该单词。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; roots, String sentence)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; rootset = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (String root: roots) rootset.add(root);</span><br><span class="line"></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String word: sentence.split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">            String prefix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word.length(); ++i) &#123;</span><br><span class="line">                prefix = word.substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (rootset.contains(prefix)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.length() &gt; <span class="number">0</span>) ans.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            ans.append(prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(n)</p>
<p>方法一：前缀树</p>
<p>把所有的词根放入前缀树中，在树上查找每个单词的最短词根，该操作可在线性时间内完成。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; roots, String sentence)</span> </span>&#123;</span><br><span class="line">        TrieNode trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">for</span> (String root: roots) &#123;</span><br><span class="line">            TrieNode cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> letter: root.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.children[letter - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)</span><br><span class="line">                    cur.children[letter - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                cur = cur.children[letter - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.word = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word: sentence.split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.length() &gt; <span class="number">0</span>)</span><br><span class="line">                ans.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            TrieNode cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> letter: word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.children[letter - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span> || cur.word != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                cur = cur.children[letter - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(cur.word != <span class="keyword">null</span> ? cur.word : word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    String word;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="064-神奇的字典"><a href="#064-神奇的字典" class="headerlink" title="064.神奇的字典"></a>064.神奇的字典</h3><p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p>
<p>实现 MagicDictionary 类：</p>
<p>MagicDictionary() 初始化对象<br>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同<br>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。</p>
<p>提示：</p>
<p>1 &lt;= dictionary.length &lt;= 100<br>1 &lt;= dictionary[i].length &lt;= 100<br>dictionary[i] 仅由小写英文字母组成<br>dictionary 中的所有字符串 互不相同<br>1 &lt;= searchWord.length &lt;= 100<br>searchWord 仅由小写英文字母组成<br>buildDict 仅在 search 之前调用一次<br>最多调用 100 次 search</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, ArrayList&lt;String&gt;&gt; buckets;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buckets = <span class="keyword">new</span> HashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            buckets.computeIfAbsent(word.length(), x -&gt; <span class="keyword">new</span> ArrayList()).add(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buckets.containsKey(word.length())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String candidate: buckets.get(word.length())) &#123;</span><br><span class="line">            <span class="keyword">int</span> mismatch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.charAt(i) != candidate.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++mismatch &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mismatch == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="065-最短的单词编码"><a href="#065-最短的单词编码" class="headerlink" title="065.最短的单词编码"></a>065.最短的单词编码</h3><p>单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：</p>
<p>words.length == indices.length<br>助记字符串 s 以 ‘#’ 字符结尾<br>对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 ‘#’ 字符结束（但不包括 ‘#’）的 子字符串 恰好与 words[i] 相等<br>给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
<li><code>words[i]</code> 仅由小写字母组成</li>
</ul>
<p>方法一：</p>
<p>枚举单词所有的后缀。对于每个后缀，如果其存在 <code>words</code> 列表中，我们就将其从列表中删除。为了高效删除，我们将 <code>words</code> 用哈希集合来存储。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; good = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(words));</span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; word.length(); ++k) &#123;</span><br><span class="line">                good.remove(word.substring(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word: good) &#123;</span><br><span class="line">            ans += word.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：字典树</p>
<p>去找到是否不同的单词具有相同的后缀，我们可以将其反序之后插入字典树中。例如，我们有 “time” 和 “me”，可以将 “emit” 和 “em” 插入字典树中。然后，字典树的叶子节点（没有孩子的节点）就代表没有后缀的单词，统计叶子节点代表的单词长度加一的和即为我们要的答案。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        TrieNode trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        Map&lt;TrieNode, Integer&gt; nodes = <span class="keyword">new</span> HashMap&lt;TrieNode, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">            String word = words[i];</span><br><span class="line">            TrieNode cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = word.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                cur = cur.get(word.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            nodes.put(cur, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode node: nodes.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.count == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += words[nodes.get(node)].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="066-单词之和"><a href="#066-单词之和" class="headerlink" title="066.单词之和"></a>066.单词之和</h3><p>实现一个 MapSum 类，支持两个方法，insert 和 sum：</p>
<p>MapSum() 初始化 MapSum 对象<br>void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。<br>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。</p>
<p>提示：</p>
<p>1 &lt;= key.length, prefix.length &lt;= 50<br>key 和 prefix 仅由小写英文字母组成<br>1 &lt;= val &lt;= 1000<br>最多调用 50 次 insert 和 sum</p>
<p>方法一 ：暴力匹配</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Map&lt;String,Integer&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        map.put(key,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length() &lt; prefix.length())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; prefix.length() &amp;&amp; prefix.charAt(i) == key.charAt(i))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == prefix.length())</span><br><span class="line">                sum += map.get(key);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：前缀树</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    TrieNode trieNode;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.trieNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TrieNode cur = trieNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = key.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.children[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.val = val;</span><br><span class="line">        cur.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode cur = trieNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getVal(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">(TrieNode trieNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trieNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = trieNode.val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trieNode.children[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sum += getVal(trieNode.children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MapSum obj = <span class="keyword">new</span> MapSum();</span><br><span class="line">        obj.insert(<span class="string">&quot;apple&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(obj.sum(<span class="string">&quot;ap&quot;</span>));</span><br><span class="line">        obj.insert(<span class="string">&quot;app&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(obj.sum(<span class="string">&quot;ap&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="067-最大的异或"><a href="#067-最大的异或" class="headerlink" title="067.最大的异或"></a>067.最大的异或</h3><p>给定一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 2 * 10^4<br>0 &lt;= nums[i] &lt;= 2^31 - 1</p>
<p>进阶：你可以在 O(n) 的时间解决这个问题吗？</p>
<p>方法一：哈希表</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">//每一次将num的前i位加入哈希表</span></span><br><span class="line">                set.add(num &gt;&gt; i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//假设第i位为1；</span></span><br><span class="line">            <span class="keyword">int</span> next = (ans &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//标志位，若能找到两个数异或使得第i位为1，则found为true</span></span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">//根据ans = a ^ b 等价于a = ans ^ b,在哈希表中寻找使得ans第i位为1的两个数。</span></span><br><span class="line">                <span class="keyword">if</span> (set.contains(next ^ (num &gt;&gt; i)))&#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到，ans第i位置1；</span></span><br><span class="line">            <span class="keyword">if</span> (found)&#123;</span><br><span class="line">                ans = next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没找到，第i位置0</span></span><br><span class="line">                ans &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<p>方法一：字典树</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字典树的根节点</span></span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="comment">// 最高位的二进制位编号为 30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HIGH_BIT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span></span><br><span class="line">            add(nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 将 nums[i] 看作 ai，找出最大的 x 更新答案</span></span><br><span class="line">            x = Math.max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.left = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.right = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = HIGH_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    x = x * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    x = x * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树指向表示 0 的子节点</span></span><br><span class="line">    Trie left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 右子树指向表示 1 的子节点</span></span><br><span class="line">    Trie right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(nlogC)</p>
<hr>
<h3 id="068-查找插入位置"><a href="#068-查找插入位置" class="headerlink" title="068.查找插入位置"></a>068.查找插入位置</h3><p>给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p>提示:</p>
<p>1 &lt;= nums.length &lt;= 10^4<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 为无重复元素的升序排列数组<br>-10^4 &lt;= target &lt;= 10^4</p>
<p>二分法：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid  = left + (right -  left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(log(n))</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="069-山峰数组的顶部"><a href="#069-山峰数组的顶部" class="headerlink" title="069.山峰数组的顶部"></a>069.山峰数组的顶部</h3><p>符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：</p>
<p>arr.length &gt;= 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]<br>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]<br>给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。</p>
<p>提示：</p>
<p>3 &lt;= arr.length &lt;= 10^4<br>0 &lt;= arr[i] &lt;= 10^6<br>题目数据保证 arr 是一个山脉数组</p>
<p>进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？</p>
<p>二分法：</p>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>,right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid  = left + (right -  left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid - <span class="number">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid - <span class="number">1</span>] &lt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(log(n))</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="070-排序数组中只出现一次的数组"><a href="#070-排序数组中只出现一次的数组" class="headerlink" title="070.排序数组中只出现一次的数组"></a>070.排序数组中只出现一次的数组</h3><p>给定一个只包含整数的有序数组 <code>nums</code> ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。</p>
<p>提示:</p>
<p>1 &lt;= nums.length &lt;= 10^5<br>0 &lt;= nums[i] &lt;= 10^5</p>
<p>进阶: 采用的方案可以在 O(log n) 时间复杂度和 O(1) 空间复杂度中运行吗？</p>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> nums[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] != nums[len - <span class="number">2</span>]) <span class="keyword">return</span> nums[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid  = left + (right -  left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] != nums[mid] &amp;&amp; nums[mid] != nums[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">if</span> ((mid - left) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>])&#123;</span><br><span class="line">                    right = mid - <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                    left = mid + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>])&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(log(n))</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="071-按权重生成随机数"><a href="#071-按权重生成随机数" class="headerlink" title="071.按权重生成随机数"></a>071.按权重生成随机数</h3><p>给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。</p>
<p>例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。</p>
<p>也就是说，选取下标 i 的概率为 w[i] / sum(w) 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= w.length &lt;= 10000</code></li>
<li><code>1 &lt;= w[i] &lt;= 10^5</code></li>
<li><code>pickIndex</code> 将被调用不超过 <code>10000</code> 次</li>
</ul>
<h4 id="前缀和-二分查找："><a href="#前缀和-二分查找：" class="headerlink" title="前缀和 + 二分查找："></a>前缀和 + 二分查找：</h4><div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前缀和数组</span></span><br><span class="line">    <span class="keyword">int</span>[] pre;</span><br><span class="line">    <span class="comment">//总权重</span></span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution1</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        pre = <span class="keyword">new</span> <span class="keyword">int</span>[w.length];</span><br><span class="line">        pre[<span class="number">0</span>] = w[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        total = pre[w.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>)(Math.random() * total) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在前缀和数组中二分查找数x</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = pre.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre[mid] &gt;= x)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(log(n))</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="072-求平方根"><a href="#072-求平方根" class="headerlink" title="072.求平方根"></a>072.求平方根</h3><p>给定一个非负整数 x ，计算并返回 x 的平方根，即实现 int sqrt(int x) 函数。</p>
<p>正数的平方根有两个，只输出其中的正数平方根。</p>
<p>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= x &lt;= 2^31 - 1</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法一：时间复杂度和空间复杂度都为O(1)</span></span><br><span class="line">    <span class="comment">//用指数函数 exp 和对数函数 ln 代替平方根函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)(ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法二：二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>)mid * mid == x) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>)mid * mid &lt; x)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(log(n))</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="073-狒狒吃香蕉"><a href="#073-狒狒吃香蕉" class="headerlink" title="073.狒狒吃香蕉"></a>073.狒狒吃香蕉</h3><p>狒狒喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p>
<p>狒狒可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。  </p>
<p>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= piles.length &lt;= 10^4</code></li>
<li><code>piles.length &lt;= H &lt;= 10^9</code></li>
<li><code>1 &lt;= piles[i] &lt;= 10^9</code></li>
</ul>
<p>二分查找法：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (getTime(mid,piles) &gt; h)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//以x的速度吃完所有香蕉需要的最少时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTime</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span>[] piles)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            ans += (pile - <span class="number">1</span>) / x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(log(n))</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="074-合并区间"><a href="#074-合并区间" class="headerlink" title="074.合并区间"></a>074.合并区间</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<p>提示：</p>
<p>1 &lt;= intervals.length &lt;= 10^4<br>intervals[i].length == 2<br>0 &lt;= starti &lt;= endi &lt;= 10^4</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">		Arrays.sort(intervals,(o1,o2) -&gt; (o1[<span class="number">0</span>] - o2[<span class="number">0</span>]));</span><br><span class="line">        ArrayList&lt;<span class="keyword">int</span>[]&gt; merge = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = intervals[i][<span class="number">0</span>],r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (merge.size() == <span class="number">0</span> || l &gt; merge.get(merge.size() - <span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                merge.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l,r&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                merge.get(merge.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merge.get(merge.size() - <span class="number">1</span>)[<span class="number">1</span>],r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merge.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public int[][] merge(int[][] intervals) &#123;</span></span><br><span class="line"><span class="comment">        Arrays.sort(intervals,(o1,o2) -&gt; (o1[0] - o2[0]));</span></span><br><span class="line"><span class="comment">        ArrayList&lt;int[]&gt; ints = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; intervals.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            int s = intervals[i][0];</span></span><br><span class="line"><span class="comment">            int e = intervals[i][1];</span></span><br><span class="line"><span class="comment">            while (i + 1 &lt; intervals.length &amp;&amp; intervals[i + 1][0] &lt;= e)&#123;</span></span><br><span class="line"><span class="comment">                if (intervals[i + 1][1] &gt; e)&#123;</span></span><br><span class="line"><span class="comment">                    e = intervals[i + 1][1];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                i++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ints.add(new int[]&#123;s,e&#125;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ints.toArray(new int[ints.size()][]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlog(n))</p>
<p>空间复杂度：O(logn)</p>
<hr>
<h3 id="075-数组相对排序"><a href="#075-数组相对排序" class="headerlink" title="075.数组相对排序"></a>075.数组相对排序</h3><p>给定两个数组，arr1 和 arr2，</p>
<p>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
<p>提示：</p>
<p>1 &lt;= arr1.length, arr2.length &lt;= 1000<br>0 &lt;= arr1[i], arr2[i] &lt;= 1000<br>arr2 中的元素 arr2[i] 各不相同<br>arr2 中的每个元素 arr2[i] 都出现在 arr1 中</p>
<p>方法一：利用list进行定制化排序</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">		 HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            map.put(arr2[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr1) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = map.getOrDefault(o1,<span class="number">1001</span>);</span><br><span class="line">                <span class="keyword">int</span> b = map.getOrDefault(o2,<span class="number">1001</span>);</span><br><span class="line">                <span class="keyword">if</span> (a == b &amp;&amp; a == <span class="number">1001</span>)</span><br><span class="line">                    <span class="keyword">return</span> o1 - o2;</span><br><span class="line">                <span class="keyword">return</span> a - b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) arr1[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlog(n))</p>
<p>空间复杂度：O(n)</p>
<p>方法二：计数排序</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="keyword">int</span> upper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr1) &#123;</span><br><span class="line">            upper = Math.max(upper, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[upper + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr1) &#123;</span><br><span class="line">            ++frequency[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frequency[x]; ++i) &#123;</span><br><span class="line">                ans[index++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            frequency[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= upper; ++x) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frequency[x]; ++i) &#123;</span><br><span class="line">                ans[index++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlog(n))</p>
<p>空间复杂度：O(logn)</p>
<hr>
<h3 id="076-数组中的第k大的数字"><a href="#076-数组中的第k大的数字" class="headerlink" title="076.数组中的第k大的数字"></a>076.数组中的第k大的数字</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<p> 方法一：快排</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 在区间 nums[left..right] 区间执行 partition 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在区间随机选择一个元素作为标定点</span></span><br><span class="line">        <span class="keyword">int</span> p = (<span class="keyword">int</span>) (Math.random() * (right - left + <span class="number">1</span>)) + left;</span><br><span class="line">        swap(nums, p, right);</span><br><span class="line">        <span class="keyword">int</span> li = left - <span class="number">1</span>, ri = right;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; ri) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[right]) &#123;</span><br><span class="line">                li++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[right]) &#123;</span><br><span class="line">                ri--;</span><br><span class="line">                swap(nums, i, ri);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,right,i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p>方法二：优先级队列</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((n1,n2) -&gt; (n1 - n2));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            heap.add(num);</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k)&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="077-链表排序"><a href="#077-链表排序" class="headerlink" title="077.链表排序"></a>077.链表排序</h3><p>给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 5 * 10^4] 内<br>-10^5 &lt;= Node.val &lt;= 10^5</p>
<p>进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<p>方法一：自顶向下递归归并排序</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head,fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode head1 = sortList(head);</span><br><span class="line">        ListNode head2 = sortList(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(head1,head2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode node1,ListNode node2)</span></span>&#123;</span><br><span class="line">        ListNode vrHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = vrHead;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node1.val &lt; node2.val)&#123;</span><br><span class="line">                temp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp.next = node1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vrHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlog n)</p>
<p>空间复杂度：O(log n)</p>
<p>方法二：自底向上归并排序（空间复杂度为O(1))</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> subLength = <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode prev = dummyHead, curr = dummyHead.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode head2 = curr.next;</span><br><span class="line">                curr.next = <span class="keyword">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//子链表间断开链接</span></span><br><span class="line">                ListNode next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode merged = merge(head1, head2);</span><br><span class="line">                <span class="comment">//子链表排好序后重连</span></span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode node1,ListNode node2)</span></span>&#123;</span><br><span class="line">        ListNode vrHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = vrHead;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node1.val &lt; node2.val)&#123;</span><br><span class="line">                temp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp.next = node1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vrHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlog n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="078-合并排序链表"><a href="#078-合并排序链表" class="headerlink" title="078.合并排序链表"></a>078.合并排序链表</h3><p>给定一个链表数组，每个链表都已经按升序排列。</p>
<p>请将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p> 提示：</p>
<p>k == lists.length<br>0 &lt;= k &lt;= 10^4<br>0 &lt;= lists[i].length &lt;= 500<br>-10^4 &lt;= lists[i][j] &lt;= 10^4<br>lists[i] 按 升序 排列<br>lists[i].length 的总和不超过 10^4</p>
<p>方法一：利用优先级队列进行多路归并排序</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line">                pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode vrHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = vrHead;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            ListNode poll = pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll.next != <span class="keyword">null</span>)</span><br><span class="line">                pq.add(poll.next);</span><br><span class="line">            cur.next = poll;</span><br><span class="line">            cur = poll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vrHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nklog k)</p>
<p>空间复杂度：O(k)</p>
<p>方法二：分治合并</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeNode(lists,<span class="number">0</span>,lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeNode</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ListNode l1 = mergeNode(lists, l, mid);</span><br><span class="line">        ListNode l2 = mergeNode(lists, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> mergeListNode(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeListNode</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode p1 = l1, p2 = l2;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val &lt; p2.val)&#123;</span><br><span class="line">                cur.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = p1 == <span class="keyword">null</span> ? p2 : p1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nklog k)</p>
<p>空间复杂度：O(k)</p>
<hr>
<h3 id="079-所有子集"><a href="#079-所有子集" class="headerlink" title="079.所有子集"></a>079.所有子集</h3><p>给定一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<p>回溯算法：</p>
<p>1.DFS 和回溯算法区别<br>DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置</p>
<p>2.何时使用回溯算法<br>当问题需要 “回头”，以此来查找出所有的解的时候，使用回溯算法。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止</p>
<p>3.怎么样写回溯算法(从上而下，※代表难点，根据题目而变化)<br>①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※<br>②根据题意，确立结束条件<br>③找准选择列表(与函数参数相关),与第一步紧密关联※<br>④判断是否需要剪枝<br>⑤作出选择，递归调用，进入下一层<br>⑥撤销选择</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums,<span class="number">0</span>,res,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> i,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (i == nums.length)&#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不选i位置的元素</span></span><br><span class="line">       dfs(nums,i + <span class="number">1</span>,res,list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//选择i位置的元素</span></span><br><span class="line">       list.add(nums[i]);</span><br><span class="line">       dfs(nums,i + <span class="number">1</span>,res,list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//回溯</span></span><br><span class="line">       list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="080-含有k个元素的组合"><a href="#080-含有k个元素的组合" class="headerlink" title="080.含有k个元素的组合"></a>080.含有k个元素的组合</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录搜素的路径</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(n,k,<span class="number">1</span>,res,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> i,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//减枝，此时，再往下一层搜索已经没有必要，不可能再有满足条件的组合，所以进行减枝</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() + (n - i + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到符合条件的组合，加入到res中</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选择数i，进入下一层</span></span><br><span class="line">        process(n,k,i + <span class="number">1</span>,res,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择数i，进入下一层</span></span><br><span class="line">        list.add(i);</span><br><span class="line">        process(n,k,i + <span class="number">1</span>,res,list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="081-允许重复选择元素的组合"><a href="#081-允许重复选择元素的组合" class="headerlink" title="081.允许重复选择元素的组合"></a>081.允许重复选择元素的组合</h3><p>给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p>
<p>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p>
<p>提示：</p>
<p>1 &lt;= candidates.length &lt;= 30<br>1 &lt;= candidates[i] &lt;= 200<br>candidate 中的每个元素都是独一无二的。<br>1 &lt;= target &lt;= 500</p>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 排序是剪枝的前提</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,res,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> begin, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝，前提是候选数组已经有序，</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            dfs(nums,target - nums[i],i,res,list);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(target)</p>
<hr>
<h3 id="082-含有重复元素集合的组合"><a href="#082-含有重复元素集合的组合" class="headerlink" title="082.含有重复元素集合的组合"></a>082.含有重复元素集合的组合</h3><p> 给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。 </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 100</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,res,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> begin, ArrayList&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] 肯定也小于 0，因此用 break</span></span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            dfs(candidates,target - candidates[i],i + <span class="number">1</span>,res,list);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(target)</p>
<hr>
<h3 id="083-没有重复元素的全排列"><a href="#083-没有重复元素的全排列" class="headerlink" title="083.没有重复元素的全排列"></a>083.没有重复元素的全排列</h3><p>给定一个不含重复数字的整数数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums,flag,res,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] flag, ArrayList&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i])&#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                flag[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(nums,flag,res,list);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                flag[i] = <span class="keyword">false</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * n!)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="084-含有重复元素集合的全排列"><a href="#084-含有重复元素集合的全排列" class="headerlink" title="084.含有重复元素集合的全排列"></a>084.含有重复元素集合的全排列</h3><p>给定一个可包含重复数字的整数集合 <code>nums</code> ，<strong>按任意顺序</strong> 返回它所有不重复的全排列。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, flag, res, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] flag, ArrayList&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剪枝条件：i &gt; 0 是为了保证 nums[i - 1] 有意义</span></span><br><span class="line">            <span class="comment">// 写 !flag[i - 1] 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !flag[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            flag[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(nums, flag, res, list);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            flag[i] = <span class="keyword">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * n!)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="085-生成匹配的括号"><a href="#085-生成匹配的括号" class="headerlink" title="085.生成匹配的括号"></a>085.生成匹配的括号</h3><p>正整数 <code>n</code> 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(n,n,res,sb);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ArrayList&lt;String&gt; res, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(sb));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            dfs(left - <span class="number">1</span>,right,res,sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            dfs(left,right - <span class="number">1</span>,res,sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="086-分割回文子字符串"><a href="#086-分割回文子字符串" class="headerlink" title="086.分割回文子字符串"></a>086.分割回文子字符串</h3><p>给定一个字符串 <code>s</code> ，请将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> ，返回 s 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 16</code></li>
<li><code>s </code>仅由小写英文字母组成</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[][] partition(String s) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt;= right; left++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[left] == chars[right] &amp;&amp; (right - left &lt;= <span class="number">2</span> || dp[left + <span class="number">1</span>][right - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s,<span class="number">0</span>,lists,list,dp);</span><br><span class="line">        String[][] res = <span class="keyword">new</span> String[lists.size()][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cols = lists.get(i).size();</span><br><span class="line">            res[i] = <span class="keyword">new</span> String[cols];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                res[i][j] = lists.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> index, ArrayList&lt;List&lt;String&gt;&gt; lists, ArrayList&lt;String&gt; list, <span class="keyword">boolean</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.length())&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[index][i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            list.add(s.substring(index,i + <span class="number">1</span>));</span><br><span class="line">            dfs(s,i + <span class="number">1</span>,lists,list,dp);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(n^2)</p>
<hr>
<h3 id="087-复原IP"><a href="#087-复原IP" class="headerlink" title="087.复原IP"></a>087.复原IP</h3><p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。</p>
<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#x2e;&#x31;" rel="external nofollow noreferrer">&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#x2e;&#x31;</a>“ 是 无效 IP 地址。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3000</code></li>
<li><code>s</code> 仅由数字组成</li>
</ul>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count记录path中添加了IP段的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> count, List&lt;String&gt; res, List&lt;String&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//符合IP规范，添加到结果集中</span></span><br><span class="line">        <span class="keyword">if</span> (begin == s.length() &amp;&amp; count == <span class="number">4</span>) &#123;</span><br><span class="line">            res.add(String.join(<span class="string">&quot;.&quot;</span>, path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; begin + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = s.length() - begin;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">3</span> * (<span class="number">4</span> - count) || len &lt; <span class="number">4</span> - count) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= s.length()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (judgeIPSegment(s, begin, i)) &#123;</span><br><span class="line">                path.add(s.substring(begin, i + <span class="number">1</span>));</span><br><span class="line">                dfs(s, i + <span class="number">1</span>, count + <span class="number">1</span>, res, path);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是IP段</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgeIPSegment</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; begin &amp;&amp; s.charAt(begin) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.parseInt(s.substring(begin, i + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">0</span> &amp;&amp; res &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(n^2)</p>
<hr>
<h3 id="088-爬楼梯的最小成本"><a href="#088-爬楼梯的最小成本" class="headerlink" title="088.爬楼梯的最小成本"></a>088.爬楼梯的最小成本</h3><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>2 &lt;= cost.length &lt;= 1000</code></p>
</li>
<li><p><code>0 &lt;= cost[i] &lt;= 999</code></p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = cost.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i- <span class="number">1</span>],dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></li>
</ul>
<p>时间复杂度：O(n )</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="089-房屋偷盗"><a href="#089-房屋偷盗" class="headerlink" title="089.房屋偷盗"></a>089.房屋偷盗</h3><p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 100</code></p>
</li>
<li><p><code>0 &lt;= nums[i] &lt;= 400</code></p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></li>
</ul>
<p>时间复杂度：O(n )</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="090-环形房屋偷盗"><a href="#090-环形房屋偷盗" class="headerlink" title="090.环形房屋偷盗"></a>090.环形房屋偷盗</h3><p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">         <span class="comment">//返回在nums下标[0,len - 2]和[1,len - 1]之间偷窃的最大值，这样能保证首尾不能同时被盗</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,len - <span class="number">2</span>),rob(nums,<span class="number">1</span>,len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在数组nums下标[start,end]之间偷窃能获得的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[start],nums[end]);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,a = nums[start],b = Math.max(nums[start],nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            res = Math.max(a + nums[i],b);</span><br><span class="line">            a = b;</span><br><span class="line">            b = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n )</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="091-粉刷房子"><a href="#091-粉刷房子" class="headerlink" title="091.粉刷房子"></a>091.粉刷房子</h3><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。</p>
<p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。</p>
<p>请计算出粉刷完所有房子最少的花费成本。</p>
<p>提示:</p>
<p>costs.length == n<br>costs[i].length == 3<br>1 &lt;= n &lt;= 100<br>1 &lt;= costs[i][j] &lt;= 20</p>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = costs.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = costs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = costs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.min(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">2</span>]) + costs[i][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.min(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">2</span>]) + costs[i][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.min(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>]) + costs[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(dp[n - <span class="number">1</span>][<span class="number">0</span>],dp[n - <span class="number">1</span>][<span class="number">1</span>]),dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n )</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="092-翻转字符"><a href="#092-翻转字符" class="headerlink" title="092.翻转字符"></a>092.翻转字符</h3><p>如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是 单调递增 的。</p>
<p>我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 s，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。</p>
<p>返回使 s 单调递增 的最小翻转次数。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20000</code></li>
<li>s 中只包含字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code></li>
</ul>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">         <span class="comment">//记录前i个位置1的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                sum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] == count[i - <span class="number">1</span>] ? dp[i - <span class="number">1</span>] : dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n )</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="093-最长斐波那契数列"><a href="#093-最长斐波那契数列" class="headerlink" title="093.最长斐波那契数列"></a>093.最长斐波那契数列</h3><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p>
<p>n &gt;= 3<br>对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p>
<p>（回想一下，子序列是从原序列  arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= arr.length &lt;= 1000</code></li>
<li><code>1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></li>
</ul>
<p>方法一：使用set暴力搜索每两个数开始的最长斐波那契数列</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = arr[i];</span><br><span class="line">                <span class="keyword">int</span> b = arr[j];</span><br><span class="line">                <span class="keyword">int</span> c = a + b;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (set.contains(c))&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    a = b;</span><br><span class="line">                    b = c;</span><br><span class="line">                    c = a + b;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2logM ),M是数组arr中的最大值</p>
<p>空间复杂度：O(n)</p>
<p>方法二:动态规划</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            index.put(arr[i], i);</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = index.getOrDefault(arr[j] - arr[i], -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (k &gt;= <span class="number">0</span> &amp;&amp; k &lt; i)&#123;<span class="comment">//k &lt; i 保证当前斐波那契数列以i和j结尾</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[k][i] == <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">3</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[k][i] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    max = Math.max(max,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max &gt;= <span class="number">3</span> ? max : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n )</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="094-最少回文分割"><a href="#094-最少回文分割" class="headerlink" title="094.最少回文分割"></a>094.最少回文分割</h3><p>给定一个字符串 <code>s</code>，请将 <code>s</code> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">//help[i][j]记录字符串s从下标i到j位置的子串是否是回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] help = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt;= right; left++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(left) == s.charAt(right) &amp;&amp; (right - left &lt;= <span class="number">2</span> || help[left + <span class="number">1</span>][right - <span class="number">1</span>]))&#123;</span><br><span class="line">                    help[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划：dp[i] = min + 1;</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (help[<span class="number">0</span>][i])&#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min = len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (help[j][i])&#123;</span><br><span class="line">                    min = Math.min(min,dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2 )</p>
<p>空间复杂度：O(n^2)</p>
<hr>
<h3 id="095-最长公共子序列"><a href="#095-最长公共子序列" class="headerlink" title="095.最长公共子序列"></a>095.最长公共子序列</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = text1.length(),len2 = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h3 id="096-字符串交织"><a href="#096-字符串交织" class="headerlink" title="096.字符串交织"></a>096.字符串交织</h3><p>给定三个字符串 s1、s2、s3，请判断 s3 能不能由 s1 和 s2 交织（交错） 组成。</p>
<p>两个字符串 s 和 t 交织 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p>
<p>s = s1 + s2 + … + sn<br>t = t1 + t2 + … + tm<br>|n - m| &lt;= 1<br>交织 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>提示：a + b 意味着字符串 a 和 b 连接。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = s1.length(),len2 = s2.length(),len3 = s3.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> s2.equals(s3);</span><br><span class="line">        <span class="keyword">if</span>(len2 == <span class="number">0</span>) <span class="keyword">return</span> s1.equals(s3);</span><br><span class="line">        <span class="keyword">if</span> (len1 + len2 != len3) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = s2.substring(<span class="number">0</span>, j).equals(s3.substring(<span class="number">0</span>, j));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = s1.substring(<span class="number">0</span>, i).equals(s3.substring(<span class="number">0</span>, i));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = (s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]) ||</span><br><span class="line">                        (s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>) &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h3 id="097-子序列的数目"><a href="#097-子序列的数目" class="headerlink" title="097.子序列的数目"></a>097.子序列的数目</h3><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(),m = t.length();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h3 id="098-路径的数目"><a href="#098-路径的数目" class="headerlink" title="098.路径的数目"></a>098.路径的数目</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h3 id="099-最小路径之和"><a href="#099-最小路径之和" class="headerlink" title="099.最小路径之和"></a>099.最小路径之和</h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：一个机器人每次只能向下或者向右移动一步。</p>
<p>提示：</p>
<p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 200<br>0 &lt;= grid[i][j] &lt;= 100</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length,n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h3 id="100-三角形中的最小路径之和"><a href="#100-三角形中的最小路径之和" class="headerlink" title="100.三角形中的最小路径之和"></a>100.三角形中的最小路径之和</h3><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<p>提示：</p>
<p>1 &lt;= triangle.length &lt;= 200<br>triangle[0].length == 1<br>triangle[i].length == triangle[i - 1].length + 1<br>-10^4 &lt;= triangle[i][j] &lt;= 10^4</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>],dp[j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>] += triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (Integer num : dp) &#123;</span><br><span class="line">            ans = Math.min(ans,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="101-分割等和子集"><a href="#101-分割等和子集" class="headerlink" title="101.分割等和子集"></a>101.分割等和子集</h3><p>给定一个非空的正整数数组 <code>nums</code> ，请判断能否将这些数字分成元素和相等的两部分。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target)&#123;</span><br><span class="line">            dp[nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二维动态规划空间压缩</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[target]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n*target)</p>
<p>空间复杂度：O(target)</p>
<hr>
<h3 id="102-加减的目标值"><a href="#102-加减的目标值" class="headerlink" title="102.加减的目标值"></a>102.加减的目标值</h3><p>给定一个正整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 20<br>0 &lt;= nums[i] &lt;= 1000<br>0 &lt;= sum(nums[i]) &lt;= 1000<br>-1000 &lt;= target &lt;= 1000</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">//设neg为添加‘-’号的元素之和，则有sum - neg - neg = target,从而得到neg = (sum - target)/2;</span></span><br><span class="line">        <span class="comment">//问题转化为从nums中选取某些元素，使得其和为neg的方式有多少种？</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt; sum || target &lt; -sum || (sum - target) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = (sum - target) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][neg + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= neg; j++) &#123;</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*空间优化</span></span><br><span class="line"><span class="comment">    public int findTargetSumWays1(int[] nums, int target) &#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for (int num : nums) &#123;</span></span><br><span class="line"><span class="comment">            sum += num;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //设neg为添加‘-’号的元素之和，则有sum - neg - neg = target,从而得到neg = (sum - target)/2;</span></span><br><span class="line"><span class="comment">        //问题转化为从nums中选取某些元素，使得其和为neg的方式有多少种？</span></span><br><span class="line"><span class="comment">        if (target &gt; sum || target &lt; -sum || (sum - target) % 2 == 1) return 0;</span></span><br><span class="line"><span class="comment">        int neg = (sum - target)/2;</span></span><br><span class="line"><span class="comment">        int[] dp = new int[neg + 1];</span></span><br><span class="line"><span class="comment">        dp[0] = 1;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = neg; j &gt;= nums[i];j--)&#123;</span></span><br><span class="line"><span class="comment">                dp[j] = dp[j] + dp[j - nums[i]];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp[neg];</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n*neg)</p>
<p>空间复杂度：O(neg)</p>
<hr>
<h3 id="103-最少的硬币数目"><a href="#103-最少的硬币数目" class="headerlink" title="103.最少的硬币数目"></a>103.最少的硬币数目</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 10^4</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - coins[j] &gt;= <span class="number">0</span> &amp;&amp; dp[i - coins[j]] &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">                    minCount = Math.min(minCount,dp[i - coins[j]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = minCount == Integer.MAX_VALUE ? -<span class="number">1</span> : minCount + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(amount*n)</p>
<p>空间复杂度：O(amount)</p>
<hr>
<h3 id="104-排列的数目"><a href="#104-排列的数目" class="headerlink" title="104.排列的数目"></a>104.排列的数目</h3><p>给定一个由 不同 正整数组成的数组 nums ，和一个目标整数 target 。请从 nums 中找出并返回总和为 target 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 1000<br>nums 中的所有元素 互不相同<br>1 &lt;= target &lt;= 1000</p>
<p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - nums[j] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">    * 进阶问题</span></span><br><span class="line"><span class="comment">如果给定的数组中含有负数，则会导致出现无限长度的排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例如，假设数组 nums 中含有正整数 a 和负整数 -b（其中 a&gt;0,b&gt;0,-b&lt;0），则有 a×b+(−b)×a=0，对于任意一个元素之和等于 target 的排列，在该排列的后面添加 b 个 a 和 a 个 −b 之后，得到的新排列的元素之和仍然等于target，而且还可以在新排列的后面继续 b 个 a 和 a 个 −b。因此只要存在元素之和等于 target 的排列，就能构造出无限长度的排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(target*n)</p>
<p>空间复杂度：O(target)</p>
<hr>
<h3 id="105-岛屿的最大面积"><a href="#105-岛屿的最大面积" class="headerlink" title="105.岛屿的最大面积"></a>105.岛屿的最大面积</h3><p>给定一个由 0 和 1 组成的非空二维数组 grid ，用来表示海洋岛屿地图。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>
<p>提示：</p>
<p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 50<br>grid[i] [j] is either 0 or 1</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length,n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> count = getSizeOfIsland(grid,i,j);</span><br><span class="line">                    res = Math.max(res,count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSizeOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] poll = queue.poll();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">int</span> i0 = poll[<span class="number">0</span>], j0 = poll[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> i1 = i0 - <span class="number">1</span>,i2 = i0 + <span class="number">1</span>,j1 = j0 - <span class="number">1</span>,j2 = j0 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt;= <span class="number">0</span> &amp;&amp; grid[i1][j0] == <span class="number">1</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i1,j0&#125;);</span><br><span class="line">                grid[i1][j0] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i2 &lt; m &amp;&amp; grid[i2][j0] == <span class="number">1</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i2,j0&#125;);</span><br><span class="line">                grid[i2][j0] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j1 &gt;= <span class="number">0</span> &amp;&amp; grid[i0][j1] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i0,j1&#125;);</span><br><span class="line">                grid[i0][j1] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j2 &lt; n &amp;&amp; grid[i0][j2] == <span class="number">1</span>)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i0,j2&#125;);</span><br><span class="line">                grid[i0][j2] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(m*n)</p>
<hr>
<h3 id="106-二分图"><a href="#106-二分图" class="headerlink" title="106.二分图"></a>106.二分图</h3><p>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。</p>
<p>给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：</p>
<p>不存在自环（graph[u] 不包含 u）。<br>不存在平行边（graph[u] 不包含重复值）。<br>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）<br>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。<br>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p>
<p>如果图是二分图，返回 true ；否则，返回 false 。</p>
<p>提示：</p>
<p>graph.length == n<br>1 &lt;= n &lt;= 100<br>0 &lt;= graph[u].length &lt; n<br>0 &lt;= graph[u] [i] &lt;= n - 1<br>graph[u] 不会包含 u<br>graph[u] 的所有值 互不相同<br>如果 graph[u] 包含 v，那么 graph[v] 也会包含 u</p>
<p>方法一：深度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NO_COLOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BLUE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//节点i未染色，则染成红色或蓝色,入栈</span></span><br><span class="line">            <span class="keyword">if</span> (colors[i] != NO_COLOR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            colors[i] = RED;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> i1 = stack.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i2 : graph[i1]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colors[i2] == colors[i1]) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (colors[i2] == NO_COLOR) &#123;</span><br><span class="line">                        colors[i2] = colors[i1] == RED ? BLUE : RED;</span><br><span class="line">                        stack.push(i2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(N + M)</p>
<p>空间复杂度：O(N)</p>
<p>方法二：并查集</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(graph.length);</span><br><span class="line">        <span class="comment">// 遍历每个顶点，将当前顶点的所有邻接点进行合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] adjs = graph[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w: adjs) &#123;</span><br><span class="line">                <span class="comment">// 若某个邻接点与当前顶点已经在一个集合中了，说明不是二分图，返回 false。</span></span><br><span class="line">                <span class="keyword">if</span> (uf.isConnected(i, w)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                uf.union(adjs[<span class="number">0</span>], w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] roots;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        roots = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            roots[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roots[i] == i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roots[i] = find(roots[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 p 和 q 是否在同一个集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(q) == find(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 p 和 q 到一个集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        roots[find(p)] = find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(N + M)</p>
<p>空间复杂度：O(N)</p>
<hr>
<h3 id="107-矩阵中的距离"><a href="#107-矩阵中的距离" class="headerlink" title="107.矩阵中的距离"></a>107.矩阵中的距离</h3><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<p>提示：</p>
<p>m == mat.length<br>n == mat[i].length<br>1 &lt;= m, n &lt;= 10^4<br>1 &lt;= m * n &lt;= 10^4<br>mat[i] [j] is either 0 or 1.<br>mat 中至少有一个 0 </p>
<p>方法一：广度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">		<span class="keyword">int</span>[][] arr = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将所有的 0 添加进初始队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                    flag[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> cur_i = poll[<span class="number">0</span>], cur_j = poll[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> next_i = cur_i + arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> next_j = cur_j + arr[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (next_i &gt;= <span class="number">0</span> &amp;&amp; next_i &lt; m &amp;&amp; next_j &gt;= <span class="number">0</span> &amp;&amp; next_j &lt; n &amp;&amp; !flag[next_i][next_j]) &#123;</span><br><span class="line">                    res[next_i][next_j] = res[cur_i][cur_j] + <span class="number">1</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;next_i,next_j&#125;);</span><br><span class="line">                    flag[next_i][next_j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<p>方法二：动态规划</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            Arrays.fill(dist[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 (i, j) 的元素为 0，那么距离为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(mn)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h3 id="108-单词演变"><a href="#108-单词演变" class="headerlink" title="108.单词演变"></a>108.单词演变</h3><p>在字典（单词列表） wordList 中，从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p>
<p>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给定两个长度相同但内容不同的单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p>
<p>提示：</p>
<p>1 &lt;= beginWord.length &lt;= 10<br>endWord.length == beginWord.length<br>1 &lt;= wordList.length &lt;= 5000<br>wordList[i].length == beginWord.length<br>beginWord、endWord 和 wordList[i] 由小写英文字母组成<br>beginWord != endWord<br>wordList 中的所有字符串 互不相同</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = wordList.size();</span><br><span class="line">        <span class="comment">//建立虚拟节点与每个单词的映射关系</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//建图，边集映射关系</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; grid = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String key = wordList.get(i);</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (isNext(wordList.get(i), wordList.get(j))) &#123;</span><br><span class="line">                    list.add(wordList.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            grid.put(key, list);</span><br><span class="line">            map.put(key, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!grid.containsKey(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若beginWord不在wordList中，将beginWord加入图中</span></span><br><span class="line">        <span class="keyword">if</span> (!grid.containsKey(beginWord)) &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNext(wordList.get(i), beginWord)) &#123;</span><br><span class="line">                    list.add(wordList.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            grid.put(beginWord, list);</span><br><span class="line">            map.put(beginWord, n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> beginId = map.get(beginWord);</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[map.size()];</span><br><span class="line">        Arrays.fill(ints, Integer.MAX_VALUE);</span><br><span class="line">        ints[beginId] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        <span class="comment">//广度优先搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            String poll = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll.equals(endWord)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ints[map.get(poll)] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String str : grid.get(poll)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[map.get(str)] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    ints[map.get(str)] = ints[map.get(poll)] + <span class="number">1</span>;</span><br><span class="line">                    queue.add(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNext</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(N* C^2)</p>
<p>空间复杂度：O(N* C^2)</p>
<hr>
<h3 id="109-开密码锁"><a href="#109-开密码锁" class="headerlink" title="109.开密码锁"></a>109.开密码锁</h3><p>一个密码锁由 4 个环形拨轮组成，每个拨轮都有 10 个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 target 代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p>
<p>提示：</p>
<p>1 &lt;= deadends.length &lt;= 500<br>deadends[i].length == 4<br>target.length == 4<br>target 不在 deadends 之中<br>target 和 deadends[i] 仅由若干位数字组成</p>
<p>方法一：双向BFS</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">        String begin = <span class="string">&quot;0000&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (begin.equals(target)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//两个方向的搜索队列</span></span><br><span class="line">        Queue&lt;String&gt; queueBegin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queueEnd = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个哈希表分别记录两个方向已经搜索过的节点以及对应的转换次数</span></span><br><span class="line">        Map&lt;String,Integer&gt; visitedBegin = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String,Integer&gt; visitedEnd = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//分别将首节点加入队列和哈希表中</span></span><br><span class="line">        queueBegin.add(begin);</span><br><span class="line">        visitedBegin.put(begin,<span class="number">0</span>);</span><br><span class="line">        queueEnd.add(target);</span><br><span class="line">        visitedEnd.put(target,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//记录死亡数字，方便后续判断</span></span><br><span class="line">        Set&lt;String&gt; deadNums = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line">        <span class="comment">//死亡数字中包含初始节点，直接返回-1；</span></span><br><span class="line">        <span class="keyword">if</span> (deadNums.contains(begin)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*只有两个队列都不空，才有必要继续往下搜索</span></span><br><span class="line"><span class="comment">        如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点*/</span></span><br><span class="line">        <span class="keyword">while</span> (!queueBegin.isEmpty() &amp;&amp; !queueEnd.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (queueBegin.size() &lt; queueEnd.size()) &#123;</span><br><span class="line">                count = update(queueBegin, visitedBegin, visitedEnd, deadNums);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = update(queueEnd, visitedEnd, visitedBegin,deadNums);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果count依然为-1，说明本次对当前队列的搜索未搜索到目标节点，继续下次搜索</span></span><br><span class="line">            <span class="keyword">if</span> (count != -<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Queue&lt;String&gt; queue, Map&lt;String, Integer&gt; cur, Map&lt;String, Integer&gt; other, Set&lt;String&gt; deadNums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String poll = queue.poll();</span><br><span class="line">            <span class="comment">// 枚举替换哪个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 能「正向转」也能「反向转」，这里直接枚举偏移量 [-1,1] 然后跳过 0</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] chars = poll.toCharArray();</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//求得替换字符串 str</span></span><br><span class="line">                    <span class="keyword">int</span> origin = chars[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">int</span> next = (origin + j) % <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span> (next == -<span class="number">1</span>) next = <span class="number">9</span>;</span><br><span class="line">                    chars[i] = (<span class="keyword">char</span>) (next + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    String str = String.valueOf(chars);</span><br><span class="line">                    <span class="keyword">if</span> (deadNums.contains(str) || cur.containsKey(str)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 如果在「另一方向」找到过，说明找到了最短路，否则加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (other.containsKey(str)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cur.get(poll) + <span class="number">1</span> + other.get(str);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        queue.add(str);</span><br><span class="line">                        cur.put(str, cur.get(poll) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本轮遍历当前队列未找到target；</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：启发式搜索（A*算法）</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;0000&quot;</span>.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; dead = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String deadend : deadends) &#123;</span><br><span class="line">            dead.add(deadend);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dead.contains(<span class="string">&quot;0000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;AStar&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;AStar&gt;((a, b) -&gt; a.f - b.f);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> AStar(<span class="string">&quot;0000&quot;</span>, target, <span class="number">0</span>));</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        seen.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            AStar node = pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (String nextStatus : get(node.status)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!seen.contains(nextStatus) &amp;&amp; !dead.contains(nextStatus)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextStatus.equals(target)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> node.g + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> AStar(nextStatus, target, node.g + <span class="number">1</span>));</span><br><span class="line">                    seen.add(nextStatus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">numPrev</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;9&#x27;</span> : (<span class="keyword">char</span>) (x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">numSucc</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="string">&#x27;9&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : (<span class="keyword">char</span>) (x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 status 通过一次旋转得到的数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">get</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] array = status.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> num = array[i];</span><br><span class="line">            array[i] = numPrev(num);</span><br><span class="line">            ret.add(<span class="keyword">new</span> String(array));</span><br><span class="line">            array[i] = numSucc(num);</span><br><span class="line">            ret.add(<span class="keyword">new</span> String(array));</span><br><span class="line">            array[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AStar</span> </span>&#123;</span><br><span class="line">    String status;</span><br><span class="line">    <span class="keyword">int</span> f, g, h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AStar</span><span class="params">(String status, String target, <span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">this</span>.g = g;</span><br><span class="line">        <span class="keyword">this</span>.h = getH(status, target);</span><br><span class="line">        <span class="keyword">this</span>.f = <span class="keyword">this</span>.g + <span class="keyword">this</span>.h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算启发函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getH</span><span class="params">(String status, String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> dist = Math.abs(status.charAt(i) - target.charAt(i));</span><br><span class="line">            ret += Math.min(dist, <span class="number">10</span> - dist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="110-所有路径"><a href="#110-所有路径" class="headerlink" title="110.所有路径"></a>110.所有路径</h3><p>给定一个有 n 个节点的有向无环图，用二维数组 graph 表示，请找到所有从 0 到 n-1 的路径并输出（不要求按顺序）。</p>
<p>graph 的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ），若为空，就是没有下一个节点了。</p>
<p>提示：</p>
<p>n == graph.length<br>2 &lt;= n &lt;= 15<br>0 &lt;= graph[i] [j] &lt; n<br>graph[i] [j] != i<br>保证输入为有向无环图 (GAD)</p>
<p>方法：深度优先搜索（DFS)</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        dfs(graph,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[i].length; j++) &#123;</span><br><span class="line">            dfs(graph,graph[i][j]);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(n)</p>
<hr>
<h3 id="111-计算除法"><a href="#111-计算除法" class="headerlink" title="111.计算除法"></a>111.计算除法</h3><p>给定一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p>
<p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p>
<p>注意：输入总是有效的。可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>
<p>提示：</p>
<p>1 &lt;= equations.length &lt;= 20<br>equations[i].length == 2<br>1 &lt;= Ai.length, Bi.length &lt;= 5<br>values.length == equations.length<br>0.0 &lt; values[i] &lt;= 20.0<br>1 &lt;= queries.length &lt;= 20<br>queries[i].length == 2<br>1 &lt;= Cj.length, Dj.length &lt;= 5<br>Ai, Bi, Cj, Dj 由小写英文字母与数字组成</p>
<p>方法一：深度优先遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> nvars = <span class="number">0</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; variables = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = equations.size();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; equation : equations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String str : equation) &#123;</span><br><span class="line">                <span class="keyword">if</span> (variables.containsKey(str)) <span class="keyword">continue</span>;</span><br><span class="line">                variables.put(str, nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于每个点，存储其直接连接到的所有点及对应的权值</span></span><br><span class="line">        List&lt;Pair&gt;[] edges = <span class="keyword">new</span> List[nvars];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nvars; i++) &#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> va = variables.get(equations.get(i).get(<span class="number">0</span>)), vb = variables.get(equations.get(i).get(<span class="number">1</span>));</span><br><span class="line">            edges[va].add(<span class="keyword">new</span> Pair(vb, values[i]));</span><br><span class="line">            edges[vb].add(<span class="keyword">new</span> Pair(va, <span class="number">1.0</span> / values[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> queriesCount = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] ret = <span class="keyword">new</span> <span class="keyword">double</span>[queriesCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queriesCount; i++) &#123;</span><br><span class="line">            List&lt;String&gt; query = queries.get(i);</span><br><span class="line">            <span class="keyword">double</span> result = -<span class="number">1.0</span>;</span><br><span class="line">            <span class="comment">//深度优先搜索</span></span><br><span class="line">            <span class="keyword">if</span> (variables.containsKey(query.get(<span class="number">0</span>)) &amp;&amp; variables.containsKey(query.get(<span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nvars];</span><br><span class="line">                <span class="keyword">int</span> ia = variables.get(query.get(<span class="number">0</span>)), ib = variables.get(query.get(<span class="number">1</span>));</span><br><span class="line">                visited[ia] = <span class="keyword">true</span>;</span><br><span class="line">                result = dfs(ia, ib, edges, visited);</span><br><span class="line">            &#125;</span><br><span class="line">            ret[i] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ia, <span class="keyword">int</span> ib, List&lt;Pair&gt;[] edges, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ia == ib) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        List&lt;Pair&gt; edge = edges[ia];</span><br><span class="line">        <span class="keyword">if</span> (edge == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : edge) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[pair.index]) <span class="keyword">continue</span>;<span class="comment">//该节点已经访问过，跳过</span></span><br><span class="line">            visited[pair.index] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">double</span> temp = dfs(pair.index, ib, edges, visited);</span><br><span class="line">            <span class="keyword">if</span> (temp != -<span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.value * temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            visited[pair.index] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line"></span><br><span class="line">    Pair(<span class="keyword">int</span> index, <span class="keyword">double</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n * 2^n)</p>
<p>空间复杂度：O(n)</p>
<p>方法二：并查集</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> nvars = <span class="number">0</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; variables = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = equations.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!variables.containsKey(equations.get(i).get(<span class="number">0</span>))) &#123;</span><br><span class="line">                variables.put(equations.get(i).get(<span class="number">0</span>), nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!variables.containsKey(equations.get(i).get(<span class="number">1</span>))) &#123;</span><br><span class="line">                variables.put(equations.get(i).get(<span class="number">1</span>), nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nvars];</span><br><span class="line">        <span class="keyword">double</span>[] w = <span class="keyword">new</span> <span class="keyword">double</span>[nvars];</span><br><span class="line">        Arrays.fill(w, <span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nvars; i++) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> va = variables.get(equations.get(i).get(<span class="number">0</span>)), vb = variables.get(equations.get(i).get(<span class="number">1</span>));</span><br><span class="line">            merge(f, w, va, vb, values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> queriesCount = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] ret = <span class="keyword">new</span> <span class="keyword">double</span>[queriesCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queriesCount; i++) &#123;</span><br><span class="line">            List&lt;String&gt; query = queries.get(i);</span><br><span class="line">            <span class="keyword">double</span> result = -<span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">if</span> (variables.containsKey(query.get(<span class="number">0</span>)) &amp;&amp; variables.containsKey(query.get(<span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">int</span> ia = variables.get(query.get(<span class="number">0</span>)), ib = variables.get(query.get(<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">int</span> fa = findf(f, w, ia), fb = findf(f, w, ib);</span><br><span class="line">                <span class="keyword">if</span> (fa == fb) &#123;</span><br><span class="line">                    result = w[ia] / w[ib];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret[i] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] f, <span class="keyword">double</span>[] w, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = findf(f, w, x);</span><br><span class="line">        <span class="keyword">int</span> fy = findf(f, w, y);</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        w[fx] = val * w[y] / w[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findf</span><span class="params">(<span class="keyword">int</span>[] f, <span class="keyword">double</span>[] w, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x] != x) &#123;</span><br><span class="line">            <span class="keyword">int</span> father = findf(f, w, f[x]);</span><br><span class="line">            w[x] = w[x] * w[f[x]];</span><br><span class="line">            f[x] = father;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="112-最长递增路径"><a href="#112-最长递增路径" class="headerlink" title="112.最长递增路径"></a>112.最长递增路径</h3><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p>提示：</p>
<p>m == matrix.length<br>n == matrix[i].length<br>1 &lt;= m, n &lt;= 200<br>0 &lt;= matrix[i] [j] &lt;= 2^31 - 1</p>
<p>方法一：深度优先遍历 + 记忆化搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] memory = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = dfs(matrix,i,j,memory);</span><br><span class="line">                    res = Math.max(res,cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span>[][] memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length,n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (memory[x][y] != <span class="number">0</span>) <span class="keyword">return</span> memory[x][y];</span><br><span class="line">        memory[x][y]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dirs[i][<span class="number">0</span>],ny = y + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; matrix[nx][ny] &lt; matrix[x][y])&#123;</span><br><span class="line">                memory[x][y] = Math.max(memory[x][y],dfs(matrix,nx,ny,memory) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memory[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p> 时间复杂度:O(mn)</p>
<p>空间复杂度:O(mn)</p>
<p>方法二：拓扑排序</p>
<p>基于出度的概念，可以使用拓扑排序求解。从所有出度为 0 的单元格开始广度优先搜索，每一轮搜索都会遍历当前层的所有单元格，更新其余单元格的出度，并将出度变为 0 的单元格加入下一层搜索。当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//初始化出度矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] out = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ni = i + dir[<span class="number">0</span>], nj = j + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n &amp;&amp; matrix[ni][nj] &gt; matrix[i][j])&#123;</span><br><span class="line">                        out[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将出度为0的点加入队列</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (out[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] poll = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> x = poll[<span class="number">0</span>], y = poll[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + dir[<span class="number">0</span>], ny = y + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; matrix[nx][ny] &lt; matrix[x][y])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(--out[nx][ny] == <span class="number">0</span>)&#123;</span><br><span class="line">                            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx,ny&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p> 时间复杂度:O(mn)</p>
<p>空间复杂度:O(mn)</p>
<hr>
<h3 id="113-课程顺序"><a href="#113-课程顺序" class="headerlink" title="113.课程顺序"></a>113.课程顺序</h3><p>现在总共有 numCourses 门课需要选，记为 0 到 numCourses-1。</p>
<p>给定一个数组 prerequisites ，它的每一个元素 prerequisites[i] 表示两门课程之间的先修顺序。 例如 prerequisites[i] = [ai, bi] 表示想要学习课程 ai ，需要先完成课程 bi 。</p>
<p>请根据给出的总课程数  numCourses 和表示先修顺序的 prerequisites 得出一个可行的修课序列。</p>
<p>可能会有多个正确的顺序，只要任意返回一种就可以了。如果不可能完成所有课程，返回一个空数组</p>
<p>提示:</p>
<p>1 &lt;= numCourses &lt;= 2000<br>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)<br>prerequisites[i].length == 2<br>0 &lt;= ai, bi &lt; numCourses<br>ai != bi<br>prerequisites 中不存在重复元素</p>
<p>方法一：广度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//入度数组</span></span><br><span class="line">        <span class="keyword">int</span>[] in = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//map记录key号课程是哪些课程的先修课程</span></span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            in[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">            List&lt;Integer&gt; list = map.getOrDefault(prerequisites[i][<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;()); </span><br><span class="line">            list.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            map.put(prerequisites[i][<span class="number">1</span>],list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//将入度为0的课程加入队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> poll = queue.poll();</span><br><span class="line">            res[index++] = poll;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(poll))&#123;</span><br><span class="line">                List&lt;Integer&gt; list = map.get(poll);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x : list) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--in[x] == <span class="number">0</span>) queue.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == numCourses) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p> 时间复杂度:O(mn)</p>
<p>空间复杂度:O(mn)</p>
<hr>
<h3 id="114-外星文字典"><a href="#114-外星文字典" class="headerlink" title="114.外星文字典"></a>114.外星文字典</h3><p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p>
<p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。</p>
<p>请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。</p>
<p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p>
<p>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。<br>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
<li><code>words[i]</code> 仅由小写英文字母组成</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//入度数组</span></span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Queue&lt;Character&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//把出现的字符保存在图HashMap里，每个不重复字符对应一个表示有序的有向边</span></span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : word.toCharArray())&#123;</span><br><span class="line">                graph.putIfAbsent(ch, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两两比较相邻字符串之间的关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.length; ++i)&#123;</span><br><span class="line">            String w1 = words[i-<span class="number">1</span>];</span><br><span class="line">            String w2 = words[i];</span><br><span class="line">            <span class="keyword">if</span>(checkPre(w1,w2) &amp;&amp; !w1.equals(w2)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">//检查为不合法输入</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Math.min(w1.length(), w2.length()); ++j)&#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = w1.charAt(j);</span><br><span class="line">                <span class="keyword">char</span> c2 = w2.charAt(j);</span><br><span class="line">                <span class="comment">//找到不同的字符才说明有顺序关系，把前一个字符指向后一字符，同时后一字符的入度+1</span></span><br><span class="line">                <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!graph.get(c1).contains(c2))&#123;</span><br><span class="line">                        graph.get(c1).add(c2);</span><br><span class="line">                        inDegree[c2 - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把所有入度为0的字符先加入队列，准备拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : graph.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) q.offer(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> node = q.poll();</span><br><span class="line">            <span class="comment">//从队列出来的这个字符肯定是入度为0，可以确定它的顺序，就把它加进字符顺序的结果里</span></span><br><span class="line">            sb.append(node);</span><br><span class="line">            <span class="comment">//取出当前出来的节点以后，该节点所有的出度(有向边指向所有节点的节点入度)都要减1，若有入度为0的节点字符出现，把它加进队列准备之后的拓扑排序遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> next : graph.get(node))&#123;</span><br><span class="line">                inDegree[next - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[next - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果结果集里的字符数量和图中所有节点数量相同，说明拓扑排序成功，返回结果集，否则不成功，不存在合法字母顺序</span></span><br><span class="line">        <span class="keyword">return</span> sb.length() == graph.size() ? sb.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPre</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(m &lt; n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s2.charAt(j) != s1.charAt(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不合法输入，例如：words = [&quot;abc&quot;,&quot;ab&quot;]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="115-重建序列"><a href="#115-重建序列" class="headerlink" title="115.重建序列"></a>115.重建序列</h3><p>请判断原始的序列 org 是否可以从序列集 seqs 中唯一地 重建 。</p>
<p>序列 org 是 1 到 n 整数的排列，其中 1 ≤ n ≤ 104。重建 是指在序列集 seqs 中构建最短的公共超序列，即  seqs 中的任意序列都是该最短序列的子序列。</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 10^4<br>org 是数字 1 到 n 的一个排列<br>1 &lt;= segs[i].length &lt;= 10^5<br>seqs[i] [j] 是 32 位有符号整数</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="keyword">int</span>[] org, List&lt;List&lt;Integer&gt;&gt; seqs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = org.length;</span><br><span class="line">        <span class="comment">//set查看序列集合中的元素是否完整(满足1～n)</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer id : seq) &#123;</span><br><span class="line">                <span class="keyword">if</span> (id &lt; <span class="number">1</span> || id &gt; n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                set.add(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//序列集元素不完整</span></span><br><span class="line">        <span class="keyword">if</span> (set.size() != n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录元素的入度</span></span><br><span class="line">        <span class="keyword">int</span>[] in = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//建元素之间的有向边关系</span></span><br><span class="line">        Map&lt;Integer,Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph.put(i,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!graph.get(seq.get(i)).contains(seq.get(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    graph.get(seq.get(i)).add(seq.get(i + <span class="number">1</span>));</span><br><span class="line">                    in[seq.get(i + <span class="number">1</span>)]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备拓扑排序，入度为0的元素入队，注意要想确定唯一序列，队列中每次只可能有唯一入度为零的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//入度为0的元素不唯一,则无法确定唯一序列</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> poll = queue.poll();</span><br><span class="line">            res.add(poll);</span><br><span class="line">            Set&lt;Integer&gt; nextSet = graph.get(poll);</span><br><span class="line">            <span class="keyword">for</span> (Integer id : nextSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--in[id] == <span class="number">0</span>) queue.add(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.size() != n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//一一比较出队序列的元素顺序，若和原始不一致则重建失败</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; org.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (org[i] != res.get(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//全部元素符合重建成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="116-省份数量"><a href="#116-省份数量" class="headerlink" title="116.省份数量"></a>116.省份数量</h3><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 200<br>n == isConnected.length<br>n == isConnected[i].length<br>isConnected[i] [j] 为 1 或 0<br>isConnected[i] [i] == 1<br>isConnected[i] [j] == isConnected[j] [i]</p>
<p>方法一：深度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(isConnected,visited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] isConnected, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[x][i] == <span class="number">1</span> &amp;&amp; !visited[i])&#123;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(isConnected,visited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2)</p>
<p>空间复杂度:O(n)</p>
<p>方法二：广度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(isConnected,visited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] isConnected, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[x][i] == <span class="number">1</span> &amp;&amp; !visited[i])&#123;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(isConnected,visited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2)</p>
<p>空间复杂度:O(n)</p>
<p>方法三：并查集</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.length;</span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">        <span class="comment">// 遍历每个顶点，将当前顶点与其邻接点进行合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    uf.union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最终合并后的集合的数量</span></span><br><span class="line">        <span class="keyword">return</span> uf.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] roots;<span class="comment">//roots[i]记录节点i的前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// 集合数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        roots = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            roots[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找节点i的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == roots[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roots[i] = find(roots[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot != qRoot) &#123;</span><br><span class="line">            roots[pRoot] = qRoot;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2 * <em>α</em>(<em>n</em>))，其中 α 为阿克曼函数的反函数，α*(*n) 可以认为是一个很小的常数。</p>
<p>空间复杂度:O(n)</p>
<hr>
<h3 id="117-相似的字符串"><a href="#117-相似的字符串" class="headerlink" title="117.相似的字符串"></a>117.相似的字符串</h3><p>如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>
<p>例如，”tars” 和 “rats” 是相似的 (交换 0 与 2 的位置)； “rats” 和 “arts” 也是相似的，但是 “star” 不与 “tars”，”rats”，或 “arts” 相似。</p>
<p>总之，它们通过相似性形成了两个关联组：{“tars”, “rats”, “arts”} 和 {“star”}。注意，”tars” 和 “arts” 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>
<p>给定一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个 字母异位词 。请问 strs 中有多少个相似字符串组？</p>
<p>字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p>
<p>提示：</p>
<p>1 &lt;= strs.length &lt;= 300<br>1 &lt;= strs[i].length &lt;= 300<br>strs[i] 只包含小写字母。<br>strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(strs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isAlike(strs[i],strs[j]))&#123;</span><br><span class="line">                    unionFind.union(strs[i],strs[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionFind.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAlike</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String[] strs;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strs = strs;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            map.put(str,str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(str).equals(str))&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(str,find(map.get(str)));</span><br><span class="line">        <span class="keyword">return</span> map.get(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        String root1 = find(str1);</span><br><span class="line">        String root2 = find(str2);</span><br><span class="line">        <span class="keyword">if</span> (!root1.equals(root2))&#123;</span><br><span class="line">            map.put(root1,root2);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2 * <em>α</em>(<em>n</em>))，其中 α 为阿克曼函数的反函数，α*(*n) 可以认为是一个很小的常数。</p>
<p>空间复杂度:O(n)</p>
<hr>
<h3 id="118-多余的边"><a href="#118-多余的边" class="headerlink" title="118.多余的边"></a>118.多余的边</h3><p>树可以看成是一个连通且 无环 的 无向 图。</p>
<p>给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p>
<p>提示:</p>
<p>n == edges.length<br>3 &lt;= n &lt;= 1000<br>edges[i].length == 2<br>1 &lt;= ai &lt; bi &lt;= edges.length<br>ai != bi<br>edges 中无重复元素<br>给定的图是连通的</p>
<p>方法：并查集</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.length;</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] edge = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (!unionFind.union(edge[<span class="number">0</span>] - <span class="number">1</span>,edge[<span class="number">1</span>] - <span class="number">1</span>)) <span class="keyword">return</span> edges[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] roots;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        roots = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            roots[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roots[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        roots[x] = find(roots[x]);</span><br><span class="line">        <span class="keyword">return</span> roots[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (find(x) == find(y)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        roots[find(x)] = find(y);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n* <em>α</em>(<em>n</em>))，其中 α 为阿克曼函数的反函数，α*(*n) 可以认为是一个很小的常数。</p>
<p>空间复杂度:O(n)</p>
<hr>
<h3 id="119-最长连续序列"><a href="#119-最长连续序列" class="headerlink" title="119.最长连续序列"></a>119.最长连续序列</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<p><strong>进阶：</strong>可以设计并实现时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>
<p>方法一：哈希表</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//哈希表去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">            <span class="comment">//遍历，存在num - 1，直接跳过，不符合最长序列要求</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(num - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(num + <span class="number">1</span>))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<p>方法二：并查集</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录每个节点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; parent;</span><br><span class="line">    <span class="comment">// 记录节点所在连通分量的节点个数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化父节点为自身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            parent.put(num, num);</span><br><span class="line">            count.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找x的父节点，实际上也就是x的最远连续右边界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!parent.containsKey(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历找到x的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (x != parent.get(x)) &#123;</span><br><span class="line">            <span class="comment">// 进行路径压缩</span></span><br><span class="line">            parent.put(x, parent.get(parent.get(x)));</span><br><span class="line">            x = parent.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个连通分量，用来将num并入到num+1的连续区间中</span></span><br><span class="line">    <span class="comment">// 返回值为x所在连通分量的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span> count.get(rootX);</span><br><span class="line">        &#125;</span><br><span class="line">        parent.put(rootX, rootY);</span><br><span class="line">        <span class="comment">// 更新该根结点连通分量的节点个数</span></span><br><span class="line">        count.put(rootY, count.get(rootX) + count.get(rootY));</span><br><span class="line">        <span class="keyword">return</span> count.get(rootY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去除nums为空的特例</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(nums);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 一次遍历即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.find(num + <span class="number">1</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// union会返回num所在连通分量的节点个数</span></span><br><span class="line">                ans = Math.max(ans, uf.union(num, num + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n* <em>α</em>(<em>n</em>))，其中 α 为阿克曼函数的反函数，α*(*n) 可以认为是一个很小的常数。</p>
<p>空间复杂度:O(n)</p>
<hr>

    </div>

    
    
    
      
  <div class="popular-posts-header">你可能感兴趣的相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2022\04\30\程序员面试金典\" rel="bookmark">程序员面试金典</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>感谢您的支持，这将鼓励我继续努力创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="曾超 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="曾超 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>曾超
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zengc0905.github.io/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="leetCode刷题笔记">http://zengc0905.github.io/2021/12/30/leetCode刷题笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>

      

      <div>
        
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

        
      </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="prev" title="深度学习">
      <i class="fa fa-chevron-left"></i> 深度学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode-top100"><span class="nav-text">leetcode top100</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-text">#437 路径总和 III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-text">#438 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">#448 找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="nav-text">#461 汉明距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-text">#494 目标和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92"><span class="nav-text">方法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">方法二：动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-text">#538 把二叉搜索树转换为累加树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-text">#543 二叉树的直径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">#560 和为K的子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE"><span class="nav-text">方法一：暴力枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">方法二：前缀和+哈希表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">#617 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-text">方法一：深度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">#581 最短无序连续子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%8E%92%E5%BA%8F"><span class="nav-text">方法一：排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E4%B8%89%E6%AE%B5%EF%BC%89"><span class="nav-text">方法二：一次遍历（将数组分成三段）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-text">#621 任务调度器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">#647 回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">方法一：动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95"><span class="nav-text">方法二：中心扩展法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-text"># 739 每日温度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="nav-text">方法一：暴力解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-text">方法二：单调栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer"><span class="nav-text">剑指offer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">03.数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%88%A9%E7%94%A8hashSet"><span class="nav-text">方法一：利用hashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8E%9F%E5%9C%B0%E4%BA%A4%E6%8D%A2"><span class="nav-text">方法二：原地交换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">04.二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-text">05.替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-text">06.从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">07.重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text">09.用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%A2%9D%E6%95%B0%E5%88%97"><span class="nav-text">10.1斐波那契额数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-text">11.旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">12.矩阵中的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-text">13.机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ADFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">方法一：DFS深度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ABFS%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">方法二：BFS广度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-text">14.1剪绳子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%93%E9%A1%B9%E7%AA%81%E5%87%BB%E7%89%88%EF%BC%89"><span class="nav-text">剑指offer（专项突击版）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#001-050"><span class="nav-text">001-050</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#001-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95"><span class="nav-text">001.整数除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95"><span class="nav-text">002.二进制加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#003-%E5%89%8Dn%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">003.前n个数字二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#004-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">004.只出现一次的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#005-%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="nav-text">005.单词长度的最大乘积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#006-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-text">006.排序数组中两个数字之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#007-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0"><span class="nav-text">007.数组中和为0的三个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#008-%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Etarget%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">008.和大于等于target的最短子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#009-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">009.乘积小于k的子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#010-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">010.和为K的子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#011-0%E5%92%8C1%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">011.0和1个数相同的子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#012-%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89"><span class="nav-text">012.左右两边子数组的和相等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#013-%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C"><span class="nav-text">013.二维子矩阵的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#014-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="nav-text">014.字符串中的变位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#015-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="nav-text">015.字符串中的所有变位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#016-%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">016.不含重复字符的最长子字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#017-%E5%90%AB%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">017.含所有字符的最短字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#018-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%96%87"><span class="nav-text">018.有效的回文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#019-%E6%9C%80%E5%A4%9A%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87"><span class="nav-text">019.最多删除一个字符得到回文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#020-%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">020.回文子字符串的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#021-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">021.删除链表的倒数第n个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#022-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="nav-text">022.链表中环的入口节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#023-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%87%8D%E5%90%88%E8%8A%82%E7%82%B9"><span class="nav-text">023.两个链表的第一个重合节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#024-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">024.反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#025-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-text">025.链表中的两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#026-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-text">026.重排链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#027-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-text">027.回文链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#028-%E5%B1%95%E5%B9%B3%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">028.展平多级双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#029-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-text">029.排序的循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#030-%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AFO-1-%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">030.插入、删除和随机访问都是O(1)的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#031-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="nav-text">031.最近最少使用缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#032-%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D"><span class="nav-text">032.有效的变位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#033-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84"><span class="nav-text">033.变位词组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#034-%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%8E%92%E5%BA%8F"><span class="nav-text">034.外星语言是否排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#035-%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE"><span class="nav-text">035.最小时间差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#036-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">036.后缀表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#037-%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E"><span class="nav-text">037.小行星碰撞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#038-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-text">038.每日温度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#039-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="nav-text">039.直方图最大矩形面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#040-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="nav-text">040.矩阵中的最大矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#041-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-text">041.滑动窗口的平均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#042-%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0"><span class="nav-text">042.最近请求次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#043-%E5%BE%80%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="nav-text">043.往完全二叉树中添加节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#044-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E5%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">044.二叉树每层的最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#045-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%BA%95%E5%B1%82%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%80%BC"><span class="nav-text">045.二叉树最底层最左边的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#046-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE"><span class="nav-text">046.二叉树的右侧视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#047-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="nav-text">047.二叉树剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#048-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">048.序列化与反序列化二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#049-%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-text">049.从根节点到叶节点的路径数字之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#050-%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E7%BB%93%E7%82%B9%E4%B9%8B%E5%92%8C"><span class="nav-text">050.向下的路径结点之和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#051-%E2%80%A6"><span class="nav-text">051-…</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#051-%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">051.节点之和最大的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#052-%E5%B1%95%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">052.展平二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#053-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="nav-text">053.二叉搜索树中的中序后继</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#054-%E6%89%80%E6%9C%89%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="nav-text">054.所有大于等于节点的值之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#055-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">055.二叉搜索树迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#056-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C"><span class="nav-text">056.二叉搜索树中两个节点之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#057-%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E4%B9%8B%E5%B7%AE%E9%83%BD%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E5%86%85"><span class="nav-text">057.值和下标之差都在给定的范围内</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#058-%E6%97%A5%E7%A8%8B%E8%A1%A8"><span class="nav-text">058.日程表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#059-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AC%ACk%E5%A4%A7%E6%95%B0%E5%80%BC"><span class="nav-text">059.数据流的第k大数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#060-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-text">060.出现频率最高的k个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#061-%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AF%B9"><span class="nav-text">061.和最小的k个数对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#062-%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-text">062.实现前缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#063-%E6%9B%BF%E6%8D%A2%E5%8D%95%E8%AF%8D"><span class="nav-text">063.替换单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#064-%E7%A5%9E%E5%A5%87%E7%9A%84%E5%AD%97%E5%85%B8"><span class="nav-text">064.神奇的字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#065-%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81"><span class="nav-text">065.最短的单词编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#066-%E5%8D%95%E8%AF%8D%E4%B9%8B%E5%92%8C"><span class="nav-text">066.单词之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#067-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96"><span class="nav-text">067.最大的异或</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#068-%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-text">068.查找插入位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#069-%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8"><span class="nav-text">069.山峰数组的顶部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#070-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-text">070.排序数组中只出现一次的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#071-%E6%8C%89%E6%9D%83%E9%87%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">071.按权重生成随机数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="nav-text">前缀和 + 二分查找：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#072-%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-text">072.求平方根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#073-%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89"><span class="nav-text">073.狒狒吃香蕉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#074-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-text">074.合并区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#075-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F"><span class="nav-text">075.数组相对排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#076-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">076.数组中的第k大的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#077-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="nav-text">077.链表排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#078-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">078.合并排序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#079-%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86"><span class="nav-text">079.所有子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#080-%E5%90%AB%E6%9C%89k%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">080.含有k个元素的组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#081-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">081.允许重复选择元素的组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#082-%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">082.含有重复元素集合的组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#083-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">083.没有重复元素的全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#084-%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">084.含有重复元素集合的全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#085-%E7%94%9F%E6%88%90%E5%8C%B9%E9%85%8D%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-text">085.生成匹配的括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#086-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">086.分割回文子字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#087-%E5%A4%8D%E5%8E%9FIP"><span class="nav-text">087.复原IP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#088-%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC"><span class="nav-text">088.爬楼梯的最小成本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#089-%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97"><span class="nav-text">089.房屋偷盗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#090-%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97"><span class="nav-text">090.环形房屋偷盗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#091-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90"><span class="nav-text">091.粉刷房子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#092-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6"><span class="nav-text">092.翻转字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#093-%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-text">093.最长斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#094-%E6%9C%80%E5%B0%91%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2"><span class="nav-text">094.最少回文分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#095-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">095.最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#096-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E7%BB%87"><span class="nav-text">096.字符串交织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#097-%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-text">097.子序列的数目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#098-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-text">098.路径的数目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#099-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C"><span class="nav-text">099.最小路径之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100-%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C"><span class="nav-text">100.三角形中的最小路径之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-text">101.分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-%E5%8A%A0%E5%87%8F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%80%BC"><span class="nav-text">102.加减的目标值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#103-%E6%9C%80%E5%B0%91%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE"><span class="nav-text">103.最少的硬币数目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E6%8E%92%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-text">104.排列的数目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-text">105.岛屿的最大面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-text">106.二分图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="nav-text">107.矩阵中的距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-%E5%8D%95%E8%AF%8D%E6%BC%94%E5%8F%98"><span class="nav-text">108.单词演变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-%E5%BC%80%E5%AF%86%E7%A0%81%E9%94%81"><span class="nav-text">109.开密码锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-text">110.所有路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-%E8%AE%A1%E7%AE%97%E9%99%A4%E6%B3%95"><span class="nav-text">111.计算除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="nav-text">112.最长递增路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-%E8%AF%BE%E7%A8%8B%E9%A1%BA%E5%BA%8F"><span class="nav-text">113.课程顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-%E5%A4%96%E6%98%9F%E6%96%87%E5%AD%97%E5%85%B8"><span class="nav-text">114.外星文字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#115-%E9%87%8D%E5%BB%BA%E5%BA%8F%E5%88%97"><span class="nav-text">115.重建序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="nav-text">116.省份数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#117-%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">117.相似的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#118-%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9"><span class="nav-text">118.多余的边</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-text">119.最长连续序列</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="曾超"
      src="/images/zc1.jpg">
  <p class="site-author-name" itemprop="name">曾超</p>
  <div class="site-description" itemprop="description">天天经过小巷，乱花漫了高墙，贪看蜂狂蝶舞，忘了世态炎凉</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zengc0905" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zengc0905" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_42403109" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42403109" rel="noopener external nofollow noreferrer" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




      
        <div class="links-of-blogroll motion-element links-of-blogroll-block">
          <div class="links-of-blogroll-title">
            <!-- modify icon to fire by szw -->
            <i class="fa fa-history fa-" aria-hidden="true"></i>
            近期文章
          </div>
          <ul class="links-of-blogroll-list">
            
            
              <li>
                <a href="/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典" target="_blank">程序员面试金典</a>
              </li>
            
              <li>
                <a href="/2022/04/15/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Netty学习笔记" target="_blank">Netty学习笔记</a>
              </li>
            
              <li>
                <a href="/2022/03/15/ssm%E6%A1%86%E6%9E%B6/" title="ssm框架" target="_blank">ssm框架</a>
              </li>
            
              <li>
                <a href="/2022/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="操作系统学习笔记" target="_blank">操作系统学习笔记</a>
              </li>
            
              <li>
                <a href="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JUC知识点整理" target="_blank">JUC知识点整理</a>
              </li>
            
          </ul>
        </div>
     


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      <!--网易云音乐播放器-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1397105439&auto=1&height=66"></iframe>
    </div> 
  </aside>
 
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">曾超</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">786k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:55</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='250,190,19' opacity='1' zIndex='-1' count='200' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/czqtxhzy1fbjx1x9grskpzvbfeb7kas3.js"></script>







  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DaPWqMMMhvWr1vm4g7PhVmOg-gzGzoHsz',
      appKey     : 'n6bU0IPWvniadHKWAeJcNV43',
      placeholder: "欢迎大家各抒己见!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<span style="color:#333333">

  
	<script src="/js/cursor/fairyDustCursor.js"></script>
  
  
    <script src="/js/cursor/fireworks.js"></script> 
  
</span>



  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = true;
    document.body.addEventListener('input', POWERMODE);
  </script>



<script type="text/javascript" src="/js/fold_action.js"></script>

<!--   -->

  
    <script src="/js/cursor/fireworks.js"></script>
  



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>

</html>
<!-- 页面点击小红心 -->
<!--<script type="text/javascript" src="/js/src/clicklove.js"></script>-->
