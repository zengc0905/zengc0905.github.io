<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetCode刷题笔记</title>
    <url>/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="leetcode-top100"><a href="#leetcode-top100" class="headerlink" title="leetcode top100"></a>leetcode top100</h1><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="#437 路径总和 III"></a>#437 路径总和 III</h2><p>&emsp;&emsp;给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<span id="more"></span>

<p><strong>方法一：深度优先搜索</strong></p>
<ul>
<li>时间复杂度：O(N^2^)，其中 N为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(N)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 O(N^2^)。</li>
<li>空间复杂度：O(N)，递归需要消耗栈空间</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = pathNum(root,targetSum);</span><br><span class="line">        res += pathSum(root.left,targetSum);</span><br><span class="line">        res += pathSum(root.right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须以node节点开始，路径和为targetSum的路径的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathNum</span><span class="params">(TreeNode node,<span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val == targetSum)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        count += pathNum(node.left, targetSum - node.val);</span><br><span class="line">        count += pathNum(node.right, targetSum - node.val);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<p><strong>方法二：前缀和（进阶），利用HashMap记录每个节点到根节点的路径和</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N为二叉树中节点的个数。利用前缀和只需遍历一次二叉树即可</li>
<li>空间复杂度：O(N)</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum1</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//prifexMap中记录每个节点到根节点的路径和，key为路径和,value为某个节点到根节点路径和为key的节点个数</span></span><br><span class="line">        HashMap&lt;Long, Integer&gt; prifexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        prifexMap.put(<span class="number">0L</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(root,targetSum,prifexMap,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//curprifex为当前节点node（不办含node）到根节点的路径和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> targetSum, HashMap&lt;Long, Integer&gt; prifexMap, <span class="keyword">long</span> curPrifex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        curPrifex += node.val;</span><br><span class="line">        res += prifexMap.getOrDefault(curPrifex - targetSum,<span class="number">0</span>);</span><br><span class="line">        prifexMap.put(curPrifex,prifexMap.getOrDefault(curPrifex,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        res += dfs(node.left,targetSum,prifexMap,curPrifex);</span><br><span class="line">        res += dfs(node.right,targetSum,prifexMap,curPrifex);</span><br><span class="line">        <span class="comment">//回溯，恢复prifexMap</span></span><br><span class="line">        prifexMap.put(curPrifex,prifexMap.get(curPrifex) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="#438 找到字符串中所有字母异位词"></a>#438 找到字符串中所有字母异位词</h2><blockquote>
<p>&emsp;&emsp;给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
</blockquote>
<p>解题思路：滑动窗口+数组</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">     <span class="comment">//滑动窗口 + 数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams1</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = p.length();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span>[] sCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len2; i &lt; len1; i++) &#123;</span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            sCount[s.charAt(i - len2) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">                list.add(i - len2 + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<hr>
<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="#448 找到所有数组中消失的数字"></a>#448 找到所有数组中消失的数字</h2><blockquote>
<p>&emsp;&emsp;给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
</ul>
</blockquote>
<p>解题思路：用一个哈希表记录数组nums 中的数字，由于数字范围均在1-n中，记录数字后我们再利用哈希表检查 1-n 中的每一个数是否出现，从而找到缺失的数字。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Set&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            hashSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashSet.contains(i))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<p>上述方法空间复杂度为O(N)，可利用原数组nums优化空间复杂度为O(1)。遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 1~n中，增加以后，这些数必然大于 n。最后遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数i+1。这样就找到了缺失的数字。<br>&emsp;&emsp;另外需要注意的是，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模来还原出它本来的值。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (nums[i] - <span class="number">1</span>) % n;</span><br><span class="line">            nums[temp] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div> 

<hr>
<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="#461 汉明距离"></a>#461 汉明距离</h2><p>&emsp;&emsp;两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>
<p>2^31^</p>
<ul>
<li>0 &lt;= x, y &lt;= 2^31^ - 1</li>
</ul>
<p>解题思路：</p>
<p>方法一：将x和y进行异或运算，统计异或后的数中1的个数</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((temp &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<p>方法二：Brian Kernighan 算法</p>
<p>记 f(x) 表示 x 和 x−1 进行与运算所得的结果（即f(x)=x &amp; (x−1)），那么f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            temp &amp;= temp - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<hr>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="#494 目标和"></a>#494 目标和</h2><p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的<strong>每个整数前</strong>添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<ul>
<li>1 &lt;= nums.length &lt;= 20</li>
<li>0 &lt;= nums[i] &lt;= 1000</li>
<li>0 &lt;= sum(nums[i]) &lt;= 1000</li>
<li>-1000 &lt;= target &lt;= 1000</li>
</ul>
<p>解题思路：</p>
<p>f(i,target) = f(i - 1,target + nums[i]) + f(i - 1,target - nums[i])</p>
<h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWays(nums,target,nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target || nums[i] == -target)&#123;</span><br><span class="line">                <span class="keyword">return</span> target == <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWays(nums,target - nums[i],i - <span class="number">1</span>) +</span><br><span class="line">                findTargetSumWays(nums,target + nums[i],i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(2^n^)，其中 n 是数组 nums 的长度。回溯需要遍历所有不同的表达式，共有 2^n^种不同的表达式，每种表达式计算结果需要 O(1) 的时间，因此总时间复杂度是 O(2^n^)；</li>
</ul>
<ul>
<li>空间复杂度：O(n)，其中 n 是数组 nums 的长度。空间复杂度主要取决于递归调用的栈空间，栈的深度不超过 n。</li>
</ul>
<h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>设neg为添加‘-’号的元素之和，则有sum - neg - neg = target,从而得到neg = (sum - target)/2;问题转化为从nums中选取某些元素，使得其和为neg的方式有多少种？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设neg为添加‘-’号的元素之和，则有sum - neg - neg = target,从而得到neg = (sum - target)/2;</span></span><br><span class="line">        <span class="comment">//问题转化为从nums中选取某些元素，使得其和为neg的方式有多少种？</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt; sum || target &lt; -sum || (sum - target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = (sum - target)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[neg + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = neg; j &gt;= nums[i];j--)&#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n* neg)</li>
<li>空间复杂度：O(sum - target)</li>
</ul>
<hr>
<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="#538 把二叉搜索树转换为累加树"></a>#538 把二叉搜索树转换为累加树</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。</li>
<li>节点的右子树仅包含键 大于 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p>解题思路：反序中序遍历</p>
<p>反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            sum += root.val;</span><br><span class="line">            root.val = sum;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> 

<ul>
<li><p>时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</p>
</li>
<li><p>空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</p>
</li>
</ul>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="#543 二叉树的直径"></a>#543 二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>深度优先搜索</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义一个全局变量res，记录整棵树的最大直径</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        process(root);</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> L = process(root.left);</span><br><span class="line">        <span class="comment">//计算右子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> R = process(root.right);</span><br><span class="line">        <span class="comment">//更新最大直径</span></span><br><span class="line">        res = Math.max(res,L + R + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(L,R) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O(N)，其中 N 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</li>
</ul>
<ul>
<li>空间复杂度：O(Height)，其中 Height 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 O(Height) 。</li>
</ul>
<hr>
<h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="#560 和为K的子数组"></a>#560 和为K的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
<h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; len; end++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = end; start &gt;= <span class="number">0</span> ; start--) &#123;</span><br><span class="line">                sum += nums[start];</span><br><span class="line">                <span class="keyword">if</span> (sum == k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><p>时间复杂度：O(n^2)，其中 n 为数组的长度。枚举子数组开头和结尾需要 O(n^2 ) 的时间，其中求和需要 O(1) 的时间复杂度，因此总时间复杂度为 O(n^2)。</p>
</li>
<li><p>空间复杂度：O(1)。只需要常数空间存放若干变量。</p>
</li>
</ul>
<h3 id="方法二：前缀和-哈希表"><a href="#方法二：前缀和-哈希表" class="headerlink" title="方法二：前缀和+哈希表"></a>方法二：前缀和+哈希表</h3><p>使用一个哈希表记录数组nums中以i结尾的前缀和的个数，hashmap中key为前缀和，value为出现的个数。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录数组nums中以i结尾前缀和为key的个数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;<span class="comment">//记录当前位置的前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(pre - k))&#123;</span><br><span class="line">                count += hashMap.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(pre,hashMap.getOrDefault(pre,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="#617 合并二叉树"></a>#617 合并二叉树</h2><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
</blockquote>
<h3 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        TreeNode right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<ul>
<li>时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>
</ul>
<ul>
<li>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>
</ul>
<hr>
<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="#581 最短无序连续子数组"></a>#581 最短无序连续子数组</h2><blockquote>
<p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>将原数组与排序后的数组进行比较</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组有序，直接返回0；</span></span><br><span class="line">        <span class="keyword">if</span> (isSorted(nums))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] numsSort = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,numsSort,<span class="number">0</span>,len);</span><br><span class="line">        Arrays.sort(numsSort);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[left] == numsSort[left])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[right] == numsSort[right])&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlogn)，其中 n 为给定数组的长度。我们需要 O(nlogn) 的时间进行排序，以及 O(n) 的时间遍历数组，因此总时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)，其中 n 为给定数组的长度。我们需要额外的一个数组保存排序后的数组 numsSorted。</p>
<h3 id="方法二：一次遍历（将数组分成三段）"><a href="#方法二：一次遍历（将数组分成三段）" class="headerlink" title="方法二：一次遍历（将数组分成三段）"></a>方法二：一次遍历（将数组分成三段）</h3><p>我们可以假设把这个数组分成三段，<code>左段</code>和<code>右段</code>是标准的升序数组，<code>中段</code>数组虽是无序的，但满足最小值大于<code>左段</code>的最大值，最大值小于<code>右段</code>的最小值。</p>
<p><img src="/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/snipaste_20220117_164246.png"></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>,right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//从左往右遍历，维护最大值，更新右边界</span></span><br><span class="line">            <span class="keyword">if</span> (max &gt; nums[i])&#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右往左遍历，维护最小值，更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (min &lt; nums[len - i - <span class="number">1</span>])&#123;</span><br><span class="line">                left = len - i - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                min = nums[len - i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right == -<span class="number">1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O*(*n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。</li>
<li>时间复杂度：O(1)，我们只需要常数的空间保存若干变量。</li>
</ul>
<hr>
<h2 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="#621 任务调度器"></a>#621 任务调度器</h2><blockquote>
<p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 最短时间 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= task.length &lt;= 10^4</code></li>
<li><code>tasks[i]</code> 是大写英文字母</li>
<li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
</blockquote>
<p>解题思路：</p>
<ol>
<li>不考虑冷却时间需要task长度时间；</li>
<li>找出任务量最多的若干任务，需要先占坑，剩下的填坑；</li>
<li>假如不可以把剩下的坑填满，那么就是最多数任务加上他们的冷却时间，否则输出task 总数。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//任务量最多的某个任务数量</span></span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//任务量等于maxCount的任务种类</span></span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            count[tasks[i] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (count[tasks[i] - <span class="string">&#x27;A&#x27;</span>] &gt; maxCount)&#123;</span><br><span class="line">                maxCount = count[tasks[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == maxCount) maxNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(tasks.length,(n + <span class="number">1</span>) * (maxCount - <span class="number">1</span>) + maxNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O(n), n为字符数组tasks的长度;</li>
<li>空间复杂度：O(1);</li>
</ul>
<hr>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="#647 回文子串"></a>#647 回文子串</h2><blockquote>
<p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p>
<p>回文字符串 是正着读和倒过来读一样的字符串。</p>
<p>子字符串 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p><code>dp[i][j] = dp[i+1][j-1]&amp;&amp;s[i] = s[j]</code></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; chars[i] == chars[i + <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i + j &lt; len &amp;&amp; chars[i] == chars[i + j])&#123;</span><br><span class="line">                    dp[i][i + j] = dp[i + <span class="number">1</span>][i + j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][i + j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2^)</p>
<p>空间复杂度：O(n)。n为字符串s的长度。</p>
<h3 id="方法二：中心扩展法"><a href="#方法二：中心扩展法" class="headerlink" title="方法二：中心扩展法"></a>方法二：中心扩展法</h3><ul>
<li>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</li>
</ul>
<p>需要注意的是：如何有序地枚举所有可能的回文中心，我们需要考虑回文长度是奇数和回文长度是偶数的两种情况。如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。</p>
<p>一种方法是做两次循环来分别枚举奇数长度和偶数长度的回文，但这样稍显繁琐，通过仔细观察可以发现，长度为n 的字符串会生成 2n−1 组回文中心 [l_i, r_i]，其中  l_i = ⌊ 2/i⌋，r_i = l_i + (i %mod 2)。这样我们只要从 0 到 2n−2 遍历 i，就可以得到所有可能的回文中心，这样就把奇数长度和偶数长度两种情况统一起来了。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最外层循环遍历所有回文中心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//以l为回文中心左边界，r为回文中心右边界向外扩展，判断是否是回文子串</span></span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len &amp;&amp; chars[l] == chars[r]) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2^)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="# 739 每日温度"></a># 739 每日温度</h2><blockquote>
<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
</blockquote>
<h3 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; temperatures[j] &lt;= temperatures[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == len) &#123;</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = j - i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2^)</p>
<p>空间复杂度：O(1)</p>
<h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h3><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//当栈不为空并且当前元素大于栈顶元素，栈顶元素出栈，计算天数</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">                res[cur] = i - cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈为空或者当前元素小于栈顶元素，当前元素入栈</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p>
<p>空间复杂度：O(n),其中 n是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p>
<hr>
<br>

<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03.数组中重复的数字"></a>03.数组中重复的数字</h2><blockquote>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<h3 id="方法一：利用hashSet"><a href="#方法一：利用hashSet" class="headerlink" title="方法一：利用hashSet"></a>方法一：利用hashSet</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    	HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            hashSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度 O(N) ： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。<br>空间复杂度 O(N) ： HashSet 占用 O(N) 大小的额外空间。</p>
<h3 id="方法二：原地交换"><a href="#方法二：原地交换" class="headerlink" title="方法二：原地交换"></a>方法二：原地交换</h3><p>可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一个重复值并返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="comment">//原地交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[nums[i]];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。<br>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</p>
<hr>
<h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04.二维数组中的查找"></a>04.二维数组中的查找</h2><blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p><strong>限制：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= n &lt;= <span class="number">1000</span></span><br><span class="line"><span class="symbol">0 </span>&lt;= m &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>题解：由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>
<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//n为行数，m为列数</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从右上角往左下角遍历</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到目标，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。<br>空间复杂度：O(1)。</p>
<hr>
<h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05.替换空格"></a>05.替换空格</h2><blockquote>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p>0 &lt;= s 的长度 &lt;= 10000</p>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n);</p>
<p>空间复杂度:O(n);</p>
<hr>
<h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06.从尾到头打印链表"></a>06.从尾到头打印链表</h2><blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>0 &lt;= 链表长度 &lt;= 10000</p>
</blockquote>
<p>题解: 栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">  		 <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head =head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。<br>空间复杂度：O(n)。额外使用一个栈存储链表中的每个节点。</p>
<hr>
<h2 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07.重建二叉树"></a>07.重建二叉树</h2><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
</blockquote>
<p>题解：在中序遍历中定位到根节点，可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p>
<p>这样一来，就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = preorder.length;</span><br><span class="line">        TreeNode root = buildTree(preorder, <span class="number">0</span>, len - <span class="number">1</span>, inorder, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当前根节点</span></span><br><span class="line">        TreeNode currentRootNode = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="comment">//找出当前根节点在中序遍历中的索引</span></span><br><span class="line">        <span class="keyword">int</span> i = getIndexOfInorder(inorder, inStart, inEnd, preorder[preStart]);</span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        TreeNode leftNode = buildTree(preorder, preStart + <span class="number">1</span>, preStart + i - inStart, inorder, inStart, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归右子树</span></span><br><span class="line">        TreeNode rightNode = buildTree(preorder, preStart + i - inStart + <span class="number">1</span>, preEnd, inorder, i + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="comment">//连接左右子树</span></span><br><span class="line">        currentRootNode.left = leftNode;</span><br><span class="line">        currentRootNode.right = rightNode;</span><br><span class="line">        <span class="keyword">return</span> currentRootNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出当前根节点在中序遍历中的索引（这一步还可以优化，利用hashmap在常数时间复杂度内得到索引值）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndexOfInorder</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><p>时间复杂度：O(n),其中 n是树中的节点个数。</p>
</li>
<li><p>空间复杂度：O(m),其中m为树的高度。</p>
</li>
</ul>
<hr>
<h2 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09.用两个栈实现队列"></a>09.用两个栈实现队列</h2><blockquote>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素从此栈入</span></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    <span class="comment">//元素从此栈出</span></span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        stackIn.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackIn.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li><p>时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。插入不多说，对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。</p>
</li>
<li><p>空间复杂度：O(n)。需要使用两个栈存储已有的元素。</p>
</li>
</ul>
<hr>
<h2 id="10-1斐波那契额数列"><a href="#10-1斐波那契额数列" class="headerlink" title="10.1斐波那契额数列"></a>10.1斐波那契额数列</h2><blockquote>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法一：递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; fib = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fib.add(<span class="number">0</span>);</span><br><span class="line">        fib.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fib.add(i,(fib.get(i - <span class="number">1</span>) + fib.get(i - <span class="number">2</span>))% (<span class="number">1000000007</span>));</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> fib.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法二：动态规划</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11.旋转数组的最小数字"></a>11.旋转数组的最小数字</h2><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  </p>
</blockquote>
<p>题解：排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。本题要找的旋转数组的最小值即旋转点</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                <span class="comment">//旋转点在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[right])&#123;</span><br><span class="line">                <span class="comment">//旋转点在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无法判断旋转点位置</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h2><blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<ul>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>
</ul>
</blockquote>
<p>题解：本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。</p>
<p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board,chars,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//搜索越界或者当前字符不匹配，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//匹配的字符置为空，防止重复匹配</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//全部字符匹配成功，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//递归匹配下一个字符</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//回溯，恢复现场</span></span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度 O(3^K^MN)： 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K^)；矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。<br>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 33种选择，因此方案数的复杂度为 O(3^K^) 。</li>
<li>空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</li>
</ul>
<hr>
<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h2><blockquote>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
</blockquote>
<h3 id="方法一：DFS深度优先遍历"><a href="#方法一：DFS深度优先遍历" class="headerlink" title="方法一：DFS深度优先遍历"></a>方法一：DFS深度优先遍历</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不满足条件，返回0；</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || getSum(i) + getSum(j) &gt; k || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//默认为fasle,搜素过后置为true</span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i,j + <span class="number">1</span>) + dfs(i + <span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算数位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="方法二：BFS广度优先遍历"><a href="#方法二：BFS广度优先遍历" class="headerlink" title="方法二：BFS广度优先遍历"></a>方法二：BFS广度优先遍历</h3><p>利用队列实现广度优先遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">int</span>[] ints = queue.poll();</span><br><span class="line">           <span class="keyword">int</span> i = ints[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">int</span> j = ints[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">int</span> si = getSum(i);</span><br><span class="line">           <span class="keyword">int</span> sj = getSum(j);</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">           ans++;</span><br><span class="line">           visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">           queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>,j&#125;);</span><br><span class="line">           queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j + <span class="number">1</span>&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//计算数位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度：O(mn)</li>
<li>空间复杂度：O(mn)</li>
</ul>
<hr>
<h2 id="14-1剪绳子"><a href="#14-1剪绳子" class="headerlink" title="14.1剪绳子"></a>14.1剪绳子</h2><blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18</p>
<ul>
<li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
</blockquote>
<p>题解：由数学推导可得：</p>
<ul>
<li>当所有绳段长度相等时，乘积最大</li>
<li>最优的绳段长度为3</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ul>
<li>时间复杂度 O(1)： 仅有求整、求余、次方运算。</li>
<li>空间复杂度O(1)</li>
</ul>
<p>进阶：答案需要取模1e9+7</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//循环取余</span></span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">                res *= <span class="number">3</span>;</span><br><span class="line">                res %= <span class="number">1000000007</span>;</span><br><span class="line">                n -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最终剩下来的肯定是2,3,4</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h1 id="剑指offer（专项突击版）"><a href="#剑指offer（专项突击版）" class="headerlink" title="剑指offer（专项突击版）"></a>剑指offer（专项突击版）</h1><h2 id="001-整数除法"><a href="#001-整数除法" class="headerlink" title="001.整数除法"></a>001.整数除法</h2><p>给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 ‘*’、除号 ‘/‘ 以及求余符号 ‘%’ 。</p>
<p>注意：</p>
<ul>
<li>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31−1]。本题中，如果除法结果溢出，则返回 2^31 − 1</li>
</ul>
<p>减法代替除法，并使用位运算优化减法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sign = (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    a = Math.abs(a);</span><br><span class="line">    b = Math.abs(b);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 首先，右移的话，再怎么着也不会越界</span></span><br><span class="line">        <span class="comment">// 其次，无符号右移的目的是：将 -2147483648 看成 2147483648</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这里不能是 (a &gt;&gt;&gt; i) &gt;= b 而应该是 (a &gt;&gt;&gt; i) - b &gt;= 0</span></span><br><span class="line">        <span class="comment">// 这个也是为了避免 b = -2147483648，如果 b = -2147483648</span></span><br><span class="line">        <span class="comment">// 那么 (a &gt;&gt;&gt; i) &gt;= b 永远为 true，但是 (a &gt;&gt;&gt; i) - b &gt;= 0 为 false</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;&gt;&gt; i) - b &gt;= <span class="number">0</span>) &#123; <span class="comment">// a &gt;= (b &lt;&lt; i)</span></span><br><span class="line">            a -= (b &lt;&lt; i);</span><br><span class="line">            <span class="comment">// 代码优化：这里控制 res 大于等于 INT_MAX</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE - (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bug 修复：因为不能使用乘号，所以将乘号换成三目运算符</span></span><br><span class="line">    <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="002-二进制加法"><a href="#002-二进制加法" class="headerlink" title="002.二进制加法"></a>002.二进制加法</h2><p>给定两个 01 字符串 <code>a</code> 和 <code>b</code> ，请计算它们的和，并以二进制字符串的形式输出。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p>提示：</p>
<p>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。<br>1 &lt;= a.length, b.length &lt;= 10^4<br>字符串如果不是 “0” ，就都不含前导零。</p>
<h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;<span class="comment">//从最低位开始</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c != <span class="number">0</span>)&#123;<span class="comment">//未加完或者存在进位</span></span><br><span class="line">            <span class="keyword">int</span> numA = i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> numB = j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = numA + numB + c;</span><br><span class="line">            c = sum &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            sum = sum &gt;= <span class="number">2</span> ? (sum - <span class="number">2</span>) : sum;</span><br><span class="line">            res.append(sum);</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>复杂度分析</p>
<p>假设 n=max{∣a∣,∣b∣}。</p>
<p>时间复杂度：O(n)，这里的时间复杂度来源于顺序遍历 a 和 b。<br>空间复杂度：O(1)，除去答案所占用的空间，这里使用了常数个临时变量。</p>
<h3 id="方法二：位运算"><a href="#方法二：位运算" class="headerlink" title="方法二：位运算"></a>方法二：位运算</h3><p>此方法字符串长度太长会溢出</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numa = Integer.parseInt(a, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> numb = Integer.parseInt(b,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> res = numa ^ numb;</span><br><span class="line">        <span class="keyword">int</span> carry = (numa &amp; numb) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (carry != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = res;</span><br><span class="line">            res ^= carry;</span><br><span class="line">            carry = (carry &amp; temp) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.toBinaryString(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="003-前n个数字二进制中1的个数"><a href="#003-前n个数字二进制中1的个数" class="headerlink" title="003.前n个数字二进制中1的个数"></a>003.前n个数字二进制中1的个数</h2><p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>
<p>说明 :</p>
<p>0 &lt;= n &lt;= 10^5</p>
<p>进阶:</p>
<p>给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？<br>要求算法的空间复杂度为 O(n) 。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。</p>
<h3 id="方法一：最高有效位"><a href="#方法一：最高有效位" class="headerlink" title="方法一：最高有效位"></a>方法一：最高有效位</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = res[i - j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="方法二：最低有效位"><a href="#方法二：最低有效位" class="headerlink" title="方法二：最低有效位"></a>方法二：最低有效位</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = i % <span class="number">2</span> == <span class="number">0</span> ? res[i / <span class="number">2</span>] : res[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度都是O（n）</p>
<hr>
<h2 id="004-只出现一次的数字"><a href="#004-只出现一次的数字" class="headerlink" title="004.只出现一次的数字"></a>004.只出现一次的数字</h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 3 * 10^4<br>-2^31 &lt;= nums[i] &lt;= 2^31 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</p>
<p>进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>使用哈希映射统计数组中每个元素的出现次数。对于哈希映射中的每个键值对，键表示一个元素，值表示其出现的次数。</p>
<p>在统计完成后，我们遍历哈希映射即可找出只出现一次的元素。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; freq = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            freq.put(num, freq.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : freq.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey(), occ = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (occ == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 是数组的长度。</p>
<p>空间复杂度：O(n)。</p>
<h3 id="方法二：依次确定每一个二进制位"><a href="#方法二：依次确定每一个二进制位" class="headerlink" title="方法二：依次确定每一个二进制位"></a>方法二：依次确定每一个二进制位</h3><div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                total += ((num &gt;&gt; i)) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (total % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围<br>空间复杂度：O(1)</p>
<hr>
<h2 id="005-单词长度的最大乘积"><a href="#005-单词长度的最大乘积" class="headerlink" title="005.单词长度的最大乘积"></a>005.单词长度的最大乘积</h2><p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
<li><code>words[i]</code> 仅包含小写字母</li>
</ul>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用一个数组masks记录每个单词的状态</span></span><br><span class="line">        <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; masks.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                masks[i] |= (<span class="number">1</span> &lt;&lt; c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            String word1 = words[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">                String word2 = words[j];</span><br><span class="line">                <span class="comment">//masks中两元素值不相等，说明两个字符串不含有相同字符</span></span><br><span class="line">                <span class="keyword">if</span> ((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = Math.max(ans,word1.length() * word2.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2),n是字符串数组的长度</p>
<p>空间复杂度: O(n)</p>
<hr>
<h2 id="006-排序数组中两个数字之和"><a href="#006-排序数组中两个数字之和" class="headerlink" title="006.排序数组中两个数字之和"></a>006.排序数组中两个数字之和</h2><p>给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 &lt;= answer[0] &lt; answer[1] &lt; numbers.length 。</p>
<p>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p>
<p>提示：</p>
<p>2 &lt;= numbers.length &lt;= 3 * 10^4<br>-1000 &lt;= numbers[i] &lt;= 1000<br>numbers 按 递增顺序 排列<br>-1000 &lt;= target &lt;= 1000<br>仅存在一个有效答案</p>
<p>方法一：hash表</p>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(target - numbers[i]))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = hashmap.get(target - numbers[i]);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(numbers[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n);</p>
<p>空间复杂度：O(n);</p>
<p> 方法二：双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[l] + numbers[r] &lt; target)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[<span class="number">0</span>] = l;</span><br><span class="line">                res[<span class="number">1</span>] = r;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n);</p>
<p>空间复杂度：O(1);</p>
<hr>
<h2 id="007-数组中和为0的三个数"><a href="#007-数组中和为0的三个数" class="headerlink" title="007.数组中和为0的三个数"></a>007.数组中和为0的三个数</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<p>双指针法，先排序，然后从左往右遍历固定一个值，然后转化为两数之和</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//去重</span></span><br><span class="line">		 <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] + nums[r] &gt; target)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[l] + nums[r] &lt; target)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));</span><br><span class="line">                    <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(l &lt; r &amp;&amp; nums[l] == nums[++l])) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(l &lt; r &amp;&amp; nums[r] == nums[--r])) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h2 id="008-和大于等于target的最短子数组"><a href="#008-和大于等于target的最短子数组" class="headerlink" title="008.和大于等于target的最短子数组"></a>008.和大于等于target的最短子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>提示：</p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p>滑动窗口法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = len;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; r &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; target)&#123;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span> (r &lt; len)&#123;</span><br><span class="line">                    cur += nums[r];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(r - l + <span class="number">1</span>,ans);</span><br><span class="line">                cur -= nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h2 id="009-乘积小于k的子数组"><a href="#009-乘积小于k的子数组" class="headerlink" title="009.乘积小于k的子数组"></a>009.乘积小于k的子数组</h2><p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
<p><strong>提示:</strong> </p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>0 &lt;= k &lt;= 10^6</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            total *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; total &gt;= k) &#123;</span><br><span class="line">                total /= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                ret += right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2021/12/29/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-java概述"><a href="#1-java概述" class="headerlink" title="1.java概述"></a>1.java概述</h1><h2 id="1-1-面向对象和面向过程的区别"><a href="#1-1-面向对象和面向过程的区别" class="headerlink" title="1.1 面向对象和面向过程的区别"></a>1.1 面向对象和面向过程的区别</h2><ul>
<li>面向过程：⾯向过程性能⽐⾯向对象⾼。 因为类调⽤时需要实例化，开销⽐᫾⼤，⽐᫾消耗资 源，所以当性能是最重要的考量因素的时候，⽐如单⽚机、嵌⼊式开发、Linux/Unix 等⼀般采 ⽤⾯向过程开发。但是，⾯向过程没有⾯向对象易维护、易复⽤、易扩展。</li>
<li>⾯向对象 ：⾯向对象易维护、易复⽤、易扩展。 因为⾯向对象有封装、继承、多态性的特性， 所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，⾯向对象性能⽐⾯向过 程低。</li>
</ul>
<p>⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏，⽽ Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的 ⼆进制机器码。</p>
<h2 id="1-2-Java语言编译与解释共存"><a href="#1-2-Java语言编译与解释共存" class="headerlink" title="1.2 Java语言编译与解释共存"></a>1.2 Java语言编译与解释共存</h2><p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><strong>编译型</strong> ：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型</strong> ：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h2 id="1-3-什么是字节码"><a href="#1-3-什么是字节码" class="headerlink" title="1.3 什么是字节码"></a>1.3 什么是字节码</h2><p>​        在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何 特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统编译型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时⽐较⾼效，⽽ 且，由于字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统 的计算机上运⾏。</p>
<p>java程序的运行步骤：</p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_095023.png"></p>
<p>在class到机器码这一步，JVM 类加载器⾸先加载字节码⽂件，然后 通过解释器逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐较慢。⽽且，有些⽅法和代码块是经常需要被 调⽤的(也就是所谓的热点代码)，所以后⾯引进了 JIT 编译器，⽽ JIT 属于运⾏时编译。当 JIT 编 译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。⽽我们知道，机器 码的运⾏效率肯定是⾼于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的 语⾔</p>
<h2 id="1-4-JVM-JDK-JRE的区别与联系"><a href="#1-4-JVM-JDK-JRE的区别与联系" class="headerlink" title="1.4 JVM,JDK,JRE的区别与联系"></a>1.4 JVM,JDK,JRE的区别与联系</h2><ul>
<li>java虚拟机（JVM）Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows， Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。（一次编译，到处运行）</li>
<li>JDK 是 Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器 （javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</li>
<li>JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机 （JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</li>
</ul>
<h2 id="1-4-java和c-的区别"><a href="#1-4-java和c-的区别" class="headerlink" title="1.4 java和c++的区别"></a>1.4 java和c++的区别</h2><ul>
<li>都是⾯向对象的语⾔，都⽀持封装、继承和多态</li>
<li> Java 不提供指针来直接访问内存，程序内存更加安全 </li>
<li>Java 的类是单继承的，C++ ⽀持多重继承，虽然 Java 的类不可以多继承，但是接⼝可以多继承。 </li>
<li>Java 有⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</li>
</ul>
<h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h1><h2 id="2-1-java-基本数据类型与相应的包装类"><a href="#2-1-java-基本数据类型与相应的包装类" class="headerlink" title="2.1 java 基本数据类型与相应的包装类"></a>2.1 java 基本数据类型与相应的包装类</h2><p>Java 中有 8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code></li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">位数</th>
<th align="center">字节</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int</code></td>
<td align="center">32</td>
<td align="center">4</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>short</code></td>
<td align="center">16</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center">64</td>
<td align="center">8</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center"><code>byte</code></td>
<td align="center">8</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">16</td>
<td align="center">2</td>
<td align="center">‘u0000’</td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center">32</td>
<td align="center">4</td>
<td align="center">0f</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">64</td>
<td align="center">8</td>
<td align="center">0d</td>
</tr>
<tr>
<td align="center"><code>boolean</code></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</p>
<p>java编程思想第四版：2.2.2节</p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_100713.png"></p>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p>输出false。</p>
<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<p><em><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</em></p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_111337.png"></p>
<p><strong>自动装箱与拆箱：</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>上面这两行代码对应的字节码为：</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java<span class="regexp">/lang/I</span>nteger.valueOf (I)Ljava<span class="regexp">/lang/I</span>nteger;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava<span class="regexp">/lang/I</span>nteger;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava<span class="regexp">/lang/I</span>nteger;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java<span class="regexp">/lang/I</span>nteger.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> <span class="keyword">RETURN</span></span><br></pre></td></tr></table></figure>



</div></div>

<p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h2 id="2-2-java-重载和重写的区别"><a href="#2-2-java-重载和重写的区别" class="headerlink" title="2.2 java 重载和重写的区别"></a>2.2 java 重载和重写的区别</h2><ul>
<li>重载就是同样的⼀个⽅法能够根据输⼊数据的不同，做出不同的处理 。发⽣在同⼀个类中，⽅法名必须相同，参数类型不同、个数不同、顺序不同，⽅法返回值和访问修饰符可以不同。</li>
<li>重写就是当⼦类继承⾃⽗类的相同⽅法，输⼊数据⼀样，但要做出有别于⽗类的响应时，你就要覆盖⽗类⽅法。<strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892</a> ）：<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
</li>
</ul>
<p>综上：重载就是同⼀个类中多个同名⽅法根据不同的传参来执⾏不同的逻辑处理；重写发⽣在运⾏期，是⼦类对⽗类的允许访问的⽅法的实现过程进⾏重新编写。</p>
<h2 id="2-3-静态方法为何不能调用非静态成员"><a href="#2-3-静态方法为何不能调用非静态成员" class="headerlink" title="2.3 静态方法为何不能调用非静态成员"></a>2.3 静态方法为何不能调用非静态成员</h2><ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h2 id="2-4-泛型"><a href="#2-4-泛型" class="headerlink" title="2.4 泛型"></a>2.4 泛型</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<strong>泛型的本质是<u>参数化类型</u>，也就是说所操作的数据类型被指定为一个参数。</strong></p>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<p>泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</p>
<p>常用的通配符：<strong>T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h2 id="2-5-，equals-，hashCode"><a href="#2-5-，equals-，hashCode" class="headerlink" title="2.5 ==，equals() ，hashCode()"></a>2.5 ==，equals() ，hashCode()</h2><p>== 和 equals() 的区别:</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><strong>hashCode():</strong></p>
<p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<p>为什么重写 equals() 时必须重写 hashCode() 方法？</p>
<ul>
<li>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</li>
</ul>
<h2 id="2-6-java面向对象"><a href="#2-6-java面向对象" class="headerlink" title="2.6 java面向对象"></a>2.6 java面向对象</h2><h3 id="2-6-1-成员变量与局部变量的区别"><a href="#2-6-1-成员变量与局部变量的区别" class="headerlink" title="2.6.1 成员变量与局部变量的区别"></a>2.6.1 成员变量与局部变量的区别</h3><ol>
<li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而<strong>局部变量不能被访问控制修饰符及 <code>static</code> 所修饰</strong>；但是，<strong>成员变量和局部变量都能被 <code>final</code> 所修饰</strong>。</li>
<li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h3 id="2-6-2-构造方法"><a href="#2-6-2-构造方法" class="headerlink" title="2.6.2 构造方法"></a>2.6.2 构造方法</h3><p>构造方法主要作用是完成对类对象的初始化工作。</p>
<p>特点：</p>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="2-6-3-面向对象的三大特征"><a href="#2-6-3-面向对象的三大特征" class="headerlink" title="2.6.3 面向对象的三大特征"></a>2.6.3 面向对象的三大特征</h3><p><strong>封装</strong></p>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。，</p>
<p><strong>继承</strong></p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>多态</strong></p>
<p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p>多态的特点:</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
<li>父类方法加上static, private，final等关键字无法被重写</li>
</ul>
<h2 id="2-7-String-，StringBuffer，StringBuilder"><a href="#2-7-String-，StringBuffer，StringBuilder" class="headerlink" title="2.7 String ，StringBuffer，StringBuilder"></a>2.7 String ，StringBuffer，StringBuilder</h2><h3 id="string："><a href="#string：" class="headerlink" title="string："></a>string：</h3><p><strong>不可变性：</strong></p>
<p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="StringBuilder与StringBuffer："><a href="#StringBuilder与StringBuffer：" class="headerlink" title="StringBuilder与StringBuffer："></a><strong>StringBuilder<code>与</code>StringBuffer：</strong></h3><p>都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p><strong>线程安全性</strong>:</p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code>与<code>StringBuild </code>每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>单线程情况下：<code>StringBUild</code>性能最优</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h2 id="2-8-Object类常见方法总结"><a href="#2-8-Object类常见方法总结" class="headerlink" title="2.8 Object类常见方法总结"></a>2.8 Object类常见方法总结</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="2-9-深拷贝和浅拷贝及引用拷贝"><a href="#2-9-深拷贝和浅拷贝及引用拷贝" class="headerlink" title="2.9 深拷贝和浅拷贝及引用拷贝"></a>2.9 深拷贝和浅拷贝及引用拷贝</h2><ul>
<li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
</li>
<li><p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</li>
</ul>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>​        浅拷贝的示例代码如下，这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>
<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>测试 ：</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="keyword">new</span> Address(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>测试 ：</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="keyword">new</span> Address(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

</div></div>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<p><strong>通过对象序列化实现深拷贝</strong></p>
<p>将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。</p>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p>二者的引用是同一个对象，并没有创建出一个新的对象</p>
<p>因为是同一个对象的引用，所以两者改一个，另一个对象的值也随之改变</p>
<h2 id="2-11-反射"><a href="#2-11-反射" class="headerlink" title="2.11 反射"></a>2.11 反射</h2><h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3><p>​        JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>​        要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_202647.png" alt="从jvm层面理解反射"></p>
<p>参考链接：<a href="https://blog.csdn.net/sinat_38259539/article/details/71799078?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">Java基础之—反射（非常重要）</a></p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>​        像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>
<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="2-12-异常"><a href="#2-12-异常" class="headerlink" title="2.12 异常"></a>2.12 异常</h2><h3 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h3><p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_204101.png"></p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_204202.png"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="受检查异常"><a href="#受检查异常" class="headerlink" title="受检查异常"></a>受检查异常</h3><p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<h3 id="不受检查异常"><a href="#不受检查异常" class="headerlink" title="不受检查异常"></a><strong>不受检查异常</strong></h3><p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul>
<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h3 id="使用-try-with-resources-来代替try-catch-finally"><a href="#使用-try-with-resources-来代替try-catch-finally" class="headerlink" title="使用 try-with-resources 来代替try-catch-finally"></a>使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3><ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">             BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</div></div>



<h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h3><p>方法 1：通过 <code>Scanner</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="built_in">new</span> Scanner(<span class="keyword">System</span>.<span class="keyword">in</span>);</span><br><span class="line">String s  = <span class="keyword">input</span>.nextLine();</span><br><span class="line"><span class="keyword">input</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 <code>BufferedReader</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(System.<span class="keyword">in</span>));</span><br><span class="line"><span class="keyword">String</span> s = input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_210112.png" alt="按操作方式分类结构图"></p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_210138.png" alt="按操作对象分类结构图"></p>
<h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<hr>
<h1 id="重要知识点总结"><a href="#重要知识点总结" class="headerlink" title="重要知识点总结"></a>重要知识点总结</h1><h2 id="代理模式详解："><a href="#代理模式详解：" class="headerlink" title="代理模式详解："></a>代理模式详解：</h2><blockquote>
<p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能</strong>。</p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
</blockquote>
<h3 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h3><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码*），非常不灵活（*比如接口一旦新增加方法，目标对象和代理对象都要进行修改*）且麻烦(*需要对每个目标类都单独写一个代理类*)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>静态代理示例如下：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">before method <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">send message:java</span></span><br><span class="line"><span class="function">after method <span class="title">send</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>

</div></div>

<hr>
<h3 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h3><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p>
<p>动态代理实现方式有很多种，常见的有<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong></p>
<h4 id="2-1-JDK动态代理机制"><a href="#2-1-JDK动态代理机制" class="headerlink" title="2.1 JDK动态代理机制"></a>2.1 JDK动态代理机制</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心</strong></p>
<ul>
<li><strong><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</strong></li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<ul>
<li><strong>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<p><strong>JDK 动态代理类使用步骤</strong></p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<p><strong>JDK动态代理示例：</strong></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.定义一个 JDK 动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h4 id="2-2-CGLIB-动态代理机制"><a href="#2-2-CGLIB-动态代理机制" class="headerlink" title="2.2 CGLIB 动态代理机制"></a>2.2 CGLIB 动态代理机制</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们<strong>在运行时对字节码进行修改和动态生成</strong>。<strong>CGLIB 通过继承方式实现代理</strong>。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIB</a>， 例如 <strong>Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</strong></p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<ul>
<li><strong>需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="params"><span class="function">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>proxy</strong> :用于调用原始方法</li>
</ol>
<ul>
<li>通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。**</li>
</ul>
<p><strong>CGLIB 动态代理类使用步骤:</strong></p>
<ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<p><strong>CGLIB动态代理示例：</strong></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ol>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此<strong>不能代理声明为 final 类型的类和方法。</strong></li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%8E%E4%B9%88%E5%8A%9E">JavaGuide/java基础知识总结.md at main · Snailclimb/JavaGuide (github.com)</a></p>
<h2 id="反射详解"><a href="#反射详解" class="headerlink" title="反射详解"></a>反射详解</h2><p><strong>反射赋予了我们在运行时分析类以及执行类中方法的能力，    通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</strong></p>
<h3 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点:"></a>反射机制的优缺点:</h3><p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow">Java Reflection: Why is it so slow?</a></p>
<h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p>
<p><strong>1.知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<p><strong>2.通过 <code>Class.forName()</code>传入类的路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3.通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TargetObject o = <span class="keyword">new</span> TargetObject();</span><br><span class="line">Class alunbarClass2 = o.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = ClassLoader.loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行</p>

</div></div>

<h3 id="反射的一些基本操作"><a href="#反射的一些基本操作" class="headerlink" title="反射的一些基本操作"></a>反射的一些基本操作</h3><div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<p>1.创建一个我们要使用反射操作的类 <code>TargetObject</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用反射操作这个类的方法以及参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取TargetObject类的Class对象并且创建TargetObject类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; tagetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">        TargetObject targetObject = (TargetObject) tagetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取所有类中所有定义的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = tagetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method publicMethod = tagetClass.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Field field = tagetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method privateMethod = tagetClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s快速入门</title>
    <url>/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1、K8s快速入门"><a href="#1、K8s快速入门" class="headerlink" title="1、K8s快速入门"></a>1、K8s快速入门</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>kubernetes简称k8s。是用于自动部署，扩展和管理容器化应用程序的开源系统。</p>
<p>中文官网：<a href="https://kubernetes.io/Zh/">https://kubernetes.io/Zh/</a><br>中文社区：<a href="https://www.kubernetes.org.cn/">https://www.kubernetes.org.cn/</a><br>官方文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a><br>社区文档：<a href="https://docs.kubernetes.org.cn/">https://docs.kubernetes.org.cn/</a></p>
<p>部署方式的进化：</p>
<p> <img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/container_evolution.svg" alt="部署演进"> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503105948619.png" alt="image-20200503105948619"></p>
<p>![image-20200503110101659](G:/java_work/谷粒商城/Guli Mall/文档/开发阶段文档md/images/image-20200503110101659.png)</p>
<h3 id="2）架构"><a href="#2）架构" class="headerlink" title="2）架构"></a>2）架构</h3><h4 id="（1）整体主从方式"><a href="#（1）整体主从方式" class="headerlink" title="（1）整体主从方式"></a>（1）整体主从方式</h4><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110244940.png" alt="image-20200503110244940"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110350256.png" alt="image-20200503110350256"></p>
<h4 id="（2）master节点架构"><a href="#（2）master节点架构" class="headerlink" title="（2）master节点架构"></a>（2）master节点架构</h4><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%5Cimage-20200503110458806.png" alt="image-20200503110458806"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110631219.png" alt="image-20200503110631219"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110732773.png" alt="image-20200503110732773"></p>
<h4 id="（3）Node节点架构"><a href="#（3）Node节点架构" class="headerlink" title="（3）Node节点架构"></a>（3）Node节点架构</h4><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110804361.png" alt="image-20200503110804361"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503111032457.png" alt="image-20200503111032457"></p>
<h3 id="3）概念"><a href="#3）概念" class="headerlink" title="3）概念"></a>3）概念</h3><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112551188.png" alt="image-20200503112551188"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112627449.png" alt="image-20200503112627449"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112723747.png" alt="image-20200503112723747"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112810938.png" alt="image-20200503112810938"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503113055314.png" alt="image-20200503113055314"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503113619233.png" alt="image-20200503113619233"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503113701902.png" alt="image-20200503113701902"></p>
<h3 id="4）快速体验"><a href="#4）快速体验" class="headerlink" title="4）快速体验"></a>4）快速体验</h3><h4 id="（1）安装minikube"><a href="#（1）安装minikube" class="headerlink" title="（1）安装minikube"></a>（1）安装minikube</h4><p><a href="https://github.com/kubernetes/minikube/releases">https://github.com/kubernetes/minikube/releases</a><br>下载minikuber-windows-amd64.exe 改名为minikube.exe<br>打开virtualBox，打开cmd<br>运行<br>minikube start –vm-driver=virtualbox –registry-mirror=<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a><br>等待20分钟即可。</p>
<h4 id="（2）体验nginx部署升级"><a href="#（2）体验nginx部署升级" class="headerlink" title="（2）体验nginx部署升级"></a>（2）体验nginx部署升级</h4><ol>
<li><p>提交一个nginx deployment<br>kubectl apply -f <a href="https://k8s.io/examples/application/deployment.yaml">https://k8s.io/examples/application/deployment.yaml</a></p>
</li>
<li><p>升级 nginx deployment<br>kubectl apply -f <a href="https://k8s.io/examples/application/deployment-update.yaml">https://k8s.io/examples/application/deployment-update.yaml</a></p>
</li>
<li><p>扩容 nginx deployment</p>
</li>
</ol>
<h2 id="2、K8s集群安装"><a href="#2、K8s集群安装" class="headerlink" title="2、K8s集群安装"></a>2、K8s集群安装</h2><h3 id="1）kubeadm"><a href="#1）kubeadm" class="headerlink" title="1）kubeadm"></a>1）kubeadm</h3><p>kubeadm是官方社区推出的一个用于快速部署kuberneters集群的工具。<br>这个工具能通过两条指令完成一个kuberneters集群的部署</p>
<p>创建一个master节点</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ kuberneters <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

<p>将一个node节点加入到当前集群中</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ kubeadm join &lt;Master节点的<span class="built_in">IP</span>和端口&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2）前置要求"><a href="#2）前置要求" class="headerlink" title="2）前置要求"></a>2）前置要求</h3><p>一台或多台机器，操作系统Centos7.x-86_x64<br>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多<br>集群中所有的机器之间网络互通<br>可以访问外网，需要拉取镜像<br>禁止Swap分区</p>
<h3 id="3）部署步骤"><a href="#3）部署步骤" class="headerlink" title="3）部署步骤"></a>3）部署步骤</h3><ol>
<li>在所有的节点上安装Docker和kubeadm</li>
<li>不是Kubernetes Master</li>
<li>部署容器网络插件</li>
<li>部署Kubernetes Node，将节点加入Kubernetes集群中</li>
<li>部署DashBoard web页面，可视化查看Kubernetes资源</li>
</ol>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503144120720.png" alt="image-20200503144120720"></p>
<h3 id="4）环境准备"><a href="#4）环境准备" class="headerlink" title="4）环境准备"></a>4）环境准备</h3><h4 id="（1）准备工作"><a href="#（1）准备工作" class="headerlink" title="（1）准备工作"></a>（1）准备工作</h4><ul>
<li>我们可以使用vagrant快速创建三个虚拟机。虚拟机启动前先设置virtualbox的主机网络。现在全部统一为192.168.56.1，以后所有虚拟机都是56.x的ip地址。</li>
</ul>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503175351320.png" alt="image-20200503175351320"></p>
<ul>
<li>在全局设定中，找到一个空间比较大的磁盘用用来存放镜像。 </li>
</ul>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503180202640.png" alt="image-20200503180202640"></p>
<h4 id="（2）启动三个虚拟机"><a href="#（2）启动三个虚拟机" class="headerlink" title="（2）启动三个虚拟机"></a>（2）启动三个虚拟机</h4><ul>
<li>使用我们提供的vagrant文件，复制到非中文无空格目录下，运行vagrant up启动三个虚拟机。其实vagrant完全可以一键部署全部K8s集群<br><a href="https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster">https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster</a><br><a href="http://github.com/davidkbainbridge/k8s-playground">http://github.com/davidkbainbridge/k8s-playground</a></li>
</ul>
<p>下面是vagrantfile，使用它来创建三个虚拟机，分别为k8s-node1，k8s-node2和k8s-node3.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Vagrant.configure(&quot;2&quot;)</span> <span class="string">do</span> <span class="string">|config|</span></span><br><span class="line">   <span class="string">(1..3).each</span> <span class="string">do</span> <span class="string">|i|</span></span><br><span class="line">        <span class="string">config.vm.define</span> <span class="string">&quot;k8s-node#&#123;i&#125;&quot;</span> <span class="string">do</span> <span class="string">|node|</span></span><br><span class="line">            <span class="comment"># 设置虚拟机的Box</span></span><br><span class="line">            <span class="string">node.vm.box</span> <span class="string">=</span> <span class="string">&quot;centos/7&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置虚拟机的主机名</span></span><br><span class="line">            <span class="string">node.vm.hostname=&quot;k8s-node#&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置虚拟机的IP</span></span><br><span class="line">            <span class="string">node.vm.network</span> <span class="string">&quot;private_network&quot;</span><span class="string">,</span> <span class="attr">ip:</span> <span class="string">&quot;192.168.56.#&#123;99+i&#125;&quot;</span><span class="string">,</span> <span class="attr">netmask:</span> <span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置主机与虚拟机的共享目录</span></span><br><span class="line">            <span class="comment"># node.vm.synced_folder &quot;~/Documents/vagrant/share&quot;, &quot;/home/vagrant/share&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># VirtaulBox相关配置</span></span><br><span class="line">            <span class="string">node.vm.provider</span> <span class="string">&quot;virtualbox&quot;</span> <span class="string">do</span> <span class="string">|v|</span></span><br><span class="line">                <span class="comment"># 设置虚拟机的名称</span></span><br><span class="line">                <span class="string">v.name</span> <span class="string">=</span> <span class="string">&quot;k8s-node#&#123;i&#125;&quot;</span></span><br><span class="line">                <span class="comment"># 设置虚拟机的内存大小</span></span><br><span class="line">                <span class="string">v.memory</span> <span class="string">=</span> <span class="number">4096</span></span><br><span class="line">                <span class="comment"># 设置虚拟机的CPU个数</span></span><br><span class="line">                <span class="string">v.cpus</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line">            <span class="string">end</span></span><br><span class="line">        <span class="string">end</span></span><br><span class="line">   <span class="string">end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li>进入到三个虚拟机，开启root的密码访问权限</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Vagrant ssh xxx进入到系统后</span><br><span class="line"></span><br><span class="line">su root 密码为vagrant</span><br><span class="line"></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">PermitRootLogin yes </span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"></span><br><span class="line">所有的虚拟机设为4核4G</span><br></pre></td></tr></table></figure>





<p>关于在”网络地址转换”的连接方式下，三个节点的eth0，IP地址相同的问题。</p>
<p><strong>问题描述：</strong>查看k8s-node1的路由表：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[root@k8s-node1 ~]</span># ip route show</span><br><span class="line">default via <span class="number">10</span>.<span class="number">0</span>.<span class="number">2</span>.<span class="number">2</span> dev eth0 proto dhcp metric <span class="number">100</span> </span><br><span class="line"><span class="number">10.0.2.0</span>/<span class="number">24</span> dev eth0 proto kernel scope link src <span class="number">10</span>.<span class="number">0</span>.<span class="number">2</span>.<span class="number">15</span> metric <span class="number">100</span> </span><br><span class="line"><span class="number">192.168.56.0</span>/<span class="number">24</span> dev eth1 proto kernel scope link src <span class="number">192</span>.<span class="number">168</span>.<span class="number">56</span>.<span class="number">100</span> metric <span class="number">101</span> </span><br><span class="line"><span class="string">[root@k8s-node1 ~</span></span><br></pre></td></tr></table></figure>

<p>能够看到路由表中记录的是，通过端口eth0进行数据包的收发。</p>
<p>分别查看k8s-node1，k8s-node2和k8s-node3的eth0所绑定的IP地址，发现它们都是相同的，全都是10.0.2.15，这些地址是供kubernetes集群通信用的，区别于eth1上的IP地址，是通远程管理使用的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# ip addr</span><br><span class="line">...</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0</span><br><span class="line">       valid_lft 84418sec preferred_lft 84418sec</span><br><span class="line">    inet6 fe80::5054:ff:fe8a:fee6/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:a3:ca:c0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.56.100/24 brd 192.168.56.255 scope global noprefixroute eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::a00:27ff:fea3:cac0/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p><strong>原因分析：</strong>这是因为它们使用是端口转发规则，使用同一个地址，通过不同的端口来区分。但是这种端口转发规则在以后的使用中会产生很多不必要的问题，所以需要修改为NAT网络类型。</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503184536343.png" alt="image-20200503184536343"></p>
<p><strong>解决方法：</strong></p>
<ul>
<li>选择三个节点，然后执行“管理”-&gt;”全局设定”-&gt;“网络”，添加一个NAT网络。</li>
</ul>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503184919936.png"></p>
<ul>
<li>分别修改每台设备的网络类型，并刷新重新生成MAC地址。</li>
</ul>
<img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503185344246.png" style="zoom: 200%;">



<ul>
<li>再次查看三个节点的IP</li>
</ul>
<img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503190101156.png" alt="image-20200503190101156" style="zoom:50%;">





<h4 id="（3）设置Linux环境（三个节点都执行）"><a href="#（3）设置Linux环境（三个节点都执行）" class="headerlink" title="（3）设置Linux环境（三个节点都执行）"></a>（3）设置Linux环境（三个节点都执行）</h4><ul>
<li>关闭防火墙</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭Linux</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> <span class="regexp">/etc/</span>selinux/config</span><br><span class="line">setenforce <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关闭swap </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a #临时关闭</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab #永久关闭</span><br><span class="line">free -g #验证，swap必须为0</span><br></pre></td></tr></table></figure>

<ul>
<li>添加主机名与IP对应关系：</li>
</ul>
<p>查看主机名：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hostname</span></span><br></pre></td></tr></table></figure>

<p>如果主机名不正确，可以通过“hostnamectl set-hostname &lt;newhostname&gt; :指定新的hostname”命令来进行修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line">10.0.2.15 k8s-node1</span><br><span class="line">10.0.2.4 k8s-node2</span><br><span class="line">10.0.2.5 k8s-node3</span><br></pre></td></tr></table></figure>



<p>将桥接的IPV4流量传递到iptables的链：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line"></span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>应用规则：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sysctl <span class="comment">--system</span></span><br></pre></td></tr></table></figure>





<p>疑难问题：遇见提示是只读的文件系统，运行如下命令</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mount</span> -o remount rw /</span><br></pre></td></tr></table></figure>

<ul>
<li>date 查看时间（可选）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install ntpupdate</span><br><span class="line"></span><br><span class="line">ntpupdate time.window.com #同步最新时间</span><br></pre></td></tr></table></figure>



<h3 id="5）所有节点安装docker、kubeadm、kubelet、kubectl"><a href="#5）所有节点安装docker、kubeadm、kubelet、kubectl" class="headerlink" title="5）所有节点安装docker、kubeadm、kubelet、kubectl"></a>5）所有节点安装docker、kubeadm、kubelet、kubectl</h3><p>Kubenetes默认CRI（容器运行时）为Docker，因此先安装Docker。</p>
<h4 id="（1）安装Docker"><a href="#（1）安装Docker" class="headerlink" title="（1）安装Docker"></a>（1）安装Docker</h4><p>1、卸载之前的docker</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker <span class="string">\</span></span><br><span class="line">                  docker-client <span class="string">\</span></span><br><span class="line">                  docker-client-latest <span class="string">\</span></span><br><span class="line">                  docker-common <span class="string">\</span></span><br><span class="line">                  docker-latest <span class="string">\</span></span><br><span class="line">                  docker-latest-logrotate <span class="string">\</span></span><br><span class="line">                  docker-logrotate <span class="string">\</span></span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>2、安装Docker  -CE</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line"><span class="bash">    --add-repo \</span></span><br><span class="line"><span class="bash">    https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum -y install docker-ce docker-ce-cli containerd.io</span>   </span><br></pre></td></tr></table></figure>

<p>3、配置镜像加速</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://ke9h1pt4.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>4、启动Docker &amp;&amp; 设置docker开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>



<p>基础环境准备好，可以给三个虚拟机备份一下；</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503192940651.png" alt="image-20200503192940651"></p>
<h4 id="（2）添加阿里与Yum源"><a href="#（2）添加阿里与Yum源" class="headerlink" title="（2）添加阿里与Yum源"></a>（2）添加阿里与Yum源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>更多详情见： <a href="https://developer.aliyun.com/mirror/kubernetes">https://developer.aliyun.com/mirror/kubernetes</a> </p>
<h4 id="（3）安装kubeadm，kubelet和kubectl"><a href="#（3）安装kubeadm，kubelet和kubectl" class="headerlink" title="（3）安装kubeadm，kubelet和kubectl"></a>（3）安装kubeadm，kubelet和kubectl</h4><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">yum list<span class="string">|grep kube</span></span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-1.17.3 kubeadm-1.17.3 kubectl-1.17.3</span><br></pre></td></tr></table></figure>

<p>开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>



<p>查看kubelet的状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl status kubelet</span></span><br></pre></td></tr></table></figure>

<p>查看kubelet版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node2 ~]# kubelet --version</span><br><span class="line">Kubernetes v1.17.3</span><br></pre></td></tr></table></figure>



<h3 id="6）部署k8s-master"><a href="#6）部署k8s-master" class="headerlink" title="6）部署k8s-master"></a>6）部署k8s-master</h3><h4 id="（1）master节点初始化"><a href="#（1）master节点初始化" class="headerlink" title="（1）master节点初始化"></a>（1）master节点初始化</h4><p>在Master节点上，创建并执行master_images.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">images=(</span><br><span class="line">	kube-apiserver:v1.17.3</span><br><span class="line">    kube-proxy:v1.17.3</span><br><span class="line">	kube-controller-manager:v1.17.3</span><br><span class="line">	kube-scheduler:v1.17.3</span><br><span class="line">	coredns:1.6.5</span><br><span class="line">	etcd:3.4.3-0</span><br><span class="line">    pause:3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line"><span class="comment">#   docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName  k8s.gcr.io/$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>




<p>初始化kubeadm</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubeadm init \</span></span><br><span class="line"><span class="bash">--apiserver-advertise-address=10.0.2.15 \</span></span><br><span class="line"><span class="bash">--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \</span></span><br><span class="line"><span class="bash">--kubernetes-version   v1.17.3 \</span></span><br><span class="line"><span class="bash">--service-cidr=10.96.0.0/16  \</span></span><br><span class="line"><span class="bash">--pod-network-cidr=10.244.0.0/16</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>–apiserver-advertise-address=10.0.2.21 ：这里的IP地址是master主机的地址，为上面的eth0网卡的地址；</li>
<li></li>
</ul>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 opt]# kubeadm init \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --apiserver-advertise-address=10.0.2.15 \</span></span><br><span class="line"><span class="bash">&gt; --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \</span></span><br><span class="line"><span class="bash">&gt; --kubernetes-version   v1.17.3 \</span></span><br><span class="line"><span class="bash">&gt; --service-cidr=10.96.0.0/16  \</span></span><br><span class="line"><span class="bash">&gt; --pod-network-cidr=10.244.0.0/16</span></span><br><span class="line">W0503 14:07:12.594252   10124 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]</span><br><span class="line">[init] Using Kubernetes version: v1.17.3</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-node1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.0.2.15]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [k8s-node1 localhost] and IPs [10.0.2.15 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [k8s-node1 localhost] and IPs [10.0.2.15 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">W0503 14:07:30.908642   10124 manifests.go:225] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">W0503 14:07:30.911330   10124 manifests.go:225] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 22.506521 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.18&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node k8s-node1 as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;</span><br><span class="line">[mark-control-plane] Marking the node k8s-node1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: sg47f3.4asffoi6ijb8ljhq</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"><span class="meta">#</span><span class="bash">表示kubernetes已经初始化成功了</span></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.0.2.15:6443 --token sg47f3.4asffoi6ijb8ljhq \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:81fccdd29970cbc1b7dc7f171ac0234d53825bdf9b05428fc9e6767436991bfb </span><br><span class="line">[root@k8s-node1 opt]# </span><br></pre></td></tr></table></figure>





<p>由于默认拉取镜像地址k8s.cr.io国内无法访问，这里指定阿里云仓库地址。可以手动按照我们的images.sh先拉取镜像。</p>
<p>地址变为：registry.aliyuncs.com/googole_containers也可以。<br>科普：无类别域间路由（Classless Inter-Domain Routing 、CIDR）是一个用于给用户分配IP地址以及在互联网上有效第路由IP数据包的对IP地址进行归类的方法。<br>拉取可能失败，需要下载镜像。</p>
<p>运行完成提前复制：加入集群的令牌。</p>
<h4 id="（2）测试Kubectl（主节点执行）"><a href="#（2）测试Kubectl（主节点执行）" class="headerlink" title="（2）测试Kubectl（主节点执行）"></a>（2）测试Kubectl（主节点执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>详细部署文档：<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes <span class="comment">#获取所有节点</span></span></span><br></pre></td></tr></table></figure>

<p>目前Master状态为notready。等待网络加入完成即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> journalctl -u kubelet <span class="comment">#查看kubelet日志</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 10.0.2.15:6443 --token sg47f3.4asffoi6ijb8ljhq \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:81fccdd29970cbc1b7dc7f171ac0234d53825bdf9b05428fc9e6767436991bfb </span><br></pre></td></tr></table></figure>

<h3 id="7）安装POD网络插件（CNI）"><a href="#7）安装POD网络插件（CNI）" class="headerlink" title="7）安装POD网络插件（CNI）"></a>7）安装POD网络插件（CNI）</h3><p>在master节点上执行按照POD网络插件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">kubectl apply -f \</span><br><span class="line">https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/coreos/</span>flanne<span class="regexp">/master/</span>Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>以上地址可能被墙，可以直接获取本地已经下载的flannel.yml运行即可，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl apply -f  kube-flannel.yml    </span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm created</span><br><span class="line">daemonset.apps/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.apps/kube-flannel-ds-s390x created</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>

<p>同时flannel.yml中指定的images访问不到可以去docker hub找一个wget yml地址<br>vi 修改yml 所有amd64的地址修改了即可<br>等待大约3分钟<br>kubectl get pods -n kube-system 查看指定名称空间的pods<br>kubectl get pods -all-namespace 查看所有名称空间的pods</p>
<p>$ ip link set cni0 down 如果网络出现问题，关闭cni0，重启虚拟机继续测试<br>执行watch kubectl get pod -n kube-system -o wide 监控pod进度<br>等待3-10分钟，完全都是running以后继续</p>
<p>查看命名空间：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@k8s-node1 k8s</span>]<span class="meta"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line"><span class="literal">default</span>           Active   <span class="number">30</span>m</span><br><span class="line">kube-node-lease   Active   <span class="number">30</span>m</span><br><span class="line">kube-<span class="keyword">public</span>       Active   <span class="number">30</span>m</span><br><span class="line">kube-system       Active   <span class="number">30</span>m</span><br><span class="line">[<span class="meta">root@k8s-node1 k8s</span>]<span class="meta">#</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get pods --all-namespaces       </span><br><span class="line">NAMESPACE     NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-546565776c-9sbmk            0/1     Pending   0          31m</span><br><span class="line">kube-system   coredns-546565776c-t68mr            0/1     Pending   0          31m</span><br><span class="line">kube-system   etcd-k8s-node1                      1/1     Running   0          31m</span><br><span class="line">kube-system   kube-apiserver-k8s-node1            1/1     Running   0          31m</span><br><span class="line">kube-system   kube-controller-manager-k8s-node1   1/1     Running   0          31m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-6xwth         1/1     Running   0          2m50s</span><br><span class="line">kube-system   kube-proxy-sz2vz                    1/1     Running   0          31m</span><br><span class="line">kube-system   kube-scheduler-k8s-node1            1/1     Running   0          31m</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p> 查看master上的节点信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get nodes</span><br><span class="line">NAME        STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-node1   Ready    master   34m   v1.17.3   #status为ready才能够执行下面的命令</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>

<p>最后再次执行，并且分别在“k8s-node2”和“k8s-node3”上也执行这里命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 10.0.2.15:6443 --token sg47f3.4asffoi6ijb8ljhq \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:81fccdd29970cbc1b7dc7f171ac0234d53825bdf9b05428fc9e6767436991bfb </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 opt]# kubectl get nodes;</span><br><span class="line">NAME        STATUS     ROLES    AGE   VERSION</span><br><span class="line">k8s-node1   Ready      master   47m   v1.17.3</span><br><span class="line">k8s-node2   NotReady   &lt;none&gt;   75s   v1.17.3</span><br><span class="line">k8s-node3   NotReady   &lt;none&gt;   76s   v1.17.3</span><br><span class="line">[root@k8s-node1 opt]# </span><br></pre></td></tr></table></figure>



<p>监控pod进度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch kubectl get pod -n kube-system -o wide</span><br></pre></td></tr></table></figure>

<p>等到所有的status都变为running状态后，再次查看节点信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]#  kubectl get nodes;                         </span><br><span class="line">NAME        STATUS   ROLES    AGE     VERSION</span><br><span class="line">k8s-node1   Ready    master   3h50m   v1.17.3</span><br><span class="line">k8s-node2   Ready    &lt;none&gt;   3h3m    v1.17.3</span><br><span class="line">k8s-node3   Ready    &lt;none&gt;   3h3m    v1.17.3</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>





<h3 id="8）加入kubenetes的Node节点"><a href="#8）加入kubenetes的Node节点" class="headerlink" title="8）加入kubenetes的Node节点"></a>8）加入kubenetes的Node节点</h3><p>在node节点中执行，向集群中添加新的节点，执行在kubeadm init 输出的kubeadm join命令；<br>确保node节点成功：<br>token过期怎么办<br>kubeadm token create –print-join-command</p>
<h3 id="9）入门操作kubernetes集群"><a href="#9）入门操作kubernetes集群" class="headerlink" title="9）入门操作kubernetes集群"></a>9）入门操作kubernetes集群</h3><p>1、在主节点上部署一个tomcat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8</span><br></pre></td></tr></table></figure>



<p>获取所有的资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS              RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-cfd8g   0/1     ContainerCreating   0          41s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   70m</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   0/1     1            0           41s</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   1         1         0       41s</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>



<p>kubectl get pods -o wide 可以获取到tomcat部署信息，能够看到它被部署到了k8s-node2上了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get all -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE    IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/tomcat6-7b84fb5fdc-cfd8g   1/1     Running   0          114s   10.244.2.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   71m   &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE    CONTAINERS   IMAGES               SELECTOR</span><br><span class="line">deployment.apps/tomcat6   1/1     1            1           114s   tomcat       tomcat:6.0.53-jre8   app=tomcat6</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE    CONTAINERS   IMAGES               SELECTOR</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   1         1         1       114s   tomcat       tomcat:6.0.53-jre8   app=tomcat6,pod-template-hash=7b84fb5fdc</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>



<p>查看node2节点上，下载了哪些镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node2 opt]# docker images</span><br><span class="line">REPOSITORY                                                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy   v1.17.3             0d40868643c6        2 weeks ago         117MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause        3.2                 80d28bedfe5d        2 months ago        683kB</span><br><span class="line">quay.io/coreos/flannel                                           v0.11.0-amd64       ff281650a721        15 months ago       52.6MB</span><br><span class="line">tomcat                                                           6.0.53-jre8         49ab0583115a        2 years ago         290MB</span><br><span class="line">[root@k8s-node2 opt]# </span><br></pre></td></tr></table></figure>



<p>查看Node2节点上，正在运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node2 opt]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                            COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">9194cc4f0b7a        tomcat                                                           &quot;catalina.sh run&quot;        2 minutes ago       Up 2 minutes                            k8s_tomcat_tomcat6-7b84fb5fdc-cfd8g_default_0c9ebba2-992d-4c0e-99ef-3c4c3294bc59_0</span><br><span class="line">f44af0c7c345        registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2    &quot;/pause&quot;                 3 minutes ago       Up 3 minutes                            k8s_POD_tomcat6-7b84fb5fdc-cfd8g_default_0c9ebba2-992d-4c0e-99ef-3c4c3294bc59_0</span><br><span class="line">ef74c90491e4        ff281650a721                                                     &quot;/opt/bin/flanneld -…&quot;   20 minutes ago      Up 20 minutes                           k8s_kube-flannel_kube-flannel-ds-amd64-5xs5j_kube-system_11a94346-316d-470b-9668-c15ce183abec_0</span><br><span class="line">c8a524e5a193        registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy   &quot;/usr/local/bin/kube…&quot;   25 minutes ago      Up 25 minutes                           k8s_kube-proxy_kube-proxy-mvlnk_kube-system_519de79a-e8d8-4b1c-a74e-94634cebabce_0</span><br><span class="line">4590685c519a        registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2    &quot;/pause&quot;                 26 minutes ago      Up 26 minutes                           k8s_POD_kube-flannel-ds-amd64-5xs5j_kube-system_11a94346-316d-470b-9668-c15ce183abec_0</span><br><span class="line">54e00af5cde4        registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2    &quot;/pause&quot;                 26 minutes ago      Up 26 minutes                           k8s_POD_kube-proxy-mvlnk_kube-system_519de79a-e8d8-4b1c-a74e-94634cebabce_0</span><br><span class="line">[root@k8s-node2 opt]# </span><br></pre></td></tr></table></figure>



<p>在node1上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get pods</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">tomcat6-7b84fb5fdc-cfd8g   1/1     Running   0          5m35s</span><br><span class="line"></span><br><span class="line">[root@k8s-node1 k8s]# kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE     NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">default       tomcat6-7b84fb5fdc-cfd8g            1/1     Running   0          163m</span><br><span class="line">kube-system   coredns-546565776c-9sbmk            1/1     Running   0          3h52m</span><br><span class="line">kube-system   coredns-546565776c-t68mr            1/1     Running   0          3h52m</span><br><span class="line">kube-system   etcd-k8s-node1                      1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-apiserver-k8s-node1            1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-controller-manager-k8s-node1   1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-5xs5j         1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-6xwth         1/1     Running   0          3h24m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-fvnvx         1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-proxy-7tkvl                    1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-proxy-mvlnk                    1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-proxy-sz2vz                    1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-scheduler-k8s-node1            1/1     Running   0          3h52m</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<p>从前面看到tomcat部署在Node2上，现在模拟因为各种原因宕机的情况，将node2关闭电源，观察情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get nodes</span><br><span class="line">NAME        STATUS     ROLES    AGE     VERSION</span><br><span class="line">k8s-node1   Ready      master   4h4m    v1.17.3</span><br><span class="line">k8s-node2   NotReady   &lt;none&gt;   3h18m   v1.17.3</span><br><span class="line">k8s-node3   Ready      &lt;none&gt;   3h18m   v1.17.3</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE    IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">tomcat6-7b84fb5fdc-cfd8g   1/1     Running   0          177m   10.244.2.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504104925236.png" alt="image-20200504104925236"></p>
<p>2、暴露nginx访问</p>
<p>在master上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment tomcat6 --port=80 --target-port=8080 --type=NodePort </span><br></pre></td></tr></table></figure>

<p>pod的80映射容器的8080；server会带来pod的80</p>
<p>查看服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        12h</span><br><span class="line">tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   49s</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get svc -o wide</span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE     SELECTOR</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        12h     &lt;none&gt;</span><br><span class="line">tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   3m30s   app=tomcat6</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p> <a href="http://192.168.56.100:30526/">http://192.168.56.100:30526/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%5Cimage-20200504105723874.png" alt="image-20200504105723874"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-qt5jm   1/1     Running   0          13m</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        12h</span><br><span class="line">service/tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   9m50s</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   1/1     1            1           11h</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   1         1         1       11h</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>



<p>3、动态扩容测试</p>
<p>kubectl get deployment</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get deployment</span><br><span class="line">NAME      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">tomcat6   2/2     2            2           11h</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>


<p>应用升级： kubectl set image (–help查看帮助)<br>扩容：kubectl scale –replicas=3 deployment tomcat6</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl scale --replicas=3 deployment tomcat6</span><br><span class="line">deployment.apps/tomcat6 scaled</span><br><span class="line">[root@k8s-node1 ~]# </span><br><span class="line"></span><br><span class="line">[root@k8s-node1 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">tomcat6-7b84fb5fdc-hdgmc   1/1     Running   0          61s   10.244.2.5   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">tomcat6-7b84fb5fdc-qt5jm   1/1     Running   0          19m   10.244.1.2   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">tomcat6-7b84fb5fdc-vlrh6   1/1     Running   0          61s   10.244.2.4   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@k8s-node1 ~]# kubectl get svc -o wide    </span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        13h   &lt;none&gt;</span><br><span class="line">tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   16m   app=tomcat6</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>





<p>扩容了多份，所有无论访问哪个node的指定端口，都可以访问到tomcat6</p>
<p> <a href="http://192.168.56.101:30526/">http://192.168.56.101:30526/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504111008668.png" alt="image-20200504111008668"></p>
<p> <a href="http://192.168.56.102:30526/">http://192.168.56.102:30526/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504111028496.png" alt="image-20200504111028496"></p>
<p>缩容：kubectl scale –replicas=2 deployment tomcat6</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@k8s</span><span class="operator">-</span>node1 <span class="operator">~</span>]#  kubectl scale <span class="comment">--replicas=2 deployment tomcat6</span></span><br><span class="line">deployment.apps<span class="operator">/</span>tomcat6 scaled</span><br><span class="line">[root<span class="variable">@k8s</span><span class="operator">-</span>node1 <span class="operator">~</span>]# kubectl <span class="keyword">get</span> pods <span class="operator">-</span>o wide                       </span><br><span class="line">NAME                       READY   STATUS        RESTARTS   AGE     IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">tomcat6<span class="number">-7</span>b84fb5fdc<span class="operator">-</span>hdgmc   <span class="number">0</span><span class="operator">/</span><span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m47s   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>       k8s<span class="operator">-</span>node2   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>           <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span></span><br><span class="line">tomcat6<span class="number">-7</span>b84fb5fdc<span class="operator">-</span>qt5jm   <span class="number">1</span><span class="operator">/</span><span class="number">1</span>     <span class="keyword">Running</span>       <span class="number">0</span>          <span class="number">22</span>m     <span class="number">10.244</span><span class="number">.1</span><span class="number">.2</span>   k8s<span class="operator">-</span>node3   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>           <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span></span><br><span class="line">tomcat6<span class="number">-7</span>b84fb5fdc<span class="operator">-</span>vlrh6   <span class="number">1</span><span class="operator">/</span><span class="number">1</span>     <span class="keyword">Running</span>       <span class="number">0</span>          <span class="number">4</span>m47s   <span class="number">10.244</span><span class="number">.2</span><span class="number">.4</span>   k8s<span class="operator">-</span>node2   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>           <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span></span><br><span class="line">[root<span class="variable">@k8s</span><span class="operator">-</span>node1 <span class="operator">~</span>]# </span><br></pre></td></tr></table></figure>





<p>4、以上操作的yaml获取<br>参照k8s细节</p>
<p>5、删除<br>kubectl get all</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有资源</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-qt5jm   1/1     Running   0          26m</span><br><span class="line">pod/tomcat6-7b84fb5fdc-vlrh6   1/1     Running   0          8m16s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        13h</span><br><span class="line">service/tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   22m</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   2/2     2            2           11h</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   2         2         2       11h</span><br><span class="line">[root@k8s-node1 ~]#</span><br><span class="line"><span class="meta">#</span><span class="bash">删除deployment.apps/tomcat6</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl delete  deployment.apps/tomcat6 </span><br><span class="line">deployment.apps &quot;tomcat6&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看剩余的资源</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl get all   </span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        13h</span><br><span class="line">service/tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   30m</span><br><span class="line">[root@k8s-node1 ~]# </span><br><span class="line">[root@k8s-node1 ~]#</span><br><span class="line"><span class="meta">#</span><span class="bash">删除service/tomcat6</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl delete service/tomcat6  </span><br><span class="line">service &quot;tomcat6&quot; deleted</span><br><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   13h</span><br><span class="line">[root@k8s-node1 ~]#</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>kubectl delete deploye/nginx<br>kubectl delete service/nginx-service</p>
<h2 id="3、K8s细节"><a href="#3、K8s细节" class="headerlink" title="3、K8s细节"></a>3、K8s细节</h2><h3 id="1、kubectl文档"><a href="#1、kubectl文档" class="headerlink" title="1、kubectl文档"></a>1、kubectl文档</h3><p>​    <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a></p>
<h3 id="2、资源类型"><a href="#2、资源类型" class="headerlink" title="2、资源类型"></a>2、资源类型</h3><p>   <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/#%e8%b5%84%e6%ba%90%e7%b1%bb%e5%9e%8b">https://kubernetes.io/zh/docs/reference/kubectl/overview/#%e8%b5%84%e6%ba%90%e7%b1%bb%e5%9e%8b</a></p>
<h3 id="3、格式化输出"><a href="#3、格式化输出" class="headerlink" title="3、格式化输出"></a>3、格式化输出</h3><p> <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a> </p>
<blockquote>
<p>所有 <code>kubectl</code> 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 <code>-o</code> 或 <code>--output</code> 参数添加到受支持的 <code>kubectl</code> 命令中。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">kubectl [<span class="built_in">command</span>] [TYPE] [NAME] -o=&lt;output_format&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据 <code>kubectl</code> 操作，支持以下输出格式：</p>
<table>
<thead>
<tr>
<th align="left">Output format</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o custom-columns=</code></td>
<td align="left">使用逗号分隔的<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/#custom-columns">自定义列</a>列表打印表。</td>
</tr>
<tr>
<td align="left"><code>-o custom-columns-file=</code></td>
<td align="left">使用 `` 文件中的<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/#custom-columns">自定义列</a>模板打印表。</td>
</tr>
<tr>
<td align="left"><code>-o json</code></td>
<td align="left">输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td align="left">`-o jsonpath=</td>
<td align="left">打印 <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/">jsonpath</a> 表达式定义的字段</td>
</tr>
<tr>
<td align="left"><code>-o jsonpath-file=</code></td>
<td align="left">打印 `` 文件中 <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/">jsonpath</a> 表达式定义的字段。</td>
</tr>
<tr>
<td align="left"><code>-o name</code></td>
<td align="left">仅打印资源名称而不打印任何其他内容。</td>
</tr>
<tr>
<td align="left"><code>-o wide</code></td>
<td align="left">以纯文本格式输出，包含任何附加信息。对于 pod 包含节点名。</td>
</tr>
<tr>
<td align="left"><code>-o yaml</code></td>
<td align="left">输出 YAML 格式的 API 对象。</td>
</tr>
</tbody></table>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>在此示例中，以下命令将单个 pod 的详细信息输出为 YAML 格式的对象：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">kubectl get pod web-pod-13je7 -o yaml</span></span><br></pre></td></tr></table></figure>

<p>请记住：有关每个命令支持哪种输出格式的详细信息，请参阅 <a href="https://kubernetes.io/docs/user-guide/kubectl/">kubectl</a> 参考文档。</p>
</blockquote>
<p>–dry-run：</p>
<blockquote>
<p>–dry-run=’none’: Must be “none”, “server”, or “client”. If client strategy, only print the object that would be</p>
<p>sent, without sending it. If server strategy, submit server-side request without persisting the resource.</p>
<p>值必须为none，server或client。如果是客户端策略，则只打印该发送对象，但不发送它。如果服务器策略，提交服务器端请求而不持久化资源。</p>
<p>也就是说，通过–dry-run选项，并不会真正的执行这条命令。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@k8s-node1</span> <span class="string">~</span>]<span class="comment"># kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 --dry-run -o yaml</span></span><br><span class="line"><span class="string">W0504</span> <span class="number">03</span><span class="string">:39:08.389369</span>    <span class="number">8107 </span><span class="string">helpers.go:535]</span> <span class="string">--dry-run</span> <span class="string">is</span> <span class="string">deprecated</span> <span class="string">and</span> <span class="string">can</span> <span class="string">be</span> <span class="string">replaced</span> <span class="string">with</span> <span class="string">--dry-run=client.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br><span class="line">[<span class="string">root@k8s-node1</span> <span class="string">~</span>]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>实际上我们也可以将这个yaml输出到文件，然后使用kubectl apply -f来应用它</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输出到tomcat6.yaml</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 --dry-run -o yaml &gt;tomcat6.yaml</span><br><span class="line">W0504 03:46:18.180366   11151 helpers.go:535] --dry-run is deprecated and can be replaced with --dry-run=client.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改副本数为3</span></span><br><span class="line">[root@k8s-node1 ~]# cat tomcat6.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    app: tomcat6</span><br><span class="line">  name: tomcat6</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3     #修改副本数为3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: tomcat6</span><br><span class="line">  strategy: &#123;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: tomcat6</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: tomcat:6.0.53-jre8</span><br><span class="line">        name: tomcat</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">status: &#123;&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">应用tomcat6.yaml</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl apply -f tomcat6.yaml </span><br><span class="line">deployment.apps/tomcat6 created</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p>查看pods：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get pods  </span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">tomcat6-7b84fb5fdc-5jh6t   1/1     Running   0          8s</span><br><span class="line">tomcat6-7b84fb5fdc-8lhwv   1/1     Running   0          8s</span><br><span class="line">tomcat6-7b84fb5fdc-j4qmh   1/1     Running   0          8s</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>



<p>查看某个pod的具体信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get pods tomcat6-7b84fb5fdc-5jh6t  -o yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">tomcat6-7b84fb5fdc-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">pod-template-hash:</span> <span class="string">7b84fb5fdc</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:generateName:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> &#123;&#125;</span><br><span class="line">          <span class="attr">f:app:</span> &#123;&#125;</span><br><span class="line">          <span class="attr">f:pod-template-hash:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:ownerReferences:</span></span><br><span class="line">          <span class="string">.:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;uid&quot;:&quot;292bfe3b-dd63-442e-95ce-c796ab5bdcc1&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:apiVersion:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:blockOwnerDeletion:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:controller:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:kind:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:name:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:uid:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:containers:</span></span><br><span class="line">          <span class="string">k:&#123;&quot;name&quot;:&quot;tomcat&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:image:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:imagePullPolicy:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:name:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:resources:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:terminationMessagePath:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:terminationMessagePolicy:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:dnsPolicy:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:enableServiceLinks:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:restartPolicy:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:schedulerName:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:securityContext:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:terminationGracePeriodSeconds:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:status:</span></span><br><span class="line">        <span class="attr">f:conditions:</span></span><br><span class="line">          <span class="string">k:&#123;&quot;type&quot;:&quot;ContainersReady&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastProbeTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:status:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:type:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;type&quot;:&quot;Initialized&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastProbeTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:status:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:type:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;type&quot;:&quot;Ready&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastProbeTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:status:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:type:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:containerStatuses:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:hostIP:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:phase:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:podIP:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:podIPs:</span></span><br><span class="line">          <span class="string">.:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;ip&quot;:&quot;10.244.2.7&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:ip:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:startTime:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubelet</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6-7b84fb5fdc-5jh6t</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat6-7b84fb5fdc</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">292bfe3b-dd63-442e-95ce-c796ab5bdcc1</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;46229&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/tomcat6-7b84fb5fdc-5jh6t</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">2f661212-3b03-47e4-bcb8-79782d5c7578</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">    <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">default-token-bxqtw</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">enableServiceLinks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">k8s-node2</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">  <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">serviceAccount:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-token-bxqtw</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">default-token-bxqtw</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Initialized</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ContainersReady</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">PodScheduled</span></span><br><span class="line">  <span class="attr">containerStatuses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerID:</span> <span class="string">docker://18eb0798384ea44ff68712cda9be94b6fb96265206c554a15cee28c288879304</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">    <span class="attr">imageID:</span> <span class="string">docker-pullable://tomcat@sha256:8c643303012290f89c6f6852fa133b7c36ea6fbb8eb8b8c9588a432beb24dc5d</span></span><br><span class="line">    <span class="attr">lastState:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restartCount:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">started:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">state:</span></span><br><span class="line">      <span class="attr">running:</span></span><br><span class="line">        <span class="attr">startedAt:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">  <span class="attr">hostIP:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.4</span></span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Running</span></span><br><span class="line">  <span class="attr">podIP:</span> <span class="number">10.244</span><span class="number">.2</span><span class="number">.7</span></span><br><span class="line">  <span class="attr">podIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.244</span><span class="number">.2</span><span class="number">.7</span></span><br><span class="line">  <span class="attr">qosClass:</span> <span class="string">BestEffort</span></span><br><span class="line">  <span class="attr">startTime:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br></pre></td></tr></table></figure>







<h3 id="命令参考"><a href="#命令参考" class="headerlink" title="命令参考"></a>命令参考</h3><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504115823058.png" alt="image-20200504115823058"></p>
<h3 id="service的意义"><a href="#service的意义" class="headerlink" title="service的意义"></a>service的意义</h3><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504120856830.png" alt="image-20200504120856830"></p>
<p>前面我们通过命令行的方式，部署和暴露了tomcat，实际上也可以通过yaml的方式来完成这些操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这些操作实际上是为了获取Deployment的yaml模板</span></span><br><span class="line">[root@k8s-node1 ~]#  kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 --dry-run -o yaml &gt;tomcat6-deployment.yaml</span><br><span class="line">W0504 04:13:28.265432   24263 helpers.go:535] --dry-run is deprecated and can be replaced with --dry-run=client.</span><br><span class="line">[root@k8s-node1 ~]# ls tomcat6-deployment.yaml</span><br><span class="line">tomcat6-deployment.yaml</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p>修改“tomcat6-deployment.yaml”内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">部署</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl apply -f tomcat6-deployment.yaml</span><br><span class="line">deployment.apps/tomcat6 configured</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看资源</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-5jh6t   1/1     Running   0          27m</span><br><span class="line">pod/tomcat6-7b84fb5fdc-8lhwv   1/1     Running   0          27m</span><br><span class="line">pod/tomcat6-7b84fb5fdc-j4qmh   1/1     Running   0          27m</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   14h</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   3/3     3            3           27m</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   3         3         3       27m</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>





<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment tomcat6 --port=80 --target-port=8080 --type=NodePort  --dry-run -o yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>将这段输出和“tomcat6-deployment.yaml”进行拼接，表示部署完毕并进行暴露服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>



<p>部署并暴露服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl apply -f tomcat6-deployment.yaml</span><br><span class="line">deployment.apps/tomcat6 created</span><br><span class="line">service/tomcat6 created</span><br></pre></td></tr></table></figure>

<p>查看服务和部署信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-dsqmb   1/1     Running   0          4s</span><br><span class="line">pod/tomcat6-7b84fb5fdc-gbmxc   1/1     Running   0          5s</span><br><span class="line">pod/tomcat6-7b84fb5fdc-kjlc6   1/1     Running   0          4s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        14h</span><br><span class="line">service/tomcat6      NodePort    10.96.147.210   &lt;none&gt;        80:30172/TCP   4s</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   3/3     3            3           5s</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   3         3         3       5s</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>

<p>访问node1，node1和node3的30172端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# curl -I http://192.168.56.&#123;100,101,102&#125;:30172/</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: W/&quot;7454-1491118183000&quot;</span><br><span class="line">Last-Modified: Sun, 02 Apr 2017 07:29:43 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 7454</span><br><span class="line">Date: Mon, 04 May 2020 04:35:35 GMT</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: W/&quot;7454-1491118183000&quot;</span><br><span class="line">Last-Modified: Sun, 02 Apr 2017 07:29:43 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 7454</span><br><span class="line">Date: Mon, 04 May 2020 04:35:35 GMT</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: W/&quot;7454-1491118183000&quot;</span><br><span class="line">Last-Modified: Sun, 02 Apr 2017 07:29:43 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 7454</span><br><span class="line">Date: Mon, 04 May 2020 04:35:35 GMT</span><br><span class="line"></span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>通过Ingress发现pod进行关联。基于域名访问<br>通过Ingress controller实现POD负载均衡<br>支持TCP/UDP 4层负载均衡和HTTP 7层负载均衡</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504123948771.png" alt="image-20200504123948771"></p>
<p>步骤：<br>（1）部署Ingress controller</p>
<p>执行“k8s/ingress-controller.yaml”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl apply -f ingress-controller.yaml </span><br><span class="line">namespace/ingress-nginx created</span><br><span class="line">configmap/nginx-configuration created</span><br><span class="line">configmap/tcp-services created</span><br><span class="line">configmap/udp-services created</span><br><span class="line">serviceaccount/nginx-ingress-serviceaccount created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created</span><br><span class="line">role.rbac.authorization.k8s.io/nginx-ingress-role created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created</span><br><span class="line">daemonset.apps/nginx-ingress-controller created</span><br><span class="line">service/ingress-nginx created</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>



<p>查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE       NAME                                READY   STATUS              RESTARTS   AGE</span><br><span class="line">default         tomcat6-7b84fb5fdc-dsqmb            1/1     Running             0          16m</span><br><span class="line">default         tomcat6-7b84fb5fdc-gbmxc            1/1     Running             0          16m</span><br><span class="line">default         tomcat6-7b84fb5fdc-kjlc6            1/1     Running             0          16m</span><br><span class="line">ingress-nginx   nginx-ingress-controller-9q6cs      0/1     ContainerCreating   0          40s</span><br><span class="line">ingress-nginx   nginx-ingress-controller-qx572      0/1     ContainerCreating   0          40s</span><br><span class="line">kube-system     coredns-546565776c-9sbmk            1/1     Running             1          14h</span><br><span class="line">kube-system     coredns-546565776c-t68mr            1/1     Running             1          14h</span><br><span class="line">kube-system     etcd-k8s-node1                      1/1     Running             1          14h</span><br><span class="line">kube-system     kube-apiserver-k8s-node1            1/1     Running             1          14h</span><br><span class="line">kube-system     kube-controller-manager-k8s-node1   1/1     Running             1          14h</span><br><span class="line">kube-system     kube-flannel-ds-amd64-5xs5j         1/1     Running             2          13h</span><br><span class="line">kube-system     kube-flannel-ds-amd64-6xwth         1/1     Running             2          14h</span><br><span class="line">kube-system     kube-flannel-ds-amd64-fvnvx         1/1     Running             1          13h</span><br><span class="line">kube-system     kube-proxy-7tkvl                    1/1     Running             1          13h</span><br><span class="line">kube-system     kube-proxy-mvlnk                    1/1     Running             2          13h</span><br><span class="line">kube-system     kube-proxy-sz2vz                    1/1     Running             1          14h</span><br><span class="line">kube-system     kube-scheduler-k8s-node1            1/1     Running             1          14h</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>

<p>这里master节点负责调度，具体执行交给node2和node3来完成，能够看到它们正在下载镜像</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504124608258.png" alt="image-20200504124608258"></p>
<p>（2）创建Ingress规则</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat6.kubenetes.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">       <span class="attr">paths:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span> </span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">tomcat6</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# touch ingress-tomcat6.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash">将上面的规则，添加到ingress-tomcat6.yaml文件中</span></span><br><span class="line">[root@k8s-node1 k8s]# vi  ingress-tomcat6.yaml  </span><br><span class="line"> </span><br><span class="line">[root@k8s-node1 k8s]# kubectl apply -f ingress-tomcat6.yaml </span><br><span class="line">ingress.extensions/web created</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p>修改本机的hosts文件，添加如下的域名转换规则：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168.56.102</span> tomcat6.kubenetes.com</span><br></pre></td></tr></table></figure>



<p>测试: <a href="http://tomcat6.kubenetes.com/">http://tomcat6.kubenetes.com/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504131325267.png" alt="image-20200504131325267"></p>
<p>并且集群中即便有一个节点不可用，也不影响整体的运行。</p>
<h2 id="安装kubernetes可视化界面——DashBoard"><a href="#安装kubernetes可视化界面——DashBoard" class="headerlink" title="安装kubernetes可视化界面——DashBoard"></a>安装kubernetes可视化界面——DashBoard</h2><p>1、部署DashBoard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl appy -f  kubernetes-dashboard.yaml</span></span><br></pre></td></tr></table></figure>

<p> 文件在“k8s”源码目录提供</p>
<p>2、暴露DashBoard为公共访问</p>
<p>默认DashBoard只能集群内部访问，修改Service为NodePort类型，暴露到外部</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">3001</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>

<p>访问地址：<a href="http://nodeip:30001/">http://NodeIP:30001</a></p>
<p>3、创建授权账号</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="keyword">create</span> serviceaccount dashboar-<span class="keyword">admin</span> -n kube-sysem</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ kubectl create clusterrolebinding dashboar-admin <span class="attribute">--clusterrole</span>=cluter-admin <span class="attribute">--serviceaccount</span>=kube-system:dashboard-admin</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ kubectl describe secrets -n kube-system <span class="constructor">$( <span class="params">kubectl</span> -<span class="params">n</span> <span class="params">kube</span>-<span class="params">system</span> <span class="params">get</span> <span class="params">secret</span> |<span class="params">awk</span> &#x27;<span class="operator">/</span><span class="params">dashboard</span>-<span class="params">admin</span><span class="operator">/</span>&#123;<span class="params">print</span> $1&#125;&#x27; )</span></span><br></pre></td></tr></table></figure>

<p>使用输出的token登录dashboard</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504153630775.png" alt="image-20200504153630775"></p>
<h2 id="kubesphere"><a href="#kubesphere" class="headerlink" title="kubesphere"></a>kubesphere</h2><p>默认的dashboard没啥用，我们用kubesphere可以打通全部的devops链路，kubesphere集成了很多套件，集群要求比较高<br><a href="https://kubesphere.io/">https://kubesphere.io</a></p>
<p>kuboard也很不错，集群要求不高<br><a href="https://kuboard.cn/support/">https://kuboard.cn/support/</a></p>
<h3 id="1、简洁"><a href="#1、简洁" class="headerlink" title="1、简洁"></a>1、简洁</h3><p>kubesphere是一款面向云原声设计的开源项目，在目前主流容器调度平台kubernets智商构建的分布式多用户容器管理平台，提供简单易用的操作界面以及向导式操作方式，在降低用户使用容器调度平台学习成本的同时，极大降低开发、测试、运维的日常工作的复杂度。</p>
<h3 id="2、安装前提提交"><a href="#2、安装前提提交" class="headerlink" title="2、安装前提提交"></a>2、安装前提提交</h3><h4 id="1、安装helm（master节点执行）"><a href="#1、安装helm（master节点执行）" class="headerlink" title="1、安装helm（master节点执行）"></a>1、安装helm（master节点执行）</h4><p>helm是kubernetes的包管理器。包管理器类似于在Ubuntu中使用的apt，centos中的yum或者python中的pip一样，能够快速查找，下载和安装软件包。Helm有客户端组件helm和服务端组件Tiller组成，能够将一组K8S资源打包统一管理，是查找、共享和使用为Kubernetes构建的软件的最佳方式。</p>
<p>1）安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -L https:<span class="regexp">//gi</span>t.io/get_helm.sh|bash</span><br></pre></td></tr></table></figure>

<p>由于被墙的原因，使用我们给定的get_helm.sh。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# ll</span><br><span class="line">total 68</span><br><span class="line">-rw-r--r-- 1 root root  7149 Feb 27 01:58 get_helm.sh</span><br><span class="line">-rw-r--r-- 1 root root  6310 Feb 28 05:16 ingress-controller.yaml</span><br><span class="line">-rw-r--r-- 1 root root   209 Feb 28 13:18 ingress-demo.yml</span><br><span class="line">-rw-r--r-- 1 root root   236 May  4 05:09 ingress-tomcat6.yaml</span><br><span class="line">-rwxr--r-- 1 root root 15016 Feb 26 15:05 kube-flannel.yml</span><br><span class="line">-rw-r--r-- 1 root root  4737 Feb 26 15:38 kubernetes-dashboard.yaml</span><br><span class="line">-rw-r--r-- 1 root root  3841 Feb 27 01:09 kubesphere-complete-setup.yaml</span><br><span class="line">-rw-r--r-- 1 root root   392 Feb 28 11:33 master_images.sh</span><br><span class="line">-rw-r--r-- 1 root root   283 Feb 28 11:34 node_images.sh</span><br><span class="line">-rw-r--r-- 1 root root  1053 Feb 28 03:53 product.yaml</span><br><span class="line">-rw-r--r-- 1 root root   931 May  3 10:08 Vagrantfile</span><br><span class="line">[root@k8s-node1 k8s]# sh get_helm.sh </span><br><span class="line">Downloading https://get.helm.sh/helm-v2.16.6-linux-amd64.tar.gz</span><br><span class="line">Preparing to install helm and tiller into /usr/local/bin</span><br><span class="line">helm installed into /usr/local/bin/helm</span><br><span class="line">tiller installed into /usr/local/bin/tiller</span><br><span class="line">Run &#x27;helm init&#x27; to configure helm.</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p>2）验证版本</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">version</span></span><br></pre></td></tr></table></figure>

<p>3）创建权限（master执行）</p>
<p>创建helm-rbac.yaml，写入如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<p>应用配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]#  kubectl apply -f helm-rbac.yaml</span><br><span class="line">serviceaccount/tiller created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/tiller created</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>



<h4 id="2、安装Tilller（Master执行）"><a href="#2、安装Tilller（Master执行）" class="headerlink" title="2、安装Tilller（Master执行）"></a>2、安装Tilller（Master执行）</h4><p>1、初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# helm init --service-account=tiller --tiller-image=sapcc/tiller:v2.16.3 --history-max 300 </span><br><span class="line">Creating /root/.helm </span><br><span class="line">Creating /root/.helm/repository </span><br><span class="line">Creating /root/.helm/repository/cache </span><br><span class="line">Creating /root/.helm/repository/local </span><br><span class="line">Creating /root/.helm/plugins </span><br><span class="line">Creating /root/.helm/starters </span><br><span class="line">Creating /root/.helm/cache/archive </span><br><span class="line">Creating /root/.helm/repository/repositories.yaml </span><br><span class="line">Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com </span><br><span class="line">Adding local repo with URL: http://127.0.0.1:8879/charts </span><br><span class="line"><span class="meta">$</span><span class="bash">HELM_HOME has been configured at /root/.helm.</span></span><br><span class="line"></span><br><span class="line">Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</span><br><span class="line"></span><br><span class="line">Please note: by default, Tiller is deployed with an insecure &#x27;allow unauthenticated users&#x27; policy.</span><br><span class="line">To prevent this, run `helm init` with the --tiller-tls-verify flag.</span><br><span class="line">For more information on securing your installation see: https://v2.helm.sh/docs/securing_installation/</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p>–tiller-image 指定镜像，否则会被墙，等待节点上部署的tiller完成即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]#  kubectl get pods -n kube-system</span><br><span class="line">NAME                                   READY   STATUS             RESTARTS   AGE</span><br><span class="line">coredns-546565776c-9sbmk               1/1     Running            3          23h</span><br><span class="line">coredns-546565776c-t68mr               1/1     Running            3          23h</span><br><span class="line">etcd-k8s-node1                         1/1     Running            3          23h</span><br><span class="line">kube-apiserver-k8s-node1               1/1     Running            3          23h</span><br><span class="line">kube-controller-manager-k8s-node1      1/1     Running            3          23h</span><br><span class="line">kube-flannel-ds-amd64-5xs5j            1/1     Running            4          22h</span><br><span class="line">kube-flannel-ds-amd64-6xwth            1/1     Running            5          23h</span><br><span class="line">kube-flannel-ds-amd64-fvnvx            1/1     Running            4          22h</span><br><span class="line">kube-proxy-7tkvl                       1/1     Running            3          22h</span><br><span class="line">kube-proxy-mvlnk                       1/1     Running            4          22h</span><br><span class="line">kube-proxy-sz2vz                       1/1     Running            3          23h</span><br><span class="line">kube-scheduler-k8s-node1               1/1     Running            3          23h</span><br><span class="line">kubernetes-dashboard-975499656-jxczv   0/1     ImagePullBackOff   0          7h45m</span><br><span class="line">tiller-deploy-8cc566858-67bxb          1/1     Running            0          31s</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>



<p>查看集群的所有节点信息：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">kubectl get <span class="keyword">node</span> <span class="title">-o</span> wide</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]#  kubectl get node -o wide</span><br><span class="line">NAME        STATUS   ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION               CONTAINER-RUNTIME</span><br><span class="line">k8s-node1   Ready    master   23h   v1.17.3   10.0.2.15     &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://19.3.8</span><br><span class="line">k8s-node2   Ready    &lt;none&gt;   22h   v1.17.3   10.0.2.4      &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://19.3.8</span><br><span class="line">k8s-node3   Ready    &lt;none&gt;   22h   v1.17.3   10.0.2.5      &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://19.3.8</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>





<p>2、测试</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">helm install <span class="keyword">stable</span>/nginx-ingress <span class="comment">--name nginx-ingress</span></span><br></pre></td></tr></table></figure>





<p>最小化安装 KubeSphere</p>
<p>若集群可用 CPU &gt; 1 Core 且可用内存 &gt; 2 G，可以使用以下命令最小化安装 KubeSphere：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">https://raw.githubusercontent.com/kubesphere/ks-installer/master/kubesphere-minimal.yaml</span></span><br></pre></td></tr></table></figure>

<p> <strong>提示：若您的服务器提示无法访问 GitHub，可将</strong> <a href="https://github.com/kubesphere/ks-installer/blob/master/kubesphere-minimal.yaml">kubesphere-minimal.yaml</a> <strong>或</strong> <a href="https://github.com/kubesphere/ks-installer/blob/master/kubesphere-complete-setup.yaml">kubesphere-complete-setup.yaml</a> <strong>文件保存到本地作为本地的静态文件，再参考上述命令进行安装。</strong> </p>
<ol>
<li>查看滚动刷新的安装日志，请耐心等待安装成功。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=<span class="string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：安装过程中若遇到问题，也可以通过以上日志命令来排查问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>java容器详解</title>
    <url>/2021/09/28/java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java容器概述"><a href="#Java容器概述" class="headerlink" title="Java容器概述"></a>Java容器概述</h1><p>Java集合分为两大阵营：<strong>Collection</strong>和<strong>Map</strong></p>
<p><strong>Collection</strong>：主要是单个元素的集合，由List、Queue、Set三个接口区分不同的集合特征，然后由下面的具体的类来实现对应的功能。</p>
<p><strong>Map</strong>：有一组键值对的存储形式来保存，可以用键对象来查找值。</p>
<p><img src="/2021/09/28/java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/snipaste_20220228_195120.png" alt="Java集合框架"></p>
<h2 id="集合框架底层数据结构总结："><a href="#集合框架底层数据结构总结：" class="headerlink" title="集合框架底层数据结构总结："></a>集合框架底层数据结构总结：</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a><strong>Collection</strong></h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》  (opens new window)</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<hr>
<h1 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>ArrayList、LinkedList和Vector都实现了List接口。</p>
<p>其中ArrayList是List的主要实现类，Vector是List的古老实现类，他们两者底层都使用<code>Object[]</code>存储，区别在于ArrayList是线程不安全的，而Vector是线程安全的。</p>
<p>与前两者不同，LinkedList底层使用的是双向链表数据结构，它也是线程不安全的。</p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><strong>无序性和不可重复性：</strong></p>
<p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul>
<li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p>
</li>
<li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
</li>
<li><p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
</li>
</ul>
<h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><p><strong>Queue与Deque的区别：</strong></p>
<p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>HashSet是基于HashMap实现的，它们是基于以下方式实现唯一性的：</p>
<p>当把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<p><strong><code>hashCode()</code>与 <code>equals()</code> ：</strong></p>
<ol>
<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>
<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>
<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>
<li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>
<li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与 equals 的区别</strong></p>
<p>对于基本类型来说，== 比较的是值是否相等；</p>
<p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p>
<p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>
<h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a><strong>HashMap 的底层实现</strong></h3><p><strong>JDK1.8 之前</strong>：</p>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK1.8之后</strong>：</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h3 id="HashMap-几种常见的遍历方式"><a href="#HashMap-几种常见的遍历方式" class="headerlink" title="HashMap 几种常见的遍历方式"></a>HashMap 几种常见的遍历方式</h3><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p>
<ol>
<li>迭代器（Iterator）方式遍历；</li>
<li>For Each 方式遍历；</li>
<li>Lambda 表达式遍历（JDK 1.8+）;</li>
<li>Streams API 遍历（JDK 1.8+）。</li>
</ol>
<p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p>
<h4 id="1-迭代器-EntrySet"><a href="#1-迭代器-EntrySet" class="headerlink" title="1.迭代器 EntrySet"></a>1.迭代器 EntrySet</h4><div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="2-迭代器-KeySet"><a href="#2-迭代器-KeySet" class="headerlink" title="2.迭代器 KeySet"></a>2.迭代器 KeySet</h4><div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer key = iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="3-ForEach-EntrySet"><a href="#3-ForEach-EntrySet" class="headerlink" title="3.ForEach EntrySet"></a>3.ForEach EntrySet</h4><div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);java</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="4-ForEach-KeySet"><a href="#4-ForEach-KeySet" class="headerlink" title="4.ForEach KeySet"></a>4.ForEach KeySet</h4><div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);java</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="5-Lambda"><a href="#5-Lambda" class="headerlink" title="5.Lambda"></a>5.Lambda</h4><div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="6-Streams-API-单线程"><a href="#6-Streams-API-单线程" class="headerlink" title="6.Streams API 单线程"></a>6.Streams API 单线程</h4><div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="7-Streams-API-多线程"><a href="#7-Streams-API-多线程" class="headerlink" title="7.Streams API 多线程"></a>7.Streams API 多线程</h4><div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p><strong>应该尽量使用迭代器（Iterator）来遍历 <code>EntrySet</code> 的遍历方式来操作 Map 集合</strong>，<strong>既安全又高效</strong>。</p>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a><strong>HashMap 和 Hashtable 的区别</strong></h3><ol>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<p>另外，与HashMap相比，TreeMap底层使用红黑树实现，<strong>多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p><strong>两者的对比图：</strong></p>
<p><img src="/2021/09/28/java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/snipaste_20220228_213431.png" alt="HashTable全表锁"></p>
<p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p>
<p><img src="/2021/09/28/java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/snipaste_20220228_213546.png" alt="ConcurrentHashMap分段锁"></p>
<p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p>
<p><img src="/2021/09/28/java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/snipaste_20220228_220058.png" alt="java8 ConcurrentHashMap"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7（上面有示意图）"><a href="#JDK1-7（上面有示意图）" class="headerlink" title="JDK1.7（上面有示意图）"></a>JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
<h4 id="JDK1-8-（上面有示意图）"><a href="#JDK1-8-（上面有示意图）" class="headerlink" title="JDK1.8 （上面有示意图）"></a>JDK1.8 （上面有示意图）</h4><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <strong>CAS 和 <code>synchronized</code></strong> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))。</p>
<p><strong><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</strong></p>
<p>[java集合使用注意事项总结](<a href="https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">Java集合使用注意事项总结 | JavaGuide</a>)</p>
<hr>
<p>参考链接：<a href="https://javaguide.cn/java/collection/java-collection-questions-01/">https://javaguide.cn/java/collection/java-collection-questions-01/</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>juc并发之CAS机制</title>
    <url>/2021/09/25/juc%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="什么是CAS机制"><a href="#什么是CAS机制" class="headerlink" title="什么是CAS机制?"></a>什么是CAS机制?</h1><p><strong>CAS机制是一种数据更新的方式</strong>。在具体讲什么是CAS机制之前，我们先来聊下在多线程环境下，对共享变量进行数据更新的两种模式：悲观锁模式和乐观锁模式。</p>
<ul>
<li><p><strong>悲观锁</strong>：在更新数据的时候大概率会有其他线程去争夺共享资源，所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。synchronized就是java中悲观锁的典型实现，synchronized使用起来非常简单方便，但是会使没争抢到资源的线程进入阻塞状态，线程在阻塞状态和Runnable状态之间切换效率较低（比较慢）。比如你的更新操作其实是非常快的，这种情况下你还用synchronized将其他线程都锁住了，线程从Blocked状态切换回Runnable华的时间可能比你的更新操作的时间还要长。</p>
</li>
<li><p><strong>乐观锁</strong>:在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。CAS机制就是乐观锁的典型实现。</p>
</li>
</ul>
<p> <strong><code>CAS</code>全称<code>compare and swap</code>——比较并替换</strong>，它是并发条件下修改数据的一种机制，包含三个操作数：</p>
<blockquote>
<ul>
<li>需要修改的数据的内存地址（V）；</li>
<li>对这个数据的旧预期值（A）；</li>
<li>需要将它修改为的值（B）；</li>
</ul>
</blockquote>
<p>  CAS的操作步骤如下：</p>
<blockquote>
<ol>
<li>修改前记录数据的内存地址V；</li>
<li>读取数据的当前的值，记录为A；</li>
<li>修改数据的值变为B；</li>
<li>查看地址V下的值是否仍然为A，若为A，则用B替换它；若地址V下的值不为A，表示在自己修改的过程中，其他的线程对数据进行了修改，则不更新变量的值，而是重新从步骤2开始执行，这被称为<strong>自旋</strong>；</li>
</ol>
</blockquote>
<p>  通过以上四个步骤对内存中的数据进行修改，就可以保证数据修改的原子性。<code>CAS</code>是乐观锁的一种实现，所以这里介绍的步骤和乐观锁的定义差不多，还是很好理解的。</p>
<p><img src="/2021/09/25/juc%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E6%9C%BA%E5%88%B6/CAS%E6%9C%BA%E5%88%B6.png" alt="CAS机制"></p>
<p>如上图中，主存中保存V值，线程中要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后变成B值，最后再把B值写回到内存V值中。多个线程共用V值都是如此操作。CAS的核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值已经被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。</p>
<p>值得注意的是CAS机制中的这步步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题。</p>
<hr>
<h1 id="CAS机制的ABA问题"><a href="#CAS机制的ABA问题" class="headerlink" title="CAS机制的ABA问题"></a>CAS机制的ABA问题</h1><p>  <code>CAS</code>机制虽然简单，但是也存在一些缺陷，其中比较典型的就是<code>ABA</code>问题。什么是<code>ABA</code>问题，我简单介绍一下：</p>
<ol>
<li>假设有三个线程<code>T1</code>、<code>T2</code>和<code>T3</code>，它们都要对一个变量<code>num</code>的值进行修改，且使用的都是<code>CAS</code>机制进行同步，假设<code>num</code>的初始值为<code>100</code>；</li>
<li>线程<code>T1</code>首先读取了<code>num</code>的值，将它记录为旧预期<code>A1 = 100</code>，然后它想要将<code>num</code>的值修改为<code>80</code>，记录<code>B2 = 80</code>，在执行<code>num = B2</code>前，线程发生了切换，切换到线程<code>T2</code>；</li>
<li>假设<code>T2</code>毫无阻碍地修改了<code>num</code>的值，将它从<code>100</code>修改为<code>80</code>，然后线程再度切换，<code>T3</code>开始执行；</li>
<li><code>T3</code>也是毫无阻碍地修改了<code>num</code>，将它从<code>80</code>重新修改为<code>100</code>，线程再次切换回<code>T1</code>；</li>
<li><code>T1</code>从上次运行的断点恢复，也就是准备用<code>B1</code>的值覆盖<code>num</code>，但是由于<code>CAS</code>机制，它需要先检测<code>num</code>的值是否等于它记录的预期值<code>A1</code>，然后它发现<code>A1 = num = 100</code>，认为<code>num</code>没有被修改过，于是用<code>B1</code>覆盖了<code>num</code>；</li>
</ol>
<p>  上面这种情况就是<code>CAS</code>的<code>ABA</code>问题：一个变量被修改，但是又被改了回去，在<code>CAS</code>机制中，将无法察觉这种错误的现象。在线程<code>T1</code>被中断的过程中，<code>num</code>的值被修改，按照<code>CAS</code>的原则，<code>T1</code>应该放弃对<code>num</code>的修改，从头开始执行。<br>  对于<code>ABA</code>问题的解决方案也非常简单，那就是再添加一个变量——版本号。每个变量都加上一个版本号，在它被修改时，也同步修改版本号，而<code>CAS</code>操作在修改前记录版本号，若在最后更新变量时，记录的版本号与当前版本号一致，表示没有被修改，可直接更新。</p>
<hr>
<h1 id="CAS的优缺点以及适用场景"><a href="#CAS的优缺点以及适用场景" class="headerlink" title="CAS的优缺点以及适用场景"></a>CAS的优缺点以及适用场景</h1><p> <strong>（1）优点</strong></p>
<ul>
<li>可以保证变量操作的原子性；</li>
<li>并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li>
<li>在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li>
</ul>
<p> <strong>（2）缺点</strong></p>
<ul>
<li> <strong>ABA问题</strong></li>
</ul>
<p>  CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p>
<ul>
<li><p><strong>可能会消耗较高的CPU</strong><br>看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p>
</li>
<li><p><strong>不能保证代码块的原子性</strong><br>Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p>
</li>
</ul>
<p> <strong>（3）适用场景</strong></p>
<p>  由上面分析的优缺点可以看出，<code>CAS</code>适用于并发冲突发生频率较低的场合，而对于并发冲突较频繁的场合，<code>CAS</code>由于不断重试，反倒会降低效率。</p>
<ul>
<li>使用一个变量统计网站的访问量；</li>
<li>Atomic类操作；</li>
<li>数据库乐观锁更新。</li>
</ul>
<p><strong>总结</strong></p>
<p>  <code>CAS</code>是一种在并发下实现原子操作的机制，但是只能用来保证一个变量的原子性，适用于并发冲突频率较低的场合。</p>
<hr>
<p><strong>参考：</strong></p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/101430930">并发编程的灵魂：CAS机制详解 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/f9PYMnpAgS1gAQYPDuCq-w">https://mp.weixin.qq.com/s/f9PYMnpAgS1gAQYPDuCq-w</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg">https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2021/09/01/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h1><h2 id="I-O是什么"><a href="#I-O是什么" class="headerlink" title="I/O是什么?"></a>I/O是什么?</h2><p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p>
<p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>
<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。<strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p>
<p><strong>从应用程序的角度来解读I/O“：</strong></p>
<p>为了保证操作系统的稳定性和安全性，<strong>一个进程的地址空间</strong>划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p>
<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如<strong>文件管理、进程通信、内存管理</strong>等等。也就是说，<strong>我们想要进行 IO 操作，一定是要依赖内核空间的能力。</strong></p>
<p>并且，用户空间的程序不能直接访问内核空间。</p>
<p><strong>进程切换</strong></p>
<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 <strong>进程切换很消耗资源</strong>。</p>
<p><strong>进程阻塞</strong></p>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<p><strong>缓存 I/O</strong></p>
<p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起<strong>系统调用</strong>请求操作系统帮忙完成。</p>
<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>
<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>
<ol>
<li><strong>内核等待 I/O 设备准备好数据</strong></li>
<li><strong>内核将数据从内核空间拷贝到用户空间。</strong></li>
</ol>
<h2 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h2><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。这也是我们经常提到的 5 种 IO 模型。</p>
<h2 id="同步、异步、阻塞与非阻塞的重点概念区分"><a href="#同步、异步、阻塞与非阻塞的重点概念区分" class="headerlink" title="同步、异步、阻塞与非阻塞的重点概念区分"></a>同步、异步、阻塞与非阻塞的重点概念区分</h2><p><strong>同步和异步</strong>的概念描述的是<strong>用户线程与内核的交互方式</strong>：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p>
<p><strong>阻塞和非阻塞</strong>的概念描述的是<strong>用户线程调用内核IO操作的方式</strong>：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成</p>
<p><strong>同步和异步</strong>、<strong>阻塞和非阻塞</strong>这两对儿概念，是两个维度的概念，大家不要混淆。</p>
<ul>
<li>同步才区分阻塞和非阻塞</li>
<li>异步则一定是非阻塞的，不存在直接的<code>异步非阻塞</code>方式</li>
</ul>
<h1 id="Java-中-3种常见-IO-模型"><a href="#Java-中-3种常见-IO-模型" class="headerlink" title="Java 中 3种常见 IO 模型"></a>Java 中 3种常见 IO 模型</h1><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><img src="/2021/09/01/IO%E6%A8%A1%E5%9E%8B/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" alt="同步阻塞IO模型"></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p>跟着我的思路往下看看，相信你会得到答案！</p>
<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p>
<p><img src="/2021/09/01/IO%E6%A8%A1%E5%9E%8B/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" alt="同步非阻塞IO模型"></p>
<p>用户线程每次发起IO请求后可以立即返回，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p>
<p><img src="/2021/09/01/IO%E6%A8%A1%E5%9E%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="IO多路复用"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<ul>
<li><p><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</p>
</li>
<li><p><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</p>
</li>
</ul>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<p><img src="/2021/09/01/IO%E6%A8%A1%E5%9E%8B/Selector%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8.png" alt="Selector多路复用器"></p>
<h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="/2021/09/01/IO%E6%A8%A1%E5%9E%8B/AIO.png" alt="AIO"></p>
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>
<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>
<p><img src="/2021/09/01/IO%E6%A8%A1%E5%9E%8B/%E5%90%84%E7%B1%BBIO%E6%80%BB%E7%BB%93.png" alt="各类IO总结"></p>
<p>参考：<a href="https://javaguide.cn/java/basis/io/#aio-asynchronous-i-o">IO模型详解 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>redis重要知识点总结</title>
    <url>/2021/07/25/redis%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h1><p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>另外，<strong>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</strong></p>
<p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p>
<h2 id="Redis特点："><a href="#Redis特点：" class="headerlink" title="Redis特点："></a><strong>Redis特点：</strong></h2><p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p>
<p>Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。</p>
<p>Redis支持数据的备份，即master-slave模式的数据备份。</p>
<p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
<p>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p>
<p>丰富的特性 – Redis还支持 publish/subscribe, 通知, 设置key有效期等等特性。</p>
<h2 id="Redis-和-Memcached-的区别和共同点"><a href="#Redis-和-Memcached-的区别和共同点" class="headerlink" title="Redis 和 Memcached 的区别和共同点"></a>Redis 和 Memcached 的区别和共同点</h2><p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>
<p><strong>共同点</strong> ：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>
<h2 id="为什么要用-Redis做缓存？"><a href="#为什么要用-Redis做缓存？" class="headerlink" title="为什么要用 Redis做缓存？"></a>为什么要用 Redis做缓存？</h2><p><strong>高性能</strong> ：</p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<p>redis除了做缓存，还能实现以下功能：</p>
<ul>
<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：<a href="https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw">《分布式锁中的王者方案 - Redisson》  (opens new window)</a>。</li>
<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》  (opens new window)</a>。</li>
<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
<li>……</li>
</ul>
<h1 id="Redis常用五大数据类型"><a href="#Redis常用五大数据类型" class="headerlink" title="Redis常用五大数据类型"></a>Redis常用五大数据类型</h1><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<ol>
<li><strong>常用命令：</strong> <code>set,get,strlen,exists,decr,incr,setex</code> 等等。</li>
<li><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li>
</ol>
<p><strong>Redis字符串类型的使用：</strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<p><strong>普通字符串的基本操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key value <span class="comment">#设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key <span class="comment"># 根据 key 获得对应的 value</span></span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key  <span class="comment"># 判断某个 key 是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key <span class="comment"># 返回 key 所储存的字符串值的长度。</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; del key <span class="comment"># 删除某个 key 对应的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>批量设置</strong> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 value1 key2 value2 <span class="comment"># 批量设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 <span class="comment"># 批量获取多个 key 对应的 value</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> number 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number <span class="comment"># 将 key 中储存的数字值增一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr number <span class="comment"># 将 key 中储存的数字值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>过期（默认为永不过期）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key  60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<ol>
<li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange,llen</code> 等。</li>
<li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li>
</ol>
<p><strong>List基本使用：</strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 <span class="comment"># 向 list 的头部（右边）添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value2 value3 <span class="comment"># 向list的头部（最右边）添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop myList <span class="comment"># 将 list的尾部(最左边)元素取出</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br><span class="line">2) <span class="string">&quot;value3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br><span class="line">2) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList2 value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop myList2 <span class="comment"># 将 list的头部(最右边)元素取出</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p>
<p><strong>通过 <code>llen</code> 查看链表长度：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen myList</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="Redis哈希表（Hash）"><a href="#Redis哈希表（Hash）" class="headerlink" title="Redis哈希表（Hash）"></a>Redis哈希表（Hash）</h2><p><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<p><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</p>
<p><strong>应用场景:</strong> 系统中对象数据的存储。</p>
<p><strong>Redis Hash简单使用：</strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="string">&quot;24&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;guide&quot;</span></span><br><span class="line">3) <span class="string">&quot;description&quot;</span></span><br><span class="line">4) <span class="string">&quot;dev&quot;</span></span><br><span class="line">5) <span class="string">&quot;age&quot;</span></span><br><span class="line">6) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;description&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals userInfoKey <span class="comment"># 获取 value 列表</span></span><br><span class="line">1) <span class="string">&quot;guide&quot;</span></span><br><span class="line">2) <span class="string">&quot;dev&quot;</span></span><br><span class="line">3) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span> <span class="comment"># 修改某个字段对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h2><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</p>
<ol>
<li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li>
<li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li>
</ol>
<p>Set基本使用：</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 <span class="comment"># 添加元素进去</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 <span class="comment"># 不允许有重复元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet <span class="comment"># 查看 set 中所有的元素</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard mySet <span class="comment"># 查看 set 的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sismember mySet value1 <span class="comment"># 检查某个元素是否存在set 中，只能接收单个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet2 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 <span class="comment"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet3</span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h2><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<p><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</p>
<p><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</p>
<p><strong>Zset基本使用：</strong></p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 <span class="comment"># 添加元素到 sorted set 中 3.0 为权重</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 <span class="comment"># 一次添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 -1 <span class="comment"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 1 <span class="comment"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange  myZset 0 1 <span class="comment"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h2><p>什么是 bigkey？</p>
<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<p> bigkey 有什么危害？</p>
<p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</p>
<p>因此，我们应该尽量避免写入 bigkey！</p>
<p>如何发现 bigkey？</p>
<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 6379 --bigkeys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes</span><br><span class="line">[00.00%] Biggest list   found so far <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 5 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is 264 (avg len 52.80)</span><br><span class="line"></span><br><span class="line">Biggest   list found <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items</span><br><span class="line">Biggest string found <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes</span><br><span class="line"></span><br><span class="line">1 lists with 17 items (20.00% of keys, avg size 17.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)</span><br><span class="line">0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00</span><br></pre></td></tr></table></figure>

<p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p>
<p><strong>2、分析 RDB 文件</strong></p>
<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
<p>网上有现成的代码/工具可以直接拿来使用：</p>
<ul>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">redis-rdb-tools  (opens new window)</a> ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li><a href="https://github.com/weiyanwei412/rdb_bigkeys">rdb_bigkeys  (opens new window)</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
<h1 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h1><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：<strong>1. 文件事件; 2. 时间事件。</strong></p>
<p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：<strong>这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing</strong>）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><strong>Redis使用单线程的好处：</strong></p>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能</li>
</ol>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">io-threads-do-reads yes</span><br></pre></td></tr></table></figure>

<p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>

<h1 id="Redis-缓存数据过期时间"><a href="#Redis-缓存数据过期时间" class="headerlink" title="Redis 缓存数据过期时间"></a>Redis 缓存数据过期时间</h1><h2 id="设置过期时间的作用"><a href="#设置过期时间的作用" class="headerlink" title="设置过期时间的作用"></a>设置过期时间的作用</h2><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exp key 60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure>

<p>注意：**Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。 **</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h2 id="Redis是如何判断数据是否过期？"><a href="#Redis是如何判断数据是否过期？" class="headerlink" title="Redis是如何判断数据是否过期？"></a><strong>Redis是如何判断数据是否过期？</strong></h2><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<h2 id="Redis过期数据删除策略"><a href="#Redis过期数据删除策略" class="headerlink" title="Redis过期数据删除策略"></a>Redis过期数据删除策略</h2><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h1 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h1><p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
</li>
<li><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p>
</li>
<li><p><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p>
</li>
<li><p><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p>
</li>
<li><p><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</p>
</li>
<li><h1 id="no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！"><a href="#no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！" class="headerlink" title="no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！"></a><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</h1></li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h1 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h1><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p>
<h3 id="快照（snapshotting）持久化（RDB）"><a href="#快照（snapshotting）持久化（RDB）" class="headerlink" title="快照（snapshotting）持久化（RDB）"></a>快照（snapshotting）持久化（RDB）</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<h3 id="AOF（append-only-file）持久化"><a href="#AOF（append-only-file）持久化" class="headerlink" title="AOF（append-only file）持久化"></a>AOF（append-only file）持久化</h3><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>AOF 重写</strong></p>
<p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p><strong>拓展：Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<blockquote>
<p>RDB的优点：简称“3更”</p>
<p>1.体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件</p>
<p>2.恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存</p>
<p>3.性能更高:父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。</p>
<p>缺点：</p>
<p>1.故障丢失:因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。</p>
<p>2.耐久性差:相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。</p>
</blockquote>
<blockquote>
<p>aof的优点</p>
<p>1.数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，咱们也最多丢失一秒数据</p>
<p>2.自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。</p>
<p>缺点呢：和rdb相反嘛，毕竟只有两种。</p>
<p>1.性能相对较差：它的操作模式决定了它会对redis的性能有所损耗</p>
<p>2.体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。</p>
<p>3.恢复速度更慢：</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>redis有两种持久化方式，aof和rdb，aof相当于日志记录操作命令，rdb相当于数据的快照。安全性来讲由于aof的记录能够精确到秒级追加甚至逐条追加，而rdb只能是全量复制，aof明显高于rdb。但是从性能来讲rdb就略胜一筹，rdb是redis性能最大化的体现，它不用每秒监控是否有数据写入，当达到触发条件后就自动fork一个子进程进行全量更新，速度也很快。容灾回复方面rdb更是能够快速的恢复数据，而aof需要读取再写入，相对慢了很多。</p>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h2 id="Redis事务基本概念"><a href="#Redis事务基本概念" class="headerlink" title="Redis事务基本概念"></a>Redis事务基本概念</h2><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<p>Redis开启一个事务后，若出现语法错误，均连坐，所有指令都不执行；</p>
<p>若出现的是运行时错误，正确的命令都会执行，错误的命令返回错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;Guide哥&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Guide哥&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 MULTI命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 EXEC命令将执行所有命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）。</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>也可以通过 DISCARD 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;Guide哥&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>WATCH 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; WATCH USER</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">&gt; SET USER <span class="string">&quot;Guide哥&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; GET USER</span><br><span class="line">Guide哥</span><br><span class="line">&gt; EXEC</span><br><span class="line">ERR EXEC without MULTI</span><br></pre></td></tr></table></figure>

<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<h2 id="Redis事务与Mysql事务的区别"><a href="#Redis事务与Mysql事务的区别" class="headerlink" title="Redis事务与Mysql事务的区别"></a>Redis事务与Mysql事务的区别</h2><h3 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h3><p><strong>mysql：</strong></p>
<ul>
<li>Begin:显式的开启一个事务；</li>
<li>Commit：提交事务，将对数据库进行的所有的修改变成永久性的；</li>
<li>Rollback：结束用户的事务，并撤销现在正在进行的未提交的修改；</li>
</ul>
<p><strong>redis：</strong></p>
<ul>
<li>Multi：标记事务的开始；</li>
<li>Exec：执行事务的commands队列；</li>
<li>Discard：结束事务，并清除commands队列；</li>
</ul>
<h3 id="默认状态"><a href="#默认状态" class="headerlink" title="默认状态"></a>默认状态</h3><p><strong>mysql：</strong></p>
<ul>
<li>mysql会<strong>默认开启</strong>一个事务，且缺省设置是自动提交，即每成功执行一次sql，一个事务就会马上commit，所以不能rollback；</li>
<li>默认情况下如上所述，但是非默认情况下，<strong>可以rollback</strong>；</li>
</ul>
<p><strong>redis：</strong></p>
<ul>
<li>redis<strong>默认不会开启</strong>事务，即command会立即执行，而不会排队，并<strong>不支持rollback</strong>；</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><strong>mysql（包含两种方式）：</strong></p>
<ol>
<li>用Begin、Rollback、commit显式开启并控制一个 新的 Transaction；</li>
<li>执行命令 set autocommit=0，用来禁止当前会话自动commit，控制 默认开启的事务；</li>
</ol>
<p><strong>redis：</strong></p>
<ol>
<li>用multi、exec、discard，显式开启并控制一个Transaction。（注意：这里没有强调 “新的” ，因为默认是不会开启事务的）。</li>
</ol>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>mysql：</strong></p>
<ul>
<li>mysql实现事务，是基于<strong>undo/redo日志</strong>；</li>
<li><code>undo</code>记录**<code>修改前</code><strong>状态，</strong><code>rollback</code><strong>基于</strong>undo**日志实现；</li>
<li><code>redo</code>记录**<code>修改后</code><strong>的状态，</strong><code>commit</code><strong>基于</strong>redo**日志实现；</li>
<li>在mysql中无论是否开启事务，<strong>sql都会被立即执行并返回执行结果</strong>，只是**<code>事务开启</code><strong>后<code>执行后的状态</code>只是记录在<code>redo日志</code>，执行<code>commit</code>之后，数据才会被</strong><code>写入磁盘；</code>**</li>
</ul>
<p>如： int insertSelective = serviceOrderMapper.insertSelective(s); </p>
<p>上述代码，insertSelective 将会被立即赋值（无论是否开启事务，只是结果或<strong>未被</strong>写入磁盘）：</p>
<p>redis:</p>
<ul>
<li>redis实现事务，是基于<code>commands队列</code></li>
<li>如果<strong>没有开启</strong>事务，command将会被立即执行并返回执行结果，并且<strong>直接写入磁盘</strong>；</li>
<li>如果<strong>事务开启</strong>，command不会被立即执行，而是<strong>排入队列</strong>，并返回**<code>排队状态</code><strong>（具体依赖于客户端（例如：spring-data-redis）自身实现）。调用</strong><code>exec</code><strong>才会执行</strong><code>commands队列；</code>**</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> a = redisTemplate.opsForZSet().add(<span class="string">&quot;generalService&quot;</span>,orderId,System.currentTimeMillis());</span><br></pre></td></tr></table></figure>

<p>可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<h3 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="Redis 可以做消息队列么？"></a>Redis 可以做消息队列么？</h3><p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p>
<ul>
<li>发布 / 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>
<p>我们通常建议是不需要使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>
<h1 id="Redis缓存存在的几个问题"><a href="#Redis缓存存在的几个问题" class="headerlink" title="Redis缓存存在的几个问题"></a>Redis缓存存在的几个问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<p><strong>解决办法：</strong></p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/">《不了解布隆过滤器？一文给你整的明明白白！》  (opens new window)</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<p><strong>解决办法：</strong></p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p> 对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问， 是一种非常“热点”的数据。这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所 有对这个 key 的数据查询都落到 db，我们称为缓存击穿。</p>
<p> 解决办法： 加锁</p>
<h2 id="缓存数据一致性"><a href="#缓存数据一致性" class="headerlink" title="缓存数据一致性"></a>缓存数据一致性</h2><ul>
<li><p>双写模式：进行插入操作之后，我们把该条数据取出来同时保存到redis缓存中去，这样再次查询缓存的时候我们也可以看到新的数据</p>
</li>
<li><p>失效模式：更新数据库时清理缓存</p>
</li>
</ul>
<p>上述两种方法在高并发场景下还是会出现不一致的问题</p>
<p>改进方法：</p>
<ul>
<li>分布式读写锁：读数据等待写数据整个操作完成</li>
<li>使用cannal</li>
</ul>
<p><img src="/2021/07/25/redis%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Cannal.png" alt="Cannal"></p>
<h1 id="3种常用的缓存读写模式"><a href="#3种常用的缓存读写模式" class="headerlink" title="3种常用的缓存读写模式"></a>3种常用的缓存读写模式</h1><h3 id="旁路缓存模式"><a href="#旁路缓存模式" class="headerlink" title="旁路缓存模式"></a>旁路缓存模式</h3><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong> ：</p>
<ul>
<li>先更新 DB</li>
<li>然后直接删除 cache 。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p>![Cache Aside Pattern](redis重要知识点总结/Cache Aside Pattern.png)</p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p>![Cache Aside Pattern 读](redis重要知识点总结/Cache Aside Pattern 读.png)</p>
<p>缺点：</p>
<p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
<p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h3 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read/Write Through Pattern（读写穿透）"></a>Read/Write Through Pattern（读写穿透）</h3><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<h3 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h3><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识点总结</title>
    <url>/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>
<p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="存储引擎相关的命令"><a href="#存储引擎相关的命令" class="headerlink" title="存储引擎相关的命令"></a>存储引擎相关的命令</h3><p><strong>查看 MySQL 提供的所有存储引擎</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="Mysql存储引擎"></p>
<p>从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB，并且在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>
<p><strong>查看 MySQL 当前默认的存储引擎</strong></p>
<p>我们也可以通过下面的命令查看默认的存储引擎。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>查看表的存储引擎</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> &quot;table_name&quot; ;</span><br></pre></td></tr></table></figure>

<h3 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h3><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>
<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p>
<ol>
<li><p><strong>是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。所以，InnoDB在并发写的时候，性能更加优秀。</p>
</li>
<li><p><strong>是否支持事务</strong></p>
<p>MyISAM不提供事务支持；InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
</li>
<li><p><strong>是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。但一般不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
</li>
<li><p><strong>是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> </p>
</li>
</ol>
<ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
<li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>
</ul>
<ol start="5">
<li><p><strong>是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能</p>
</li>
</ol>
<h3 id="锁机制与-InnoDB-锁算法"><a href="#锁机制与-InnoDB-锁算法" class="headerlink" title="锁机制与 InnoDB 锁算法"></a>锁机制与 InnoDB 锁算法</h3><p><strong>MyISAM 和 InnoDB 存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM 采用表级锁(table-level locking)。</li>
<li>InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB 存储引擎的锁的算法有三种：</strong></p>
<ul>
<li>Record lock：记录锁，单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p>
<p>平时，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p>
<p><strong>那数据库事务有什么作用呢？</strong></p>
<p>简单来说：数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 开启一个事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"># 多条 <span class="keyword">SQL</span> 语句</span><br><span class="line">SQL1,SQL2...</span><br><span class="line">## 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p><strong>数据事务的实现原理：</strong></p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
<h3 id="并发情况下事务存在的问题"><a href="#并发情况下事务存在的问题" class="headerlink" title="并发情况下事务存在的问题"></a>并发情况下事务存在的问题</h3><ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次查询同一条查询语句（DQL）时，记录发现记录增多或减少了</p>
<h3 id="事务的四大隔离级别"><a href="#事务的四大隔离级别" class="headerlink" title="事务的四大隔离级别"></a>事务的四大隔离级别</h3><ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、不可重复读、幻读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是不可重复读和幻读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">REPEATABLE-READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure>

<p>隔离级别越低，事务请求的锁越少，并发情况下性能越高。大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<h1 id="MySQL基本操作"><a href="#MySQL基本操作" class="headerlink" title="MySQL基本操作"></a>MySQL基本操作</h1><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Windows服务 */</span><br><span class="line">-- 启动MySQL</span><br><span class="line">    net start mysql</span><br><span class="line">-- 创建Windows服务</span><br><span class="line">    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line">/* 连接与断开服务器 */</span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line">SHOW PROCESSLIST -- 显示哪些线程正在运行</span><br><span class="line">SHOW VARIABLES -- 显示系统变量信息</span><br></pre></td></tr></table></figure>

<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 数据库操作 */ ------------------</span><br><span class="line">-- 查看当前数据库</span><br><span class="line">    SELECT DATABASE();</span><br><span class="line">-- 显示当前时间、用户名、数据库版本</span><br><span class="line">    SELECT now(), user(), version();</span><br><span class="line">-- 创建库</span><br><span class="line">    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        CHARACTER SET charset_name</span><br><span class="line">        COLLATE collation_name</span><br><span class="line">-- 查看已有库</span><br><span class="line">    SHOW DATABASES[ LIKE &#x27;PATTERN&#x27;]</span><br><span class="line">-- 查看当前库信息</span><br><span class="line">    SHOW CREATE DATABASE 数据库名</span><br><span class="line">-- 修改库的选项信息</span><br><span class="line">    ALTER DATABASE 库名 选项信息</span><br><span class="line">-- 删除库</span><br><span class="line">    DROP DATABASE[ IF EXISTS] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure>

<h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        TEMPORARY 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#x27;string&#x27;]</span><br><span class="line">-- 表选项</span><br><span class="line">    -- 字符集</span><br><span class="line">        CHARSET = charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    -- 存储引擎</span><br><span class="line">        ENGINE = engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive</span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        SHOW ENGINES -- 显示存储引擎的状态信息</span><br><span class="line">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息</span><br><span class="line">    -- 自增起始数</span><br><span class="line">    	AUTO_INCREMENT = 行数</span><br><span class="line">    -- 数据文件目录</span><br><span class="line">        DATA DIRECTORY = &#x27;目录&#x27;</span><br><span class="line">    -- 索引文件目录</span><br><span class="line">        INDEX DIRECTORY = &#x27;目录&#x27;</span><br><span class="line">    -- 表注释</span><br><span class="line">        COMMENT = &#x27;string&#x27;</span><br><span class="line">    -- 分区选项</span><br><span class="line">        PARTITION BY ... (详细见手册)</span><br><span class="line">-- 查看所有表</span><br><span class="line">    SHOW TABLES[ LIKE &#x27;pattern&#x27;]</span><br><span class="line">    SHOW TABLES FROM  库名</span><br><span class="line">-- 查看表结构</span><br><span class="line">    SHOW CREATE TABLE 表名 （信息更详细）</span><br><span class="line">    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#x27;PATTERN&#x27;]</span><br><span class="line">    SHOW TABLE STATUS [FROM db_name] [LIKE &#x27;pattern&#x27;]</span><br><span class="line">-- 修改表</span><br><span class="line">    -- 修改表本身的选项</span><br><span class="line">        ALTER TABLE 表名 表的选项</span><br><span class="line">        eg: ALTER TABLE 表名 ENGINE=MYISAM;</span><br><span class="line">    -- 对表进行重命名</span><br><span class="line">        RENAME TABLE 原表名 TO 新表名</span><br><span class="line">        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        -- RENAME可以交换两个表名</span><br><span class="line">    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span><br><span class="line">        ALTER TABLE 表名 操作名</span><br><span class="line">        -- 操作名</span><br><span class="line">            ADD[ COLUMN] 字段定义       -- 增加字段</span><br><span class="line">                AFTER 字段名          -- 表示增加在该字段名后面</span><br><span class="line">                FIRST               -- 表示增加在第一个</span><br><span class="line">            ADD PRIMARY KEY(字段名)   -- 创建主键</span><br><span class="line">            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引</span><br><span class="line">            ADD INDEX [索引名] (字段名) -- 创建普通索引</span><br><span class="line">            DROP[ COLUMN] 字段名      -- 删除字段</span><br><span class="line">            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">            DROP INDEX 索引名 -- 删除索引</span><br><span class="line">            DROP FOREIGN KEY 外键    -- 删除外键</span><br><span class="line">-- 删除表</span><br><span class="line">    DROP TABLE[ IF EXISTS] 表名 ...</span><br><span class="line">-- 清空表数据</span><br><span class="line">    TRUNCATE [TABLE] 表名</span><br><span class="line">-- 复制表结构</span><br><span class="line">    CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">-- 复制表结构和数据</span><br><span class="line">    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">-- 检查表是否有错误</span><br><span class="line">    CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">-- 优化表</span><br><span class="line">    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">-- 修复表</span><br><span class="line">    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">-- 分析表</span><br><span class="line">    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 数据操作 */ ------------------</span><br><span class="line">-- 增</span><br><span class="line">    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]</span><br><span class="line">-- 查</span><br><span class="line">    SELECT 字段列表 FROM 表名[ 其他子句]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替，表示所有字段</span><br><span class="line">-- 删</span><br><span class="line">    DELETE FROM 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line">-- 改</span><br><span class="line">    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]</span><br></pre></td></tr></table></figure>

<h3 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 字符集编码 */ ------------------</span><br><span class="line">-- MySQL、数据库、表、字段均可设置编码</span><br><span class="line">-- 数据编码与客户端编码不需一致</span><br><span class="line">SHOW VARIABLES LIKE &#x27;character_set_%&#x27;   -- 查看所有字符集编码项</span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line">SET 变量名 = 变量值</span><br><span class="line">    SET character_set_client = gbk;</span><br><span class="line">    SET character_set_results = gbk;</span><br><span class="line">    SET character_set_connection = gbk;</span><br><span class="line">SET NAMES GBK;  -- 相当于完成以上三个设置</span><br><span class="line">-- 校对集</span><br><span class="line">    校对集用以排序</span><br><span class="line">    SHOW CHARACTER SET [LIKE &#x27;pattern&#x27;]/SHOW CHARSET [LIKE &#x27;pattern&#x27;]   查看所有字符集</span><br><span class="line">    SHOW COLLATION [LIKE &#x27;pattern&#x27;]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    COLLATE 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure>

<h3 id="数据类型-列类型"><a href="#数据类型-列类型" class="headerlink" title="数据类型(列类型)"></a>数据类型(列类型)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 数据类型（列类型） */ ------------------</span><br><span class="line">1. 数值类型</span><br><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255</span><br><span class="line">    smallint    2字节    -32768 ~ 32767</span><br><span class="line">    mediumint   3字节    -8388608 ~ 8388607</span><br><span class="line">    int         4字节</span><br><span class="line">    bigint      8字节</span><br><span class="line">    int(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span><br><span class="line">        例：int(5)   插入一个数&#x27;123&#x27;，补填后为&#x27;00123&#x27;</span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    float(单精度)     4字节</span><br><span class="line">    double(双精度)    8字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填0.</span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        float(M, D)     double(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span><br><span class="line">2. 字符串类型</span><br><span class="line">-- a. char, varchar ----------</span><br><span class="line">    char    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    char,最多255个字符，与编码无关。</span><br><span class="line">    varchar,最多65535字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过65535个字节。</span><br><span class="line">        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2=65532字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3</span><br><span class="line">-- b. blob, text ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line">-- c. binary, varbinary ----------</span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br><span class="line">3. 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line">year        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line">4. 枚举和集合</span><br><span class="line">-- 枚举(enum) ----------</span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line">-- 集合（set） ----------</span><br><span class="line">set(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender set(&#x27;男&#x27;, &#x27;女&#x27;, &#x27;无&#x27;) );</span><br><span class="line">    insert into tab values (&#x27;男, 女&#x27;);</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure>

<h3 id="列属性-列约束"><a href="#列属性-列约束" class="headerlink" title="列属性(列约束)"></a>列属性(列约束)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 列属性（列约束） */ ------------------</span><br><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：create table tab ( id int, stu varchar(10), primary key (id));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    insert into tab values (null, &#x27;val&#x27;);</span><br><span class="line">        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    insert into tab values (default, &#x27;val&#x27;);    -- 此时表示强制使用默认值。</span><br><span class="line">    create table tab ( add_time timestamp default current_timestamp );</span><br><span class="line">        -- 表示将当前时间的时间戳设为默认值。</span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;</span><br><span class="line">6. COMMENT 注释</span><br><span class="line">    例：create table tab ( id int ) comment &#x27;注释内容&#x27;;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);</span><br><span class="line">        -- 将表t1的t1_id外键关联到表t2的id字段。</span><br><span class="line">        -- 每个外键都有一个名字，可以通过 constraint 指定</span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</span><br><span class="line">    3. restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure>

<h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 建表规范 */ ------------------</span><br><span class="line">    -- Normal Format, NF</span><br><span class="line">        - 每个表保存一个实体信息</span><br><span class="line">        - 每个具有一个ID字段作为主键</span><br><span class="line">        - ID主键 + 原子表</span><br><span class="line">    -- 1NF, 第一范式</span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    -- 2NF, 第二范式</span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除复合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    -- 3NF, 第三范式</span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure>

<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* SELECT */ ------------------</span><br><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * from tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() from tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 from tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * FROM tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- from子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * FROM tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;</span><br><span class="line">        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从from获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is/is not 加上ture/false/unknown，检验某个值的真假</span><br><span class="line">            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段/别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure>

<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* UNION */ ------------------</span><br><span class="line">    将多个select查询的结果组合成一个结果集合。</span><br><span class="line">    SELECT ... UNION [ALL|DISTINCT] SELECT ...</span><br><span class="line">    默认 DISTINCT 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个SELECT查询加上小括号包裹。</span><br><span class="line">    ORDER BY 排序时，需加上 LIMIT 进行结合。</span><br><span class="line">    需要各select查询的字段数量一样。</span><br><span class="line">    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</span><br></pre></td></tr></table></figure>

<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 子查询 */ ------------------</span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line">-- from型</span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;</span><br><span class="line">-- where型</span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    select * from tb where money = (select max(money) from tb);</span><br><span class="line">    -- 列子查询</span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            select column1 from t1 where exists (select * from t2);</span><br><span class="line">    -- 行子查询</span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * from t1 where (id, gender) in (select id, gender from t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    -- 特殊运算符</span><br><span class="line">    != all()    相当于 not in</span><br><span class="line">    = some()    相当于 in。any 是 some 的别名</span><br><span class="line">    != some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure>

<h3 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 连接查询(join) */ ------------------</span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner join)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    -- 交叉连接 cross join</span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        select * from tb1 cross join tb2;</span><br><span class="line">-- 外连接(outer join)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left join</span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    -- 右外连接 right join</span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line">-- 自然连接(natural join)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line">select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;</span><br></pre></td></tr></table></figure>

<h3 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* TRUNCATE */ ------------------</span><br><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line">1，truncate 是删除表再创建，delete 是逐条删除</span><br><span class="line">2，truncate 重置auto_increment的值。而delete不会</span><br><span class="line">3，truncate 不知道删除了几条，而delete知道。</span><br><span class="line">4，当被用于带分区的表时，truncate 会保留分区</span><br></pre></td></tr></table></figure>

<h3 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 备份与还原 */ ------------------</span><br><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line">-- 导出</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] ---database DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [options] --all--database</span><br><span class="line">1. 导出一张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</span><br><span class="line">2. 导出多张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)</span><br><span class="line">3. 导出所有表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">4. 导出一个库</span><br><span class="line">　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">可以-w携带WHERE条件</span><br><span class="line">-- 导入</span><br><span class="line">1. 在登录mysql的情况下：</span><br><span class="line">　　source  备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure>

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line">-- 创建视图</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于SELECT语句检索的列数</span><br><span class="line">-- 查看结构</span><br><span class="line">    SHOW CREATE VIEW view_name</span><br><span class="line">-- 删除视图</span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    DROP VIEW [IF EXISTS] view_name ...</span><br><span class="line">-- 修改视图结构</span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    ALTER VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">-- 视图作用</span><br><span class="line">    1. 简化业务逻辑</span><br><span class="line">    2. 对客户端隐藏真实的表结构</span><br><span class="line">-- 视图算法(ALGORITHM)</span><br><span class="line">    MERGE       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure>

<h3 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据完整性方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line">-- 事务开启</span><br><span class="line">    START TRANSACTION; 或者 BEGIN;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line">-- 事务提交</span><br><span class="line">    COMMIT;</span><br><span class="line">-- 事务回滚</span><br><span class="line">    ROLLBACK;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line">-- 事务的特性</span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line">-- 事务的实现</span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line">-- 事务的原理</span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</span><br><span class="line">-- 注意</span><br><span class="line">    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    2. 事务不能被嵌套</span><br><span class="line">-- 保存点</span><br><span class="line">    SAVEPOINT 保存点名称 -- 设置一个事务保存点</span><br><span class="line">    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点</span><br><span class="line">    RELEASE SAVEPOINT 保存点名称 -- 删除保存点</span><br><span class="line">-- InnoDB自动提交特性设置</span><br><span class="line">    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，</span><br><span class="line">        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure>

<h3 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 锁表 */</span><br><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line">-- 锁定</span><br><span class="line">    LOCK TABLES tbl_name [AS alias]</span><br><span class="line">-- 解锁</span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure>

<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 触发器 */ ------------------</span><br><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        INSERT：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        DELETE：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [schema_name.]trigger_name</span><br><span class="line">可以使用old和new代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是old，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line">-- 注意</span><br><span class="line">    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line">-- 字符连接函数</span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line">-- 分支语句</span><br><span class="line">if 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">else</span><br><span class="line">    执行语句</span><br><span class="line">end if;</span><br><span class="line">-- 修改最外层语句结束符</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     -- 修改回原来的分号</span><br><span class="line">-- 语句块包裹</span><br><span class="line">begin</span><br><span class="line">    语句块</span><br><span class="line">end</span><br><span class="line">-- 特殊的执行</span><br><span class="line">1. 只要添加记录，就会触发程序。</span><br><span class="line">2. Insert into on duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before insert, after insert;</span><br><span class="line">    如果有重复记录并更新，会触发 before insert, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before insert, before update</span><br><span class="line">3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</span><br></pre></td></tr></table></figure>

<h3 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* SQL编程 */ ------------------</span><br><span class="line">--// 局部变量 ----------</span><br><span class="line">-- 变量声明</span><br><span class="line">    declare var_name[,...] type [default value]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</span><br><span class="line">-- 赋值</span><br><span class="line">    使用 set 和 select into 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line">--// 全局变量 ----------</span><br><span class="line">-- 定义、赋值</span><br><span class="line">set 语句可以定义并为变量赋值。</span><br><span class="line">set @var = value;</span><br><span class="line">也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。</span><br><span class="line">select @var:=20;</span><br><span class="line">select @v1:=id, @v2=name from t1 limit 1;</span><br><span class="line">select * from tbl_name where @var:=30;</span><br><span class="line">select into 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| select max(height) into @max_height from tb;</span><br><span class="line">-- 自定义变量名</span><br><span class="line">为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@var=10;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line">--// 控制结构 ----------</span><br><span class="line">-- if语句</span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line">end if;</span><br><span class="line">-- case语句</span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line">END</span><br><span class="line">-- while循环</span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line">end while [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    -- 退出循环</span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line">--// 内置函数 ----------</span><br><span class="line">-- 数值函数</span><br><span class="line">abs(x)          -- 绝对值 abs(-10.9) = 10</span><br><span class="line">format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span><br><span class="line">ceil(x)         -- 向上取整 ceil(10.1) = 11</span><br><span class="line">floor(x)        -- 向下取整 floor (10.1) = 10</span><br><span class="line">round(x)        -- 四舍五入去整</span><br><span class="line">mod(m, n)       -- m%n m mod n 求余 10%3=1</span><br><span class="line">pi()            -- 获得圆周率</span><br><span class="line">pow(m, n)       -- m^n</span><br><span class="line">sqrt(x)         -- 算术平方根</span><br><span class="line">rand()          -- 随机数</span><br><span class="line">truncate(x, d)  -- 截取d位小数</span><br><span class="line">-- 时间日期函数</span><br><span class="line">now(), current_timestamp();     -- 当前日期时间</span><br><span class="line">current_date();                 -- 当前日期</span><br><span class="line">current_time();                 -- 当前时间</span><br><span class="line">date(&#x27;yyyy-mm-dd hh:ii:ss&#x27;);    -- 获取日期部分</span><br><span class="line">time(&#x27;yyyy-mm-dd hh:ii:ss&#x27;);    -- 获取时间部分</span><br><span class="line">date_format(&#x27;yyyy-mm-dd hh:ii:ss&#x27;, &#x27;%d %y %a %d %m %b %j&#x27;); -- 格式化时间</span><br><span class="line">unix_timestamp();               -- 获得unix时间戳</span><br><span class="line">from_unixtime();                -- 从时间戳获得时间</span><br><span class="line">-- 字符串函数</span><br><span class="line">length(string)          -- string长度，字节</span><br><span class="line">char_length(string)     -- string的字符个数</span><br><span class="line">substring(str, position [,length])      -- 从str的position开始,取length个字符</span><br><span class="line">replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str</span><br><span class="line">instr(string ,substring)    -- 返回substring首次在string中出现的位置</span><br><span class="line">concat(string [,...])   -- 连接字串</span><br><span class="line">charset(str)            -- 返回字串字符集</span><br><span class="line">lcase(string)           -- 转换成小写</span><br><span class="line">left(string, length)    -- 从string2中的左边起取length个字符</span><br><span class="line">load_file(file_name)    -- 从文件读取内容</span><br><span class="line">locate(substring, string [,start_position]) -- 同instr,但可指定开始位置</span><br><span class="line">lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length</span><br><span class="line">ltrim(string)           -- 去除前端空格</span><br><span class="line">repeat(string, count)   -- 重复count次</span><br><span class="line">rpad(string, length, pad)   --在str后用pad补充,直到长度为length</span><br><span class="line">rtrim(string)           -- 去除后端空格</span><br><span class="line">strcmp(string1 ,string2)    -- 逐字符比较两字串大小</span><br><span class="line">-- 流程函数</span><br><span class="line">case when [condition] then result [when [condition] then result ...] [else result] end   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line">-- 聚合函数</span><br><span class="line">count()</span><br><span class="line">sum();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line">-- 其他常用函数</span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line">--// 存储函数，自定义函数 ----------</span><br><span class="line">-- 新建</span><br><span class="line">    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 return 返回值语句。</span><br><span class="line">-- 删除</span><br><span class="line">    DROP FUNCTION [IF EXISTS] function_name;</span><br><span class="line">-- 查看</span><br><span class="line">    SHOW FUNCTION STATUS LIKE &#x27;partten&#x27;</span><br><span class="line">    SHOW CREATE FUNCTION function_name;</span><br><span class="line">-- 修改</span><br><span class="line">    ALTER FUNCTION function_name 函数选项</span><br><span class="line">--// 存储过程，自定义功能 ----------</span><br><span class="line">-- 定义</span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的sql组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</span><br><span class="line">-- 创建</span><br><span class="line">CREATE PROCEDURE sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line">IN，表示输入型</span><br><span class="line">OUT，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 存储过程 */ ------------------</span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：CALL 过程名</span><br><span class="line">-- 注意</span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line">-- 参数</span><br><span class="line">IN|OUT|INOUT 参数名 数据类型</span><br><span class="line">IN      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line">OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line">-- 语法</span><br><span class="line">CREATE PROCEDURE 过程名 (参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">    过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 用户和权限管理 */ ------------------</span><br><span class="line">-- root密码重置</span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;</span><br><span class="line">    [Windows] mysqld --skip-grant-tables</span><br><span class="line">3. use mysql;</span><br><span class="line">4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;</span><br><span class="line">5. FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">-- 增加用户</span><br><span class="line">CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 &#x27;user_name&#x27;@&#x27;192.168.1.1&#x27;</span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line">-- 重命名用户</span><br><span class="line">RENAME USER old_user TO new_user</span><br><span class="line">-- 设置密码</span><br><span class="line">SET PASSWORD = PASSWORD(&#x27;密码&#x27;)  -- 为当前用户设置密码</span><br><span class="line">SET PASSWORD FOR 用户名 = PASSWORD(&#x27;密码&#x27;) -- 为指定用户设置密码</span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER 用户名</span><br><span class="line">-- 分配权限/添加用户</span><br><span class="line">GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;]</span><br><span class="line">    - all privileges 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    GRANT ALL PRIVILEGES ON `pms`.* TO &#x27;pms&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;pms0817&#x27;;</span><br><span class="line">-- 查看权限</span><br><span class="line">SHOW GRANTS FOR 用户名</span><br><span class="line">    -- 查看当前用户权限</span><br><span class="line">    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();</span><br><span class="line">-- 撤消权限</span><br><span class="line">REVOKE 权限列表 ON 表名 FROM 用户名</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限</span><br><span class="line">-- 权限层级</span><br><span class="line">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用REVOKE时，您必须指定与被授权列相同的列。</span><br><span class="line">-- 权限列表</span><br><span class="line">ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限</span><br><span class="line">ALTER   -- 允许使用ALTER TABLE</span><br><span class="line">ALTER ROUTINE   -- 更改或取消已存储的子程序</span><br><span class="line">CREATE  -- 允许使用CREATE TABLE</span><br><span class="line">CREATE ROUTINE  -- 创建已存储的子程序</span><br><span class="line">CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE</span><br><span class="line">CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span><br><span class="line">CREATE VIEW     -- 允许使用CREATE VIEW</span><br><span class="line">DELETE  -- 允许使用DELETE</span><br><span class="line">DROP    -- 允许使用DROP TABLE</span><br><span class="line">EXECUTE     -- 允许用户运行已存储的子程序</span><br><span class="line">FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span><br><span class="line">INDEX   -- 允许使用CREATE INDEX和DROP INDEX</span><br><span class="line">INSERT  -- 允许使用INSERT</span><br><span class="line">LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES</span><br><span class="line">PROCESS     -- 允许使用SHOW FULL PROCESSLIST</span><br><span class="line">REFERENCES  -- 未被实施</span><br><span class="line">RELOAD  -- 允许使用FLUSH</span><br><span class="line">REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址</span><br><span class="line">REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span><br><span class="line">SELECT  -- 允许使用SELECT</span><br><span class="line">SHOW DATABASES  -- 显示所有数据库</span><br><span class="line">SHOW VIEW   -- 允许使用SHOW CREATE VIEW</span><br><span class="line">SHUTDOWN    -- 允许使用mysqladmin shutdown</span><br><span class="line">SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span><br><span class="line">UPDATE  -- 允许使用UPDATE</span><br><span class="line">USAGE   -- “无权限”的同义词</span><br><span class="line">GRANT OPTION    -- 允许授予权限</span><br></pre></td></tr></table></figure>

<h3 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 表维护 */</span><br><span class="line">-- 分析和存储表的关键字分布</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...</span><br><span class="line">-- 检查一个或多个表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br><span class="line">-- 整理数据文件的碎片</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 杂项 */ ------------------</span><br><span class="line">1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 /* 注释内容 */</span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 \&#x27;</span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line">6. SQL对大小写不敏感</span><br><span class="line">7. 清除已有语句：\c</span><br></pre></td></tr></table></figure>

<h1 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h1><h2 id="MySQL-索引详解"><a href="#MySQL-索引详解" class="headerlink" title="MySQL 索引详解"></a>MySQL 索引详解</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure>

<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p>既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p>
<p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
<p>试想一种情况:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb1 WHERE id &lt; <span class="number">500</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B树和B+树的区别</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h4><p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<h4 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h4><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><p><strong>聚集索引</strong></p>
<p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p><strong>聚集索引的优点</strong>：</p>
<p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p><strong>聚集索引的缺点：</strong></p>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<p><strong>非聚集索引</strong></p>
<p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<blockquote>
<p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
</blockquote>
<p><strong>非聚集索引的优点</strong></p>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p><strong>非聚集索引的缺点</strong></p>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<p>非聚集索引不一定需要回表查询：</p>
<blockquote>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name FROM table WHERE name=&#x27;guang19&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
</blockquote>
<p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id FROM table WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<h3 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h3><p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h3 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h3><ul>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li>
<li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ul>
<h3 id="MySQL-如何为表字段添加索引？"><a href="#MySQL-如何为表字段添加索引？" class="headerlink" title="MySQL 如何为表字段添加索引？"></a>MySQL 如何为表字段添加索引？</h3><p>1.添加 PRIMARY KEY（主键索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY ( `<span class="keyword">column</span>` )</span><br></pre></td></tr></table></figure>

<p>2.添加 UNIQUE(唯一索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD UNIQUE ( `column` )</span><br></pre></td></tr></table></figure>

<p>3.添加 INDEX(普通索引)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `<span class="keyword">column</span>` )</span><br></pre></td></tr></table></figure>

<p>4.添加 FULLTEXT(全文索引)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> FULLTEXT ( `<span class="keyword">column</span>`)</span><br></pre></td></tr></table></figure>

<p>5.添加多列索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` )</span><br></pre></td></tr></table></figure>

<h2 id="MySQL-三大日志）"><a href="#MySQL-三大日志）" class="headerlink" title="MySQL 三大日志）"></a>MySQL 三大日志）</h2><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p>![redo log](MySQL知识点总结/redo log.png)</p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p>![redo log原理](MySQL知识点总结/redo log原理.png)</p>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<blockquote>
<p>每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA.png" alt="刷盘时机"></p>
<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p>
<p><strong>为什么呢？</strong></p>
<p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5.png" alt="刷盘策略"></p>
<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p>
<p>下面是不同刷盘策略的流程图。</p>
<p><strong>innodb_flush_log_at_trx_commit=0</strong></p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/myBlog\source_posts\MySQL知识点总结\刷盘策略流程图0.png" alt="刷盘策略流程图0"></p>
<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>
<p> <strong>innodb_flush_log_at_trx_commit=1</strong></p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/myBlog\source_posts\MySQL知识点总结\刷盘策略流程图1.png" alt="刷盘策略流程图1"></p>
<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</p>
<p> innodb_flush_log_at_trx_commit=2</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/myBlog\source_posts\MySQL知识点总结\刷盘策略流程图2.png" alt="刷盘策略流程图2"></p>
<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>
<h4 id="文件日志组"><a href="#文件日志组" class="headerlink" title="文件日志组"></a>文件日志组</h4><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>
<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>
<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E6%96%87%E4%BB%B6%E6%97%A5%E5%BF%97%E7%BB%84.png" alt="文件日志组"></p>
<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>
<ul>
<li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p>
<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>
<p>![write pos 和checkpoint](MySQL知识点总结/write pos 和checkpoint.png)</p>
<p><strong>redo log小结</strong></p>
<p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p>直接刷盘数据页和利用redo log刷盘的差别：</p>
<p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<blockquote>
<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并。</p>
</blockquote>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p><strong>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</strong></p>
<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/binlog.png" alt="binlog"></p>
<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h4 id="binlog记录格式"><a href="#binlog记录格式" class="headerlink" title="binlog记录格式"></a>binlog记录格式</h4><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/statement.png" alt="statement"></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/row.png" alt="row"></p>
<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>
<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>
<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>
<p><code>binlog</code>日志刷盘流程如下</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/binlog%E5%88%B7%E7%9B%98%E6%B5%81%E7%A8%8B.png" alt="binlog刷盘流程"></p>
<ul>
<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>
<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/sync_binlog=0.png" alt="sync_binlog=0"></p>
<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p>
<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>binlog 日志刷盘流程</strong>一样。</p>
<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/sync_binlog=N.png" alt="sync_binlog=N"></p>
<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>
<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p>![redo log 和binlog](MySQL知识点总结/redo log 和binlog.png)</p>
<p><code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>
<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>
<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/binlog%E5%86%99%E5%85%A5%E5%BC%82%E5%B8%B8.png" alt="binlog写入异常"></p>
<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>
<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/InnoDB%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" alt="InnoDB两阶段提交"></p>
<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" alt="两阶段提交"></p>
<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/commit%E9%98%B6%E6%AE%B5%E5%BC%82%E5%B8%B8.png" alt="commit阶段异常"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，<strong>所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。</strong>如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p>原文链接：<a href="https://javaguide.cn/database/mysql/mysql-logs.html">https://javaguide.cn/database/mysql/mysql-logs.html</a></p>
<h2 id="InnoDB存储引擎对MVCC的实现"><a href="#InnoDB存储引擎对MVCC的实现" class="headerlink" title="InnoDB存储引擎对MVCC的实现"></a>InnoDB存储引擎对MVCC的实现</h2><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html"><strong>一致性非锁定读（Consistent Nonlocking Reads）</strong></a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p>
<p>在 <code>InnoDB</code> 存储引擎中，<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">多版本控制 (multi versioning)</a> 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它<strong>快照读</strong> (snapshot read)</p>
<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读</p>
<h3 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h3><p>如果执行的是下列语句，就是 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html"><strong>锁定读（Locking Reads）</strong></a></p>
<ul>
<li><code>select ... lock in share mode</code></li>
<li><code>select ... for update</code></li>
<li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li>
</ul>
<p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <strong>当前读（current read</strong>）。锁定读会对读取到的记录加锁：</p>
<ul>
<li><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li>
<li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li>
</ul>
<p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p>
<h3 id="InnoDB-对-MVCC-的实现"><a href="#InnoDB-对-MVCC-的实现" class="headerlink" title="InnoDB 对 MVCC 的实现"></a>InnoDB 对 MVCC 的实现</h3><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">隐藏字段</a>：</p>
<ul>
<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li>
<li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li>
<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li>
</ul>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">trx_id_t</span> m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">trx_id_t</span> m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">trx_id_t</span> m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">trx_id_t</span> m_low_limit_no;      <span class="comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">ids_t</span> m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class="line"></span><br><span class="line">  m_closed;                     <span class="comment">/* 标记 Read View 是否 close */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298"><code>Read View</code></a> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</strong></p>
<p>主要有以下字段：</p>
<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
<p>事务可见性示意图</p>
<p><img src="/2021/05/07/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt="事务可见性"></p>
<h4 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo-log"></a>undo-log</h4><p><code>undo log</code> 主要有两个作用：</p>
<ul>
<li><strong>当事务回滚时用于将数据恢复到修改前的样子</strong></li>
<li><strong>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</strong></li>
</ul>
<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>
<ol>
<li><p><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</p>
</li>
<li><p><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</p>
</li>
</ol>
<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p>
<h4 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h4><p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>
<ol>
<li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li>
<li>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li>
<li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</li>
<li>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）<ul>
<li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li>
<li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li>
</ul>
</li>
<li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> </li>
</ol>
<h3 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h3><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>
</ul>
<p><strong>MVCC 解决不可重复读问题</strong></p>
<p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于 <strong>生成 Read View 时机不同</strong>，从而在 RR 级别下实现可重复读</p>
<h3 id="MVCC➕Next-key-Lock-防止幻读"><a href="#MVCC➕Next-key-Lock-防止幻读" class="headerlink" title="MVCC➕Next-key-Lock 防止幻读"></a>MVCC➕Next-key-Lock 防止幻读</h3><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>
<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p><strong>2、执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MysSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>谷粒商城-分布式基础篇</title>
    <url>/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1. 整体介绍"></a>1. 整体介绍</h2><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200422211607028.png" alt="image-20200422211607028"></p>
<h3 id="1）安装vagrant"><a href="#1）安装vagrant" class="headerlink" title="1）安装vagrant"></a>1）安装vagrant</h3><h3 id="2）安装Centos7"><a href="#2）安装Centos7" class="headerlink" title="2）安装Centos7"></a>2）安装Centos7</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant init centos/7</span></span><br><span class="line">A `Vagrantfile` has been placed in this directory. You are now</span><br><span class="line">ready to `vagrant up` your first virtual environment! Please read</span><br><span class="line">the comments in the Vagrantfile as well as documentation on</span><br><span class="line">`vagrantup.com` for more information on using Vagrant.</span><br></pre></td></tr></table></figure>

<p>执行完上面的命令后，会在用户的家目录下生成Vagrantfile文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant up</span></span><br><span class="line">Bringing machine &#x27;default&#x27; up with &#x27;virtualbox&#x27; provider...</span><br><span class="line">==&gt; default: Box &#x27;centos/7&#x27; could not be found. Attempting to find and install...</span><br><span class="line">    default: Box Provider: virtualbox</span><br><span class="line">    default: Box Version: &gt;= 0</span><br><span class="line">==&gt; default: Loading metadata for box &#x27;centos/7&#x27;</span><br><span class="line">    default: URL: https://vagrantcloud.com/centos/7</span><br><span class="line">==&gt; default: Adding box &#x27;centos/7&#x27; (v1905.1) for provider: virtualbox</span><br><span class="line">    default: Downloading: https://vagrantcloud.com/centos/boxes/7/versions/1905.1/providers/virtualbox.box</span><br><span class="line">    default: Download redirected to host: cloud.centos.org</span><br><span class="line">    default: Progress: 0% (Rate: 6717/s, Estimated time remaining: 7:33:42)</span><br></pre></td></tr></table></figure>

<p>下载镜像过程比较漫长，也可以采用先用下载工具下载到本地后，然后使用“ vagrant box add ”添加，再“vagrant up”即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将下载的镜像添加到virtualBox中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vagrant box add centos/7 E:\迅雷下载\CentOS-7-x86_64-Vagrant-1905_01.VirtualBox.box</span></span><br><span class="line">==&gt; box: Box file was not detected as metadata. Adding it directly...</span><br><span class="line">==&gt; box: Adding box &#x27;centos/7&#x27; (v0) for provider:</span><br><span class="line">    box: Unpacking necessary files from: file:///E:/%D1%B8%C0%D7%CF%C2%D4%D8/CentOS-7-x86_64-Vagrant-1905_01.VirtualBox.box</span><br><span class="line">    box:</span><br><span class="line">==&gt; box: Successfully added box &#x27;centos/7&#x27; (v0) for &#x27;virtualbox&#x27;!</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vagrant up</span></span><br><span class="line">Bringing machine &#x27;default&#x27; up with &#x27;virtualbox&#x27; provider...</span><br><span class="line">==&gt; default: Importing base box &#x27;centos/7&#x27;...</span><br><span class="line">==&gt; default: Matching MAC address for NAT networking...</span><br><span class="line">==&gt; default: Setting the name of the VM: Administrator_default_1588497928070_24634</span><br><span class="line">==&gt; default: Clearing any previously set network interfaces...</span><br><span class="line">==&gt; default: Preparing network interfaces based on configuration...</span><br><span class="line">    default: Adapter 1: nat</span><br><span class="line">    default: Adapter 2: hostonly</span><br><span class="line">==&gt; default: Forwarding ports...</span><br><span class="line">    default: 22 (guest) =&gt; 2222 (host) (adapter 1)</span><br><span class="line">==&gt; default: Booting VM...</span><br><span class="line">==&gt; default: Waiting for machine to boot. This may take a few minutes...</span><br><span class="line">    default: SSH address: 127.0.0.1:2222</span><br><span class="line">    default: SSH username: vagrant</span><br><span class="line">    default: SSH auth method: private key</span><br><span class="line">    default:</span><br><span class="line">    default: Vagrant insecure key detected. Vagrant will automatically replace</span><br><span class="line">    default: this with a newly generated keypair for better security.</span><br><span class="line">    default:</span><br><span class="line">    default: Inserting generated public key within guest...</span><br><span class="line">    default: Removing insecure key from the guest if it&#x27;s present...</span><br><span class="line">    default: Key inserted! Disconnecting and reconnecting using new SSH key...</span><br><span class="line">==&gt; default: Machine booted and ready!</span><br><span class="line">==&gt; default: Checking for guest additions in VM...</span><br><span class="line">    default: No guest additions were detected on the base box for this VM! Guest</span><br><span class="line">    default: additions are required for forwarded ports, shared folders, host only</span><br><span class="line">    default: networking, and more. If SSH fails on this machine, please install</span><br><span class="line">    default: the guest additions and repackage the box to continue.</span><br><span class="line">    default:</span><br><span class="line">    default: This is not an error message; everything may continue to work properly,</span><br><span class="line">    default: in which case you may ignore this message.</span><br><span class="line">==&gt; default: Configuring and enabling network interfaces...</span><br><span class="line">==&gt; default: Rsyncing folder: /cygdrive/c/Users/Administrator/ =&gt; /vagrant</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>vagrant ssh 开启SSH，并登陆到centos7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant ssh</span></span><br><span class="line">[vagrant@localhost ~]$ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0</span><br><span class="line">       valid_lft 86091sec preferred_lft 86091sec</span><br><span class="line">    inet6 fe80::5054:ff:fe8a:fee6/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:d1:76:f6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.56.102/24 brd 192.168.56.255 scope global noprefixroute dynamic eth1</span><br><span class="line">       valid_lft 892sec preferred_lft 892sec</span><br><span class="line">    inet6 fe80::8c94:1942:ba09:2458/64 scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[vagrant@localhost ~]$</span><br></pre></td></tr></table></figure>









<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ipconfig</span><br><span class="line"></span><br><span class="line">Windows IP 配置</span><br><span class="line"></span><br><span class="line">以太网适配器 VirtualBox Host-Only Network:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::a00c:1ffa:a39a:c8c2%16</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 192.168.56.1</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></table></figure>







<p>配置网络信息，打开”Vagrantfile”文件：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">config<span class="selector-class">.vm</span><span class="selector-class">.network</span> <span class="string">&quot;private_network&quot;</span>, ip: <span class="string">&quot;192.168.56.10&quot;</span></span><br></pre></td></tr></table></figure>



<p>修改完成后，重启启动vagrant</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vagrant reload</span></span><br></pre></td></tr></table></figure>

<p>检查宿主机和virtualBox之间的通信是否正常</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[vagrant@localhost ~]$<span class="built_in"> ping </span>192.168.43.43                                                                                                        <span class="built_in"> PING </span>192.168.43.43 (192.168.43.43) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.43.43: <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=127 <span class="attribute">time</span>=0.533 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 192.168.43.43: <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=127 <span class="attribute">time</span>=0.659 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.43.43<span class="built_in"> ping </span>statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.533/0.596/0.659/0.063 ms</span><br><span class="line">[vagrant@localhost ~]$</span><br><span class="line">[vagrant@localhost ~]$</span><br><span class="line">[vagrant@localhost ~]$<span class="built_in"> ping </span>www.baidu.com<span class="built_in"></span></span><br><span class="line"><span class="built_in">PING </span>www.a.shifen.com (112.80.248.76) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 112.80.248.76 (112.80.248.76): <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=53 <span class="attribute">time</span>=56.1 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 112.80.248.76 (112.80.248.76): <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=53 <span class="attribute">time</span>=58.5 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 112.80.248.76 (112.80.248.76): <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=53 <span class="attribute">time</span>=53.4 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启远程登陆，修改“/etc/ssh/sshd_config”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes </span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>

<p>然后重启SSHD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<p>使用Xshell或SecureCRT进行远程连接。</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200503174735162.png" alt="image-20200503174735162"></p>
<h2 id="2-docker中安装mysql"><a href="#2-docker中安装mysql" class="headerlink" title="2. docker中安装mysql"></a>2. docker中安装mysql</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop-104 module]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">123275d6e508: Already exists </span><br><span class="line">27cddf5c7140: Pull complete </span><br><span class="line">c17d442e14c9: Pull complete </span><br><span class="line">2eb72ffed068: Pull complete </span><br><span class="line">d4aa125eb616: Pull complete </span><br><span class="line">52560afb169c: Pull complete </span><br><span class="line">68190f37a1d2: Pull complete </span><br><span class="line">3fd1dc6e2990: Pull complete </span><br><span class="line">85a79b83df29: Pull complete </span><br><span class="line">35e0b437fe88: Pull complete </span><br><span class="line">992f6a10268c: Pull complete </span><br><span class="line">Digest: sha256:82b72085b2fcff073a6616b84c7c3bcbb36e2d13af838cec11a9ed1d0b183f5e</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>

<p>查看镜像</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">[root@hadoop<span class="number">-104</span> <span class="built_in">module</span>]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY  TAG    IMAGE ID     CREATED       SIZE</span><br><span class="line">mysql       <span class="number">5.7</span>    f5829c0eee9e <span class="number">2</span> hours ago   <span class="number">455</span>MB</span><br><span class="line">[root@hadoop<span class="number">-104</span> <span class="built_in">module</span>]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>启动mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>修改配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">[root@hadoop-104</span> <span class="string">conf]# pwd</span></span><br><span class="line"><span class="attr">/mydata/mysql/conf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">[root@hadoop-104</span> <span class="string">conf]# cat my.cnf</span></span><br><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="meta">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span></span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">&#x27;SET NAMES utf8&#x27;</span></span><br><span class="line"><span class="meta">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="meta">collation-server</span>=<span class="string">utf8_unicode_ci</span></span><br><span class="line"><span class="attr">skip-character-set-client-handshake</span></span><br><span class="line"><span class="attr">skip-name-resolve</span></span><br><span class="line"><span class="meta">[root@hadoop-104</span> <span class="string">conf]# </span></span><br><span class="line"></span><br><span class="line"><span class="meta">[root@hadoop-104</span> <span class="string">conf]# docker restart mysql</span></span><br><span class="line"><span class="attr">mysql</span></span><br><span class="line"><span class="meta">[root@hadoop-104</span> <span class="string">conf]# </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>进入容器查看配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop-104 conf]# docker exec -it mysql /bin/bash</span><br><span class="line">root@b3a74e031bd7:/# whereis mysql</span><br><span class="line">mysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql</span><br><span class="line"></span><br><span class="line">root@b3a74e031bd7:/# ls /etc/mysql </span><br><span class="line">my.cnf</span><br><span class="line">root@b3a74e031bd7:/# cat /etc/mysql/my.cnf </span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br><span class="line">root@b3a74e031bd7:/# </span><br></pre></td></tr></table></figure>



<p>设置启动docker时，即运行mysql</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@hadoop</span><span class="number">-104</span> ~]<span class="meta"># docker update mysql --restart=always</span></span><br><span class="line">mysql</span><br><span class="line">[root<span class="symbol">@hadoop</span><span class="number">-104</span> ~]<span class="meta"># </span></span><br></pre></td></tr></table></figure>



<h2 id="3-docker中安装redis"><a href="#3-docker中安装redis" class="headerlink" title="3. docker中安装redis"></a>3. docker中安装redis</h2><p>下载docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop-104 ~]# docker pull redis</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">123275d6e508: Already exists </span><br><span class="line">f2edbd6a658e: Pull complete </span><br><span class="line">66960bede47c: Pull complete </span><br><span class="line">79dc0b596c90: Pull complete </span><br><span class="line">de36df38e0b6: Pull complete </span><br><span class="line">602cd484ff92: Pull complete </span><br><span class="line">Digest: sha256:1d0b903e3770c2c3c79961b73a53e963f4fd4b2674c2c4911472e8a054cb5728</span><br><span class="line">Status: Downloaded newer image for redis:latest</span><br><span class="line">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>



<p>启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop-104 ~]# mkdir -p /mydata/redis/conf</span><br><span class="line">[root@hadoop-104 ~]# touch /mydata/redis/conf/redis.conf</span><br><span class="line">[root@hadoop-104 ~]# echo &quot;appendonly yes&quot;  &gt;&gt; /mydata/redis/conf/redis.conf</span><br><span class="line">[root@hadoop-104 ~]# docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span></span><br><span class="line"><span class="bash">&gt; -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line">ce7ae709711986e3f90c9278b284fe6f51f1c1102ba05f3692f0e934ceca1565</span><br><span class="line">[root@hadoop-104 ~]# </span><br></pre></td></tr></table></figure>

<p> 连接到docker的redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop-104 ~]# docker exec -it redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set key1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>设置redis容器在docker启动的时候启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop-104 ~]# docker update redis --restart=always</span><br><span class="line">redis</span><br><span class="line">[root@hadoop-104 ~]# </span><br></pre></td></tr></table></figure>



<h2 id="4-创建maven工程"><a href="#4-创建maven工程" class="headerlink" title="4. 创建maven工程"></a>4. 创建maven工程</h2><h2 id="5-执行sql脚本"><a href="#5-执行sql脚本" class="headerlink" title="5. 执行sql脚本"></a>5. 执行sql脚本</h2><p>gulimall_oms.sql<br>gulimall_pms.sql<br>gulimall_sms.sql<br>gulimall_ums.sql<br>gulimall_wms.sql<br>pms_catelog.sql<br>sys_menus.sql</p>
<h2 id="6-clone-人人开源"><a href="#6-clone-人人开源" class="headerlink" title="6. clone 人人开源"></a>6. clone 人人开源</h2><p><a href="https://gitee.com/renrenio">https://gitee.com/renrenio</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587609877028.png" alt="1587609877028"></p>
<p>克隆到本地：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/renrenio/renren-fast-vue.git</span><br><span class="line"></span><br><span class="line">git clone https://gitee.com/renrenio/renren-fast.git</span><br></pre></td></tr></table></figure>



<p>将拷贝下来的“renren-fast”删除“.git”后，拷贝到“gulimall”工程根目录下，然后将它作为gulimall的一个module</p>
<p>创建“gulimall_admin”的数据库，然后执行“renren-fast/db/mysql.sql”中的SQl脚本</p>
<p>修改“application-dev.yml”文件，默认为dev环境，修改连接mysql的url和用户名密码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">druid:</span></span><br><span class="line">            <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.137.14:3306/gulimall_admin?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>





<p>启动“gulimall_admin”，然后访问“<a href="http://localhost:8080/renren-fast/">http://localhost:8080/renren-fast/</a>”</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587616296253.png" alt="1587616296253"></p>
<p>安装node.js，并且安装仓库</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> <span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npm.taobao.org/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS D:\tmp\renren-fast-vue&gt; npm config set registry http://registry.npm.taobao.org/</span><br><span class="line">PS D:\tmp\renren-fast-vue&gt; npm install</span><br><span class="line">npm WARN ajv-keywords@1.5.1 requires a peer of ajv@&gt;=4.10.0 but none is installed. You must install peer dependencies yourself.</span><br><span class="line">npm WARN sass-loader@6.0.6 requires a peer of node-sass@^4.0.0 but none is installed. You must install peer dependencies yourself.</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">up to date in 17.227s</span><br><span class="line">PS D:\tmp\renren-fast-vue&gt; </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS D:\tmp\renren-fast-vue&gt; npm run dev</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> renren-fast-vue@1.2.2 dev D:\tmp\renren-fast-vue</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> 10%</span><span class="bash"> building modules 5/10 modules 5 active ...-0!D:\tmp\renren-fast-vue\src\main.js(node:19864) Warning: Accessing non-existent property <span class="string">&#x27;cat&#x27;</span> of module exports inside circular dependency</span></span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;cd&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;chmod&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;cp&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;dirs&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;pushd&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;popd&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;echo&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;tempdir&#x27; of module exports inside circular dependency</span><br><span class="line">(node:19864) Warning: Accessing non-existent property &#x27;pwd&#x27; of module exports inside circular dependency</span><br></pre></td></tr></table></figure>



<p>常见问题1：“Module build failed: Error: Cannot find module ‘node-sass”</p>
<p>运行过程中，出现“Module build failed: Error: Cannot find module ‘node-sass’报错问题”，解决方法</p>
<blockquote>
<p>用npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> ，从淘宝镜像那下载，然后cnpm下载成功。</p>
<p>最后输入cnpm install node-sass –save。npm run dev终于能跑起来了！！！<br>————————————————<br>版权声明：本文为CSDN博主「夕阳下美了剪影」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_38401285/article/details/86483278">https://blog.csdn.net/qq_38401285/article/details/86483278</a></p>
</blockquote>
<p>常见问题2：cnpm - 解决 “ cnpm : 无法加载文件 C:\Users\93457\AppData\Roaming\npm\cnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息 。。。 “</p>
<p><a href="https://www.cnblogs.com/500m/p/11634969.html">https://www.cnblogs.com/500m/p/11634969.html</a></p>
<p>所有问题的根源都在“node_modules”，npm install之前，应该将这个文件夹删除，然后再进行安装和运行。</p>
<p>再次运行npm run dev恢复正常：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587637858665.png" alt="1587637858665"></p>
<h2 id="7-clone-renren-generator"><a href="#7-clone-renren-generator" class="headerlink" title="7. clone renren-generator"></a>7. clone renren-generator</h2><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p><a href="https://gitee.com/renrenio/renren-generator.git">https://gitee.com/renrenio/renren-generator.git</a></p>
<p>然后将该项目放置到“gulimall”的跟路径下，然后添加该Module，并且提交到github上</p>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>renren-generator/src/main/resources/generator.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#代码生成器，配置信息</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mainPath</span>=<span class="string">com.bigdata</span></span><br><span class="line"><span class="comment">#包名</span></span><br><span class="line"><span class="attr">package</span>=<span class="string">com.bigdata.gulimall</span></span><br><span class="line"><span class="attr">moduleName</span>=<span class="string">product</span></span><br><span class="line"><span class="comment">#作者</span></span><br><span class="line"><span class="attr">author</span>=<span class="string">cosmoswong</span></span><br><span class="line"><span class="comment">#Email</span></span><br><span class="line"><span class="attr">email</span>=<span class="string">cosmoswong@sina.com</span></span><br><span class="line"><span class="comment">#表前缀(类名不会包含表前缀)</span></span><br><span class="line"><span class="attr">tablePrefix</span>=<span class="string">pms_</span></span><br></pre></td></tr></table></figure>

<h3 id="运行“renren-generator”"><a href="#运行“renren-generator”" class="headerlink" title="运行“renren-generator”"></a>运行“renren-generator”</h3><p>访问：&lt;<a href="http://localhost/">http://localhost:80/</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587638853416.png" alt="1587638853416"></p>
<p>点击“renren-fast”，能够看到它将“renren-fast”的所有表都列举了出来：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587638968519.png" alt="1587638968519"></p>
<p>选择所有的表，然后点击“生成代码”，将下载的“renren.zip”，解压后取出main文件夹，放置到“gulimall-product”项目的main目录中。</p>
<p>下面的几个module，也采用同样的方式来操作。</p>
<p>但是针对于“undo_log”，存在一个问题</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587657745923.png" alt="1587657745923"></p>
<p>它的数据类型是“longblob”类型，逆向工程后，对应的数据类型未知：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587657812283.png" alt="1587657812283"></p>
<p>这个问题该要怎么解决？</p>
<h2 id="8-微服务注册中心"><a href="#8-微服务注册中心" class="headerlink" title="8. 微服务注册中心"></a>8. 微服务注册中心</h2><p>要注意nacos集群所在的server，一定要关闭防火墙，否则容易出现各种问题。</p>
<p>搭建nacos集群，然后分别启动各个微服务，将它们注册到Nacos中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gulimall-coupon</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.14</span></span><br></pre></td></tr></table></figure>



<p>查看注册情况：</p>
<p><a href="http://192.168.137.14:8848/nacos/#/serviceManagement?dataId=&amp;group=&amp;appName=&amp;namespace=">http://192.168.137.14:8848/nacos/#/serviceManagement?dataId=&amp;group=&amp;appName=&amp;namespace=</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587694451601.png" alt="1587694451601"></p>
<h2 id="9-使用openfen"><a href="#9-使用openfen" class="headerlink" title="9. 使用openfen"></a>9. 使用openfen</h2><p>1)、引入open-feign</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2)、编写一个接口，告诉SpringCLoud这个接口需要调用远程服务</p>
<p>修改“com.bigdata.gulimall.coupon.controller.CouponController”，添加以下controller方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/member/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">memberCoupons</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CouponEntity couponEntity = <span class="keyword">new</span> CouponEntity();</span><br><span class="line">    couponEntity.setCouponName(<span class="string">&quot;discount 20%&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;coupons&quot;</span>,Arrays.asList(couponEntity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>新建“com.bigdata.gulimall.member.feign.CouponFeignService”接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;gulimall_coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CouponFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupon/coupon/member/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">memberCoupons</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改“com.bigdata.gulimall.member.GulimallMemberApplication”类，添加上”@EnableFeignClients”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.bigdata.gulimall.member.feign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallMemberApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    声明接口的每一个方法都是调用哪个远程服务的那个请求</p>
<p>3)、开启远程调用功能</p>
<p>com.bigdata.gulimall.member.controller.MemberController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/coupons&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MemberEntity memberEntity=<span class="keyword">new</span> MemberEntity();</span><br><span class="line">    memberEntity.setNickname(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    R memberCoupons = couponFeignService.memberCoupons();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memberCoupons.put(<span class="string">&quot;member&quot;</span>,memberEntity).put(<span class="string">&quot;coupons&quot;</span>,memberCoupons.get(<span class="string">&quot;coupons&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>(4)、访问<a href="http://localhost:8000/member/member/coupons">http://localhost:8000/member/member/coupons</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587701348764.png" alt="1587701348764"></p>
<p>停止“gulimall-coupon”服务，能够看到注册中心显示该服务的健康值为0：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587701521184.png" alt="1587701521184"></p>
<p>再次访问：<a href="http://localhost:8000/member/member/coupons">http://localhost:8000/member/member/coupons</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587701587456.png" alt="1587701587456"></p>
<p>启动“gulimall-coupon”服务，再次访问，又恢复了正常。</p>
<h2 id="10-配置中心"><a href="#10-配置中心" class="headerlink" title="10. 配置中心"></a>10. 配置中心</h2><h3 id="1）修改“gulimall-coupon”模块"><a href="#1）修改“gulimall-coupon”模块" class="headerlink" title="1）修改“gulimall-coupon”模块"></a>1）修改“gulimall-coupon”模块</h3><p>添加pom依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>创建bootstrap.properties文件，该配置文件会优先于“application.yml”加载。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">gulimall-coupon</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">192.168.137.14:8848</span></span><br></pre></td></tr></table></figure>



<h3 id="2）传统方式"><a href="#2）传统方式" class="headerlink" title="2）传统方式"></a>2）传统方式</h3><p>为了详细说明config的使用方法，先来看原始的方式</p>
<p>创建“application.properties”配置文件，添加如下配置内容：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">coupon.user.name</span>=<span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"><span class="meta">coupon.user.age</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure>

<p>修改“com.bigdata.gulimall.coupon.controller.CouponController”文件，添加如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;coupon.user.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;coupon.user.age&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> R.ok().put(<span class="string">&quot;name&quot;</span>,name).put(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动“gulimall-coupon”服务：</p>
<p>访问：<a href="http://localhost:7000/coupon/coupon/test&gt;">http://localhost:7000/coupon/coupon/test&gt;</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587716583668.png" alt="1587716583668"></p>
<p>这样做存在的一个问题，如果频繁的修改application.properties，在需要频繁重新打包部署。下面我们将采用Nacos的配置中心来解决这个问题。</p>
<h3 id="3）nacos-config"><a href="#3）nacos-config" class="headerlink" title="3）nacos config"></a>3）nacos config</h3><p>1、在Nacos注册中心中，点击“配置列表”，添加配置规则：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587716911435.png" alt="1587716911435"></p>
<p>DataID：gulimall-coupon</p>
<p>配置格式：properties</p>
<p>文件的命名规则为：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</p>
<p>${spring.application.name}：为微服务名</p>
<p>${spring.profiles.active}：指明是哪种环境下的配置，如dev、test或info</p>
<p>${spring.cloud.nacos.config.file-extension}：配置文件的扩展名，可以为properties、yml等</p>
<p>2、查看配置：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587717125580.png" alt="1587717125580"></p>
<p>3、修改“com.bigdata.gulimall.coupon.controller.CouponController”类，添加“@RefreshScope”注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;coupon/coupon&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponController</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>这样都会动态的从配置中心读取配置.</p>
<p>4、访问：<a href="http://localhost:7000/coupon/coupon/test">http://localhost:7000/coupon/coupon/test</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587717485283.png" alt="1587717485283"></p>
<p>能够看到读取到了nacos 中的最新的配置信息，并且在指明了相同的配置信息时，配置中心中设置的值优先于本地配置。</p>
<h3 id="4）Nacos支持三种配置加载方方案"><a href="#4）Nacos支持三种配置加载方方案" class="headerlink" title="4）Nacos支持三种配置加载方方案"></a>4）Nacos支持三种配置加载方方案</h3><p>Nacos支持“Namespace+group+data ID”的配置解决方案。</p>
<p>详情见：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-docs/src/main/asciidoc-zh/nacos-config.adoc">https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-docs/src/main/asciidoc-zh/nacos-config.adoc</a></p>
<h5 id="Namespace方案"><a href="#Namespace方案" class="headerlink" title="Namespace方案"></a>Namespace方案</h5><p>通过命名空间实现环境区分</p>
<p>下面是配置实例：</p>
<p>1、创建命名空间：</p>
<p>“命名空间”—&gt;“创建命名空间”：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587718802109.png" alt="1587718802109"></p>
<p> 创建三个命名空间，分别为dev，test和prop</p>
<p>2、回到配置列表中，能够看到所创建的三个命名空间</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587718889316.png" alt="1587718889316"></p>
<p>下面我们需要在dev命名空间下，创建“gulimall-coupon.properties”配置规则：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587719108947.png" alt="1587719108947"></p>
<p>3、访问：<a href="http://localhost:7000/coupon/coupon/test">http://localhost:7000/coupon/coupon/test</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587721184218.png" alt="1587721184218"></p>
<p>并没有使用我们在dev命名空间下所配置的规则，而是使用的是public命名空间下所配置的规则，这是怎么回事呢？</p>
<p>查看“gulimall-coupon”服务的启动日志：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">24</span> <span class="number">16</span>:<span class="number">37</span>:<span class="number">24</span><span class="variable">.158</span>  WARN <span class="number">32792</span> --- [           main] c<span class="variable">.a</span><span class="variable">.c</span><span class="variable">.n</span><span class="variable">.c</span><span class="variable">.NacosPropertySourceBuilder</span>     : Ignore the empty nacos configuration <span class="keyword">and</span> get it based on dataId[gulimall-coupon] &amp; group[DEFAULT_GROUP]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">24</span> <span class="number">16</span>:<span class="number">37</span>:<span class="number">24</span><span class="variable">.163</span>  INFO <span class="number">32792</span> --- [           main] c<span class="variable">.a</span><span class="variable">.nacos</span><span class="variable">.client</span><span class="variable">.config</span><span class="variable">.utils</span><span class="variable">.JVMUtil</span>    : isMultiInstance:false</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">24</span> <span class="number">16</span>:<span class="number">37</span>:<span class="number">24</span><span class="variable">.169</span>  INFO <span class="number">32792</span> --- [           main] b<span class="variable">.c</span><span class="variable">.PropertySourceBootstrapConfiguration</span> : Located <span class="keyword">property</span> source: [BootstrapPropertySource &#123;name=&#x27;bootstrapProperties-gulimall-coupon<span class="variable">.properties</span>,DEFAULT_GROUP&#x27;&#125;, BootstrapPropertySource &#123;name=&#x27;bootstrapProperties-gulimall-coupon,DEFAULT_GROUP&#x27;&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**”gulimall-coupon.properties”**，默认就是public命名空间中的内容中所配置的规则。</p>
<p>4、指定命名空间</p>
<p>如果想要使得我们自定义的命名空间生效，需要在“bootstrap.properties”文件中，指定使用哪个命名空间：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">a2c83f0b-e0a8-40fb-9b26-1e9d61be7d6d</span></span><br></pre></td></tr></table></figure>

<p>这个命名空间ID来源于我们在第一步所创建的命名空间</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587718802109.png" alt="1587718802109"></p>
<p>5、重启“gulimall-coupon”，再次访问：<a href="http://localhost:7000/coupon/coupon/test">http://localhost:7000/coupon/coupon/test</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587720311349.png" alt="1587720311349"></p>
<p>但是这种命名空间的粒度还是不够细化，对此我们可以为项目的每个微服务module创建一个命名空间。</p>
<p>6、为所有微服务创建命名空间</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587720714101.png" alt="1587720714101"></p>
<p>7、回到配置列表选项卡，克隆pulic的配置规则到coupon命名空间下</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587720883244.png" alt="1587720883244"></p>
<p>切换到coupon命名空间下，查看所克隆的规则：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587720963699.png" alt="1587720963699"></p>
<p>8、修改“gulimall-coupon”下的bootstrap.properties文件，添加如下配置信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">7905c915-64ad-4066-8ea9-ef63918e5f79</span></span><br></pre></td></tr></table></figure>

<p>这里指明的是，读取时使用coupon命名空间下的配置。</p>
<p>9、重启“gulimall-coupon”，访问：<a href="http://localhost:7000/coupon/coupon/test">http://localhost:7000/coupon/coupon/test</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587721184218.png" alt="1587721184218"></p>
<h5 id="DataID方案"><a href="#DataID方案" class="headerlink" title="DataID方案"></a>DataID方案</h5><p>通过指定spring.profile.active和配置文件的DataID，来使不同环境下读取不同的配置，读取配置时，使用的是默认命名空间public，默认分组（default_group）下的DataID。</p>
<p>默认情况，Namespace=public，Group=DEFAULT GROUP，默认Cluster是DEFAULT</p>
<h5 id="Group方案"><a href="#Group方案" class="headerlink" title="Group方案"></a>Group方案</h5><p>通过Group实现环境区分</p>
<p>实例：通过使用不同的组，来读取不同的配置，还是以上面的gulimall-coupon微服务为例</p>
<p>1、新建“gulimall-coupon.properties”，将它置于“tmp”组下</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587721616021.png" alt="1587721616021"></p>
<p>2、修改“bootstrap.properties”配置，添加如下的配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.group</span>=<span class="string">tmp</span></span><br></pre></td></tr></table></figure>

<p>3、重启“gulimall-coupon”，访问：<a href="http://localhost:7000/coupon/coupon/test">http://localhost:7000/coupon/coupon/test</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587721844449.png" alt="1587721844449"></p>
<h3 id="5）同时加载多个配置集"><a href="#5）同时加载多个配置集" class="headerlink" title="5）同时加载多个配置集"></a>5）同时加载多个配置集</h3><p>当微服务数量很庞大时，将所有配置都书写到一个配置文件中，显然不是太合适。对此我们可以将配置按照功能的不同，拆分为不同的配置文件。</p>
<p>如下面的配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#MySQL配置</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.137.14:3306/gulimall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gulimall-coupon</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.14</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我们可以将，</p>
<p>数据源有关的配置写到一个配置文件中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#MySQL配置</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.137.14:3306/gulimall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>和框架有关的写到另外一个配置文件中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure>



<p>也可以将上面的这些配置交给nacos来进行管理。</p>
<p>实例：将“gulimall-coupon”的“application.yml”文件拆分为多个配置，并放置到nacos配置中心</p>
<p>1、创建“datasource.yml”，用于存储和数据源有关的配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#MySQL配置</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.137.14:3306/gulimall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>在coupon命名空间中，创建“datasource.yml”配置</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587722798375.png" alt="1587722798375"></p>
<p>2、将和mybatis相关的配置，放置到“mybatis.yml”中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure>



<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587722710432.png" alt="1587722710432"></p>
<p>3、创建“other.yml”配置，保存其他的配置信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gulimall-coupon</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.14</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure>



<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587722998265.png" alt="1587722998265"></p>
<p>现在“mybatis.yml”、“datasource.yml”和“other.yml”共同构成了微服务的配置。</p>
<p>4、修改“gulimall-coupon”的“bootstrap.properties”文件，加载“mybatis.yml”、“datasource.yml”和“other.yml”配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">mybatis.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[1].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[2].data-id</span>=<span class="string">other.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[2].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[2].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>“spring.cloud.nacos.config.ext-config”已经被废弃，建议使用“spring.cloud.nacos.config.extension-configs”</p>
<p>5、注释“application.yml”文件中的所有配置</p>
<p>6、重启“gulimall-coupon”服务，然后访问：<a href="http://localhost:7000/coupon/coupon/test">http://localhost:7000/coupon/coupon/test</a></p>
<p> <img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587724212905.png" alt="1587724212905"></p>
<p>7、访问：<a href="http://localhost:7000/coupon/coupon/list">http://localhost:7000/coupon/coupon/list</a>，查看是否能够正常的访问数据库</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587724350548.png" alt="1587724350548"></p>
<p>小结：</p>
<p>1)、微服务任何配置信息，任何配置文件都可以放在配置中心；</p>
<p>2)、只需要在bootstrap.properties中，说明加载配置中心的哪些配置文件即可；</p>
<p>3)、@Value, @ConfigurationProperties。都可以用来获取配置中心中所配置的信息；</p>
<p>4)、配置中心有的优先使用配置中心中的，没有则使用本地的配置。</p>
<h2 id="11-网关"><a href="#11-网关" class="headerlink" title="11. 网关"></a>11. 网关</h2><h3 id="1、注册“gulimall-gateway”到Nacos"><a href="#1、注册“gulimall-gateway”到Nacos" class="headerlink" title="1、注册“gulimall-gateway”到Nacos"></a>1、注册“gulimall-gateway”到Nacos</h3><h4 id="1）创建“gulimall-gateway”"><a href="#1）创建“gulimall-gateway”" class="headerlink" title="1）创建“gulimall-gateway”"></a>1）创建“gulimall-gateway”</h4><p>SpringCloud gateway</p>
<h4 id="2）添加“gulimall-common”依赖和“spring-cloud-starter-gateway”依赖"><a href="#2）添加“gulimall-common”依赖和“spring-cloud-starter-gateway”依赖" class="headerlink" title="2）添加“gulimall-common”依赖和“spring-cloud-starter-gateway”依赖"></a>2）添加“gulimall-common”依赖和“spring-cloud-starter-gateway”依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bigdata.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）“com-bigdata-gulimall-gulimallgateway-GulimallGatewayApplication”类上加上“-EnableDiscoveryClient”注解"><a href="#3）“com-bigdata-gulimall-gulimallgateway-GulimallGatewayApplication”类上加上“-EnableDiscoveryClient”注解" class="headerlink" title="3）“com.bigdata.gulimall.gulimallgateway.GulimallGatewayApplication”类上加上“@EnableDiscoveryClient”注解"></a>3）“com.bigdata.gulimall.gulimallgateway.GulimallGatewayApplication”类上加上“@EnableDiscoveryClient”注解</h4><h4 id="4）在Nacos中创建“gateway”命名空间，同时在该命名空间中创建“gulimall-gateway-yml”"><a href="#4）在Nacos中创建“gateway”命名空间，同时在该命名空间中创建“gulimall-gateway-yml”" class="headerlink" title="4）在Nacos中创建“gateway”命名空间，同时在该命名空间中创建“gulimall-gateway.yml”"></a>4）在Nacos中创建“gateway”命名空间，同时在该命名空间中创建“gulimall-gateway.yml”</h4><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587729576178.png" alt="1587729576178"></p>
<h4 id="5）创建“bootstrap-properties”文件，添加如下配置，指明配置中心地址和所属命名空间"><a href="#5）创建“bootstrap-properties”文件，添加如下配置，指明配置中心地址和所属命名空间" class="headerlink" title="5）创建“bootstrap.properties”文件，添加如下配置，指明配置中心地址和所属命名空间"></a>5）创建“bootstrap.properties”文件，添加如下配置，指明配置中心地址和所属命名空间</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">gulimall-gateway</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">192.168.137.14:8848</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">1c82552e-1af0-4ced-9a48-26f19c2d315f</span></span><br></pre></td></tr></table></figure>



<h4 id="6）创建“application-properties”文件，指定服务名和注册中心地址"><a href="#6）创建“application-properties”文件，指定服务名和注册中心地址" class="headerlink" title="6）创建“application.properties”文件，指定服务名和注册中心地址"></a>6）创建“application.properties”文件，指定服务名和注册中心地址</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">gulimall-gateway</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">192.168.137.14:8848</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">88</span></span><br></pre></td></tr></table></figure>

<h4 id="7）启动“gulimall-gateway”"><a href="#7）启动“gulimall-gateway”" class="headerlink" title="7）启动“gulimall-gateway”"></a>7）启动“gulimall-gateway”</h4><p>启动报错：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Failed to configure a DataSource: &#x27;url&#x27; attribute is <span class="keyword">not</span> specified <span class="keyword">and</span> no embedded datasource could be configured.</span><br><span class="line"></span><br><span class="line">Reason: Failed to determine a suitable driver <span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<p>解决方法：在“com.bigdata.gulimall.gulimallgateway.GulimallGatewayApplication”中排除和数据源相关的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>重新启动</p>
<p>访问：<a href="http://192.168.137.14:8848/nacos/#">http://192.168.137.14:8848/nacos/#</a>，查看到该服务已经注册到了Nacos中</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587730035866.png" alt="1587730035866"></p>
<h3 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h3><p>现在想要实现针对于“<a href="http://localhost:88/hello?url=baidu%E2%80%9D%EF%BC%8C%E8%BD%AC%E5%8F%91%E5%88%B0%E2%80%9Chttps://www.baidu.com%E2%80%9D%EF%BC%8C%E9%92%88%E5%AF%B9%E4%BA%8E%E2%80%9Chttp://localhost:88/hello?url=qq%E2%80%9D%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%BD%AC%E5%8F%91%E5%88%B0%E2%80%9Chttps://www.qq.com/%E2%80%9D">http://localhost:88/hello?url=baidu”，转发到“https://www.baidu.com”，针对于“http://localhost:88/hello?url=qq”的请求，转发到“https://www.qq.com/”</a></p>
<h4 id="1）创建“application-yml”"><a href="#1）创建“application-yml”" class="headerlink" title="1）创建“application.yml”"></a>1）创建“application.yml”</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">baidu_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=url,</span> <span class="string">baidu</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">qq_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.qq.com/</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=url,</span> <span class="string">qq</span></span><br></pre></td></tr></table></figure>

<h4 id="2）启动“gulimall-gateway”"><a href="#2）启动“gulimall-gateway”" class="headerlink" title="2）启动“gulimall-gateway”"></a>2）启动“gulimall-gateway”</h4><h4 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a>3）测试</h4><p>访问：<a href="http://localhost:88/hello?url=baidu">http://localhost:88/hello?url=baidu</a></p>
<p>访问：<a href="http://localhost:88/hello?url=qq">http://localhost:88/hello?url=qq</a></p>
<h2 id="12-Vue"><a href="#12-Vue" class="headerlink" title="12. Vue"></a>12. Vue</h2><p>安装vue</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最新稳定版</span></span><br><span class="line">$ npm <span class="keyword">install</span> vue</span><br></pre></td></tr></table></figure>

<h3 id="1、vue声明式渲染"><a href="#1、vue声明式渲染" class="headerlink" title="1、vue声明式渲染"></a>1、vue声明式渲染</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,<span class="comment">//绑定元素</span></span><br><span class="line">    <span class="attr">data</span>: &#123;  <span class="comment">//封装数据</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;  <span class="comment">//封装方法</span></span><br><span class="line">        <span class="function"><span class="title">cancle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.num -- ;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2、双向绑定-模型变化，视图变化。反之亦然"><a href="#2、双向绑定-模型变化，视图变化。反之亦然" class="headerlink" title="2、双向绑定,模型变化，视图变化。反之亦然"></a>2、双向绑定,模型变化，视图变化。反之亦然</h3><p>双向绑定使用v-model</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt; &#123;&#123;name&#125;&#125; ,非常帅，有&#123;&#123;num&#125;&#125;个人为他点赞&#123;&#123;hello()&#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587746815353.png" alt="1587746815353" style="zoom: 67%;">

<h3 id="3、事件处理"><a href="#3、事件处理" class="headerlink" title="3、事件处理"></a>3、事件处理</h3><p>v-xx：指令<br>1、创建vue实例，关联页面的模板，将自己的数据（data）渲染到关联的模板，响应式的<br>2、指令来简化对dom的一些操作。<br>3、声明方法来做更复杂的操作。methods里面可以封装方法。</p>
<p>v-on是按钮的单击事件：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> v-<span class="keyword">on</span>:click=<span class="string">&quot;num++&quot;</span>&gt;点赞&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure>





<p>在VUE中el,data和vue的作用:</p>
<ul>
<li>el：用来绑定数据；</li>
<li>data:用来封装数据；</li>
<li>methods：用来封装方法，并且能够封装多个方法，如何上面封装了cancell和hello方法。</li>
</ul>
<p>安装“Vue 2 Snippets”，用来做代码提示</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587747283279.png" alt="1587747283279"></p>
<p>为了方便的在浏览器上调试VUE程序，需要安装“<a href="https://github.com/vuejs/vue-devtools">vue-devtools</a>”，编译后安装到chrome中即可。</p>
<p>详细的使用方法见：<a href="https://www.jianshu.com/p/63f09651724c">Vue调试神器vue-devtools安装</a></p>
<p>“v-html”不会对于HTML标签进行转义，而是直接在浏览器上显示data所设置的内容;而“ v-text”会对html标签进行转义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;  &#123;&#123;<span class="number">1</span>+<span class="number">1</span>&#125;&#125;  &#123;&#123;hello()&#125;&#125;&lt;br/&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">   </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">msg</span>:<span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">link</span>:<span class="string">&quot;http://www.baidu.com&quot;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="keyword">return</span> <span class="string">&quot;World&quot;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1587748494597.png" alt="1587748494597"></p>
    :称为差值表达式，它必须要写在Html表达式，可以完成数学运算和方法调用



<h3 id="4、v-bind-单向绑定"><a href="#4、v-bind-单向绑定" class="headerlink" title="4、v-bind :单向绑定"></a>4、v-bind :单向绑定</h3><p>给html标签的属性绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 给html标签的属性绑定 --&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;link&quot;</span>&gt;</span>gogogo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">       <span class="comment">&lt;!-- class,style  &#123;class名：加上？&#125;--&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;active:isActive,&#x27;text-danger&#x27;:hasError&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">         <span class="attr">:style</span>=<span class="string">&quot;&#123;color: color1,fontSize: size&#125;&quot;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">       <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">           <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">           <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">               <span class="attr">link</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">               <span class="attr">isActive</span>:<span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">               <span class="attr">hasError</span>:<span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">               <span class="attr">color1</span>:<span class="string">&#x27;red&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">               <span class="attr">size</span>:<span class="string">&#x27;36px&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">           &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面所完成的任务就是给a标签绑定一个超链接。并且当“isActive”和“hasError”都是true的时候，将属性动态的绑定到，则绑定该“active”和 “text-danger”class。这样可以动态的调整属性的存在。</p>
<p>而且如果想要实现修改vm的”color1”和“size”， span元素的style也能够随之变化，则可以写作v-bind:style，也可以省略v-bind。</p>
<h3 id="5、v-model双向绑定"><a href="#5、v-model双向绑定" class="headerlink" title="5、v-model双向绑定"></a>5、v-model双向绑定</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 表单项，自定义组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        精通的语言：</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;language&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Java&quot;</span>&gt;</span> java<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;language&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PHP&quot;</span>&gt;</span> PHP<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;language&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Python&quot;</span>&gt;</span> Python<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        选中了 &#123;&#123;language.join(&quot;,&quot;)&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">language</span>: []</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面完成的功能就是通过“v-model”为输入框绑定多个值，能够实现选中的值，在data的language也在不断的发生着变化，</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425090955705.png" alt="image-20200425090955705"></p>
<p>如果在控制台上指定vm.language=[“Java”,”PHP”]，则data值也会跟着变化。</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425091736505.png" alt="image-20200425091736505"></p>
<p>通过“v-model”实现了页面发生了变化，则数据也发生变化，数据发生变化，则页面也发生变化，这样就实现了双向绑定。</p>
<p>数组的连接操作： 选中了 { {language.join(“,”)} }</p>
<h3 id="6、v-on为按钮绑定事件"><a href="#6、v-on为按钮绑定事件" class="headerlink" title="6、v-on为按钮绑定事件"></a>6、v-on为按钮绑定事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--事件中直接写js片段--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;num++&quot;</span>&gt;</span>点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;cancle&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面是为两个按钮绑定了单击事件，其中一个对于num进行自增，另外一个自减。</p>
<p>v-on:click也可以写作@click</p>
<p>事件的冒泡：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事件修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red;padding: 20px;&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    大div</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid blue;padding: 20px;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">        小div <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的这两个嵌套div中，如果点击了内层的div，则外层的div也会被触发；这种问题可以事件修饰符来完成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事件修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red;padding: 20px;&quot;</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    大div</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid blue;padding: 20px;&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">        小div <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent.stop</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里禁止了超链接的点击跳转操作，并且只会触发当前对象的操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于事件修饰符：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425094010008.png" alt="image-20200425094010008"></p>
<p>按键修饰符：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425094247167.png" alt="image-20200425094247167"></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425100629676.png" alt="image-20200425100629676"></p>
<h3 id="7、v-for遍历循环"><a href="#7、v-for遍历循环" class="headerlink" title="7、v-for遍历循环"></a>7、v-for遍历循环</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(user,index) in users&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;user.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;user.gender == &#x27;女&#x27;&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 1、显示user信息：v-for=&quot;item in items&quot; --&gt;</span></span><br><span class="line">               当前索引：&#123;&#123;index&#125;&#125; ==&gt; &#123;&#123;user.name&#125;&#125;  ==&gt;   &#123;&#123;user.gender&#125;&#125; ==&gt;&#123;&#123;user.age&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 2、获取数组下标：v-for=&quot;(item,index) in items&quot; --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 3、遍历对象：</span></span><br><span class="line"><span class="comment">                        v-for=&quot;value in object&quot;</span></span><br><span class="line"><span class="comment">                        v-for=&quot;(value,key) in object&quot;</span></span><br><span class="line"><span class="comment">                        v-for=&quot;(value,key,index) in object&quot; </span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                对象信息：</span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;(v,k,i) in user&quot;</span>&gt;</span>&#123;&#123;k&#125;&#125;==&#123;&#123;v&#125;&#125;==&#123;&#123;i&#125;&#125;；<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(num,index) in nums&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">         </span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">users</span>: [&#123; <span class="attr">name</span>: <span class="string">&#x27;柳岩&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">name</span>: <span class="string">&#x27;范冰冰&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">name</span>: <span class="string">&#x27;刘亦菲&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">name</span>: <span class="string">&#x27;古力娜扎&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;],</span></span><br><span class="line"><span class="javascript">                <span class="attr">nums</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器常用来处理文本格式化的操作。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;user in userList&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123;user.id&#125;&#125; ==&gt; &#123;&#123;user.name&#125;&#125; ==&gt; &#123;&#123;user.gender == 1?&quot;男&quot;:&quot;女&quot;&#125;&#125; ==&gt;</span><br><span class="line">                &#123;&#123;user.gender | genderFilter&#125;&#125; ==&gt; &#123;&#123;user.gender | gFilter&#125;&#125;</span><br><span class="line">                <span class="comment">&lt;!-- 这里的&quot;|&quot;表示的管道，将user.gender的值交给genderFilter --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局过滤器 </span></span></span><br><span class="line"><span class="javascript">        Vue.filter(<span class="string">&quot;gFilter&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (val == <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="string">&quot;男~~~&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="string">&quot;女~~~&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">userList</span>: [</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;jacky&#x27;</span>, <span class="attr">gender</span>: <span class="number">1</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;peter&#x27;</span>, <span class="attr">gender</span>: <span class="number">0</span> &#125;</span></span><br><span class="line"><span class="javascript">                ]</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">filters</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//// filters 定义局部过滤器，只可以在当前vue实例中使用</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">genderFilter</span>(<span class="params">val</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (val == <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="string">&quot;男&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="string">&quot;女&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>我被点击了 &#123;&#123;count&#125;&#125; 次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用所定义的组件button-counter --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//1、全局声明注册一个组件</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">&quot;counter&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">template</span>: <span class="string">`&lt;button v-on:click=&quot;count++&quot;&gt;我被点击了 &#123;&#123;count&#125;&#125; 次&lt;/button&gt;`</span>,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">count</span>: <span class="number">1</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//2、局部声明一个组件</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> buttonCounter = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">template</span>: <span class="string">`&lt;button v-on:click=&quot;count++&quot;&gt;我被点击了 &#123;&#123;count&#125;&#125; 次~~~&lt;/button&gt;`</span>,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">count</span>: <span class="number">1</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">count</span>: <span class="number">1</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//声明所定义的局部组件</span></span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;button-counter&#x27;</span>: buttonCounter</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425110048496.png" alt="image-20200425110048496"></p>
<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;num&quot;</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;num++&quot;</span>&gt;</span>赞！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;，有&#123;&#123;num&#125;&#125;个人点赞<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">num</span>: <span class="number">100</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.num++;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;=========beforeCreate=============&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;数据模型未加载：&quot;</span> + <span class="built_in">this</span>.name, <span class="built_in">this</span>.num);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;方法未加载：&quot;</span> + <span class="built_in">this</span>.show());</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;html模板未加载：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;num&quot;</span>));</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;=========created=============&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;数据模型已加载：&quot;</span> + <span class="built_in">this</span>.name, <span class="built_in">this</span>.num);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;方法已加载：&quot;</span> + <span class="built_in">this</span>.show());</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;html模板已加载：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;num&quot;</span>));</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;html模板未渲染：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;num&quot;</span>).innerText);</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;=========beforeMount=============&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;html模板未渲染：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;num&quot;</span>).innerText);</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;=========mounted=============&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;html模板已渲染：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;num&quot;</span>).innerText);</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;=========beforeUpdate=============&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;数据模型已更新：&quot;</span> + <span class="built_in">this</span>.num);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;html模板未更新：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;num&quot;</span>).innerText);</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;=========updated=============&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;数据模型已更新：&quot;</span> + <span class="built_in">this</span>.num);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;html模板已更新：&quot;</span> + <span class="built_in">document</span>.getElementById(<span class="string">&quot;num&quot;</span>).innerText);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="13-element-ui"><a href="#13-element-ui" class="headerlink" title="13. element ui"></a>13. element ui</h2><p>官网： <a href="https://element.eleme.cn/#/zh-CN/component/installation">https://element.eleme.cn/#/zh-CN/component/installation</a> </p>
<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><p> 在 main.js 中写入以下内容： </p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ElementUI  <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>





<h2 id="14-递归树形结构获取数据"><a href="#14-递归树形结构获取数据" class="headerlink" title="14. 递归树形结构获取数据"></a>14. 递归树形结构获取数据</h2><p>在注册中心中“product”命名空间中，创建“gulimall-product.yml”配置文件：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425153735737.png" alt="image-20200425153735737"></p>
<p>将“application.yml”内容拷贝到该配置文件中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#MySQL配置</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.137.14:3306/gulimall_pms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gulimall-product</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.14</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在本地创建“bootstrap.properties”文件，指明配置中心的位置和使用到的配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">gulimall-product</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">192.168.137.14:8848</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">3c50ffaa-010b-4b59-9372-902e35059232</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">gulimall-product.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>然后启动gulimall-product，查看到该服务已经出现在了nacos的注册中心中了</p>
<p>修改“com.bigdata.gulimall.product.service.CategoryService”类，添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/list/tree&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;CategoryEntity&gt; categoryEntities = categoryService.listWithTree();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> categoryEntities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：<a href="http://localhost:10000/product/category/list/tree">http://localhost:10000/product/category/list/tree</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425154348716.png" alt="image-20200425154348716"></p>
<p>如何区别是哪种分类级别？</p>
<p>答：可以通过分类的parent_cid来进行判断，如果是一级分类，其值为0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/list/tree&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;CategoryEntity&gt; categoryEntities = categoryService.listWithTree();</span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; level1Menus = categoryEntities.stream()</span><br><span class="line">            .filter(item -&gt; item.getParentCid() == <span class="number">0</span>)</span><br><span class="line">            .map(menu-&gt;&#123;</span><br><span class="line">                menu.setChildCategoryEntity(getChildrens(menu,categoryEntities));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted((menu1, menu2) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> (menu1.getSort() ==<span class="keyword">null</span> ? <span class="number">0</span>:menu1.getSort())- (menu2.getSort()==<span class="keyword">null</span>?<span class="number">0</span>:menu2.getSort());</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level1Menus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">getChildrens</span><span class="params">(CategoryEntity root,List&lt;CategoryEntity&gt; all)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CategoryEntity&gt; childrens = all.stream().filter(item -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> item.getParentCid() == root.getCatId();</span><br><span class="line">    &#125;).map(item -&gt; &#123;</span><br><span class="line">        item.setChildCategoryEntity(getChildrens(item, all));</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;).sorted((menu1, menu2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (menu1.getSort() ==<span class="keyword">null</span> ? <span class="number">0</span>:menu1.getSort())- (menu2.getSort()==<span class="keyword">null</span>?<span class="number">0</span>:menu2.getSort());</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> childrens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>下面是得到的部分JSON数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;catId&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;图书、音像、电子书刊&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;parentCid&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;catLevel&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;childCategoryEntity&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;catId&quot;</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;电子书刊&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parentCid&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;catLevel&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;childCategoryEntity&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;catId&quot;</span>: <span class="number">165</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;电子书&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;parentCid&quot;</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="attr">&quot;catLevel&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;childCategoryEntity&quot;</span>: []</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;catId&quot;</span>: <span class="number">166</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;网络原创&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;parentCid&quot;</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="attr">&quot;catLevel&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;childCategoryEntity&quot;</span>: []</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;catId&quot;</span>: <span class="number">167</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;数字杂志&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;parentCid&quot;</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="attr">&quot;catLevel&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;childCategoryEntity&quot;</span>: []</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;catId&quot;</span>: <span class="number">168</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;多媒体图书&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;parentCid&quot;</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="attr">&quot;catLevel&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;childCategoryEntity&quot;</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;catId&quot;</span>: <span class="number">23</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;音像&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;parentCid&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;catLevel&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;childCategoryEntity&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;catId&quot;</span>: <span class="number">169</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;音乐&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;parentCid&quot;</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">&quot;catLevel&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;childCategoryEntity&quot;</span>: []</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;catId&quot;</span>: <span class="number">170</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;影视&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;parentCid&quot;</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">&quot;catLevel&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;childCategoryEntity&quot;</span>: []</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;catId&quot;</span>: <span class="number">171</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;教育音像&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;parentCid&quot;</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">&quot;catLevel&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;showStatus&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productUnit&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;productCount&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;childCategoryEntity&quot;</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br></pre></td></tr></table></figure>



<p>启动后端项目renren-fast</p>
<p>启动前端项目renren-fast-vue：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm <span class="builtin-name">run</span> dev</span><br></pre></td></tr></table></figure>



<p>访问： <a href="http://localhost:8001/#/login">http://localhost:8001/#/login</a> </p>
<p>创建一级菜单：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425164019287.png" alt="image-20200425164019287"></p>
<p>创建完成后，在后台的管理系统中会创建一条记录：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425164201813.png" alt="image-20200425164201813"></p>
<p>然后创建子菜单：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425164509143.png" alt="image-20200425164509143"></p>
<p>创建renren-fast-vue\src\views\modules\product目录，子所以是这样来创建，是因为product/category，对应于product-category</p>
<p>在该目录下，新建“category.vue”文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>刷新页面出现404异常，查看请求发现，请求的是“<a href="http://localhost:8080/renren-fast/product/category/list/tree%E2%80%9D">http://localhost:8080/renren-fast/product/category/list/tree”</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425173615149.png" alt="image-20200425173615149"></p>
<p>这个请求是不正确的，正确的请求是：<a href="http://localhost:10000/product/category/list/tree%EF%BC%8C">http://localhost:10000/product/category/list/tree，</a></p>
<p>修正这个问题：</p>
<p>替换“static\config\index.js”文件中的“window.SITE_CONFIG[‘baseUrl’]”</p>
<p>替换前：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">window.SITE_CONFIG[&#x27;baseUrl&#x27;] = &#x27;http://localhost:<span class="number">8080</span>/renren-fast&#x27;;</span><br></pre></td></tr></table></figure>

<p>替换后：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.SITE_CONFIG[<span class="string">&#x27;baseUrl&#x27;</span>] = <span class="string">&#x27;http://localhost:88/api&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost:88，这个地址是我们网关微服务的接口。">http://localhost:88，这个地址是我们网关微服务的接口。</a></p>
<p>这里我们需要通过网关来完成路径的映射，因此将renren-fast注册到nacos注册中心中，并添加配置中心</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">renren-fast</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.14</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">renren-fast</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">ee409c3f-3206-4a3b-ba65-7376922a886d</span></span><br></pre></td></tr></table></figure>



<p>配置网关路由，前台的所有请求都是经由“<a href="http://localhost:88/api%E2%80%9D%E6%9D%A5%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%8C%E5%9C%A8%E2%80%9Cgulimall-gateway%E2%80%9D%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%EF%BC%9A">http://localhost:88/api”来转发的，在“gulimall-gateway”中添加路由规则：</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">admin_route</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://renren-fast</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br></pre></td></tr></table></figure>



<p>但是这样做也引入了另外的一个问题，再次访问：<a href="http://localhost:8001/#/login%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8D%E5%86%8D%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8001/#/login，发现验证码不再显示：</a></p>
<p>分析原因：</p>
<ol>
<li>现在的验证码请求路径为，<a href="http://localhost:88/api/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6">http://localhost:88/api/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6</a></li>
<li>原始的验证码请求路径：<a href="http://localhost:8001/renren-fast/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6">http://localhost:8001/renren-fast/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6</a></li>
</ol>
<p>在admin_route的路由规则下，在访问路径中包含了“api”，因此它会将它转发到renren-fast，网关在转发的时候，会使用网关的前缀信息，为了能够正常的取得验证码，我们需要对请求路径进行重写</p>
<p>关于请求路径重写：</p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#the-rewritepath-gatewayfilter-factory">6.16. The <code>RewritePath</code> <code>GatewayFilter</code> Factory</a></p>
<p>The <code>RewritePath</code> <code>GatewayFilter</code> factory takes a path <code>regexp</code> parameter and a <code>replacement</code> parameter. This uses Java regular expressions for a flexible way to rewrite the request path. The following listing configures a <code>RewritePath</code> <code>GatewayFilter</code>:</p>
<p>Example 41. application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">rewritepath_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/foo/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RewritePath=/red(?&lt;segment&gt;/?.*),</span> <span class="string">$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>For a request path of <code>/red/blue</code>, this sets the path to <code>/blue</code> before making the downstream request. Note that the <code>$</code> should be replaced with <code>$\</code> because of the YAML specification.</p>
<p>修改“admin_route”路由规则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">admin_route</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://renren-fast</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;/?.*),</span> <span class="string">/renren-fast/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>



<p>再次访问：<a href="http://localhost:8001/#/login%EF%BC%8C%E9%AA%8C%E8%AF%81%E7%A0%81%E8%83%BD%E5%A4%9F%E6%AD%A3%E5%B8%B8%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BA%86%E3%80%82">http://localhost:8001/#/login，验证码能够正常的加载了。</a></p>
<p>但是很不幸新的问题又产生了，访问被拒绝了</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425192722821.png" alt="image-20200425192722821"></p>
<p> 问题描述：已拦截跨源请求：同源策略禁止读取位于 <a href="http://localhost:88/api/sys/login">http://localhost:88/api/sys/login</a> 的远程资源。（原因：CORS 头缺少 ‘Access-Control-Allow-Origin’）。 </p>
<p>问题分析：这是一种跨域问题。访问的域名和端口和原来的请求不同，请求就会被限制</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425192902637.png" alt="image-20200425192902637"></p>
<p>跨域流程：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425193136641.png" alt="image-20200425193136641"></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425193523849.png" alt="image-20200425193523849"></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425193614185.png" alt="image-20200425193614185"></p>
<p>解决方法：在网关中定义“GulimallCorsConfiguration”类，该类用来做过滤，允许所有的请求跨域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallCorsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source=<span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再次访问：<a href="http://localhost:8001/#/login">http://localhost:8001/#/login</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425195437299.png" alt="image-20200425195437299"></p>
<p><a href="http://localhost:8001/renre%E5%B7%B2%E6%8B%A6%E6%88%AA%E8%B7%A8%E6%BA%90%E8%AF%B7%E6%B1%82%EF%BC%9A%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%A6%81%E6%AD%A2%E8%AF%BB%E5%8F%96%E4%BD%8D%E4%BA%8E">http://localhost:8001/renre已拦截跨源请求：同源策略禁止读取位于</a> <a href="http://localhost:88/api/sys/login">http://localhost:88/api/sys/login</a> 的远程资源。（原因：不允许有多个 ‘Access-Control-Allow-Origin’ CORS 头）n-fast/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6</p>
<p>出现了多个请求，并且也存在多个跨源请求。</p>
<p>为了解决这个问题，需要修改renren-fast项目，注释掉“io.renren.config.CorsConfig”类。然后再次进行访问。</p>
<p>在显示分类信息的时候，出现了404异常，请求的<a href="http://localhost:88/api/product/category/list/tree%E4%B8%8D%E5%AD%98%E5%9C%A8">http://localhost:88/api/product/category/list/tree不存在</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425213240724.png" alt="image-20200425213240724"></p>
<p>这是因为网关上所做的路径映射不正确，映射后的路径为<a href="http://localhost:8001/renren-fast/product/category/list/tree">http://localhost:8001/renren-fast/product/category/list/tree</a></p>
<p>但是只有通过<a href="http://localhost:10000/product/category/list/tree%E8%B7%AF%E5%BE%84%E6%89%8D%E8%83%BD%E5%A4%9F%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BC%9A%E6%8A%A5404%E5%BC%82%E5%B8%B8%E3%80%82">http://localhost:10000/product/category/list/tree路径才能够正常访问，所以会报404异常。</a></p>
<p>解决方法就是定义一个product路由规则，进行路径重写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://gulimall-product</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/product/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;/?.*),/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>在路由规则的顺序上，将精确的路由规则放置到模糊的路由规则的前面，否则的话，精确的路由规则将不会被匹配到，类似于异常体系中try catch子句中异常的处理顺序。</p>
<h2 id="15-删除数据"><a href="#15-删除数据" class="headerlink" title="15. 删除数据"></a>15. 删除数据</h2><p>添加delete和append标识，并且增加复选框</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-tree</span><br><span class="line">   :data=&quot;menus&quot;</span><br><span class="line">   show-checkbox  //显示复选框</span><br><span class="line">   :props=&quot;defaultProps&quot;  </span><br><span class="line">   :expand-on-click-node=&quot;false&quot; //设置节点点击时不展开</span><br><span class="line">   node-key=&quot;catId&quot;   </span><br><span class="line"> &gt;</span><br><span class="line">   &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt;</span><br><span class="line">     &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt;</span><br><span class="line">     &lt;span&gt;</span><br><span class="line">       &lt;el-button v-if=&quot;node.level &lt;= 2&quot; type=&quot;text&quot; size=&quot;mini&quot; @click=&quot;() =&gt; append(data)&quot;&gt;Append&lt;/el-button&gt;</span><br><span class="line">       &lt;el-button</span><br><span class="line">         v-if=&quot;node.childNodes.length == 0&quot;</span><br><span class="line">         type=&quot;text&quot;</span><br><span class="line">         size=&quot;mini&quot;</span><br><span class="line">         @click=&quot;() =&gt; remove(node, data)&quot;</span><br><span class="line">       &gt;Delete&lt;/el-button&gt;</span><br><span class="line">     &lt;/span&gt;</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line"> &lt;/el-tree&gt;</span><br></pre></td></tr></table></figure>



<p>测试删除数据，打开postman输入“ <a href="http://localhost:88/api/product/category/delete">http://localhost:88/api/product/category/delete</a> ”，请求方式设置为POST，为了比对效果，可以在删除之前查询数据库的pms_category表：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200426112814069.png" alt="image-20200426112814069"></p>
<p>由于delete请求接收的是一个数组，所以这里使用JSON方式，传入了一个数组：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200426113003531.png" alt="image-20200426113003531"></p>
<p>再次查询数据库能够看到cat_id为1000的数据已经被删除了。</p>
<p>修改“com.bigdata.gulimall.product.controller.CategoryController”类，添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">delete</span><span class="params">(<span class="meta">@RequestBody</span> Long[] catIds)</span></span>&#123;</span><br><span class="line">        <span class="comment">//删除之前需要判断待删除的菜单那是否被别的地方所引用。</span></span><br><span class="line"><span class="comment">//		categoryService.removeByIds(Arrays.asList(catIds));</span></span><br><span class="line"></span><br><span class="line">        categoryService.removeMenuByIds(Arrays.asList(catIds));</span><br><span class="line">        <span class="keyword">return</span> R.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>com.bigdata.gulimall.product.service.impl.CategoryServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">void</span> <span class="title">removeMenuByIds</span><span class="params">(List&lt;Long&gt; asList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 检查当前的菜单是否被别的地方所引用</span></span><br><span class="line">    categoryDao.deleteBatchIds(asList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然而多数时候，我们并不希望删除数据，而是标记它被删除了，这就是逻辑删除；</p>
<p>可以设置show_status为0，标记它已经被删除。</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200426115332899.png" alt="image-20200426115332899"></p>
<p>mybatis-plus的逻辑删除：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200426115420393.png" alt="image-20200426115420393"></p>
<p>配置全局的逻辑删除规则，在“src/main/resources/application.yml”文件中添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>修改“com.bigdata.gulimall.product.entity.CategoryEntity”类，添加上@TableLogic，表明使用逻辑删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否显示[0-不显示，1显示]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableLogic(value = &quot;1&quot;,delval = &quot;0&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer showStatus;</span><br></pre></td></tr></table></figure>

<p>然后在POSTMan中测试一下是否能够满足需要。另外在“src/main/resources/application.yml”文件中，设置日志级别，打印出SQL语句：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.bigdata.gulimall.product:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>打印的日志：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE pms_category SET show_status=<span class="number">0</span> WHERE cat_id IN ( ? ) AND show_status=<span class="number">1</span> </span><br><span class="line">==&gt; Parameters: <span class="number">1431</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">get changedGroupKeys:[]</span><br></pre></td></tr></table></figure>



<h2 id="16-菜单拖动"><a href="#16-菜单拖动" class="headerlink" title="16. 菜单拖动"></a>16. 菜单拖动</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>同一个菜单内拖动</td>
<td>正常</td>
</tr>
<tr>
<td>拖动到父菜单的前面或后面</td>
<td>正常</td>
</tr>
<tr>
<td>拖动到父菜单同级的另外一个菜单中</td>
<td>正常</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>关注的焦点在于，拖动到目标节点中，使得目标节点的catlevel+deep小于3即可。拖动到目标节点前后的条件是，使得</p>
<h3 id="拖动菜单时需要修改顺序和级别"><a href="#拖动菜单时需要修改顺序和级别" class="headerlink" title="拖动菜单时需要修改顺序和级别"></a>拖动菜单时需要修改顺序和级别</h3><p>需要考虑两种类型节点的catLevel</p>
<p>一种关系是：如果是同一个节点下的子节点的前后移动，则不需要修改其catLevel</p>
<p>如果是拖动到另外一个节点内或父节点中，则要考虑修改其catLevel</p>
<p>如果拖动到与父节点平级的节点关系中，则要将该拖动的节点的catLevel，设置为兄弟节点的Level，</p>
<p>先考虑parentCid还是先考虑catLevel?</p>
<p>两种关系在耦合</p>
<p>另外还有一种是前后拖动的情况</p>
<p>哪个范围最大？</p>
<p>肯定是拖动类型关系最大，</p>
<p>如果是前后拖动，则拖动后需要看待拖动节点的层级和设置待拖动节点的parentId，</p>
<p>​       如果待拖动节点和目标节点的层级相同，则认为是同级拖动，只需要修改节点的先后顺序即可；</p>
<p>​       否则认为是跨级拖动，则需要修改层级和重新设置parentID</p>
<p>​              如果</p>
<p>​      以拖动类型来分，并不合适，比较合适的是跨级拖动和同级拖动</p>
<p>如何判断是跨级拖动还是同级拖动，根据拖动的层级来看，如果是同一级的拖动，只需要修改先后顺序即可，但是这样也会存在一个问题，就是当拖动到另外一个分组下的同级目录中，显然也需要修改parentID，究竟什么样的模型最好呢？</p>
<p>  另外也可以判断在跨级移动时，跨级后的parentID是否相同，如果不相同，则认为是在不同目录下的跨级移动需要修改parentID。</p>
<p>顺序、catLevel和parentID</p>
<p>同级移动：</p>
<p>（1）首先判断待移动节点和目标节点的catLevel是否相同，</p>
<p> （2）相同则认为是同级移动，</p>
<p>​          如果此时移动后目标节点的parentID和待移动节点的相同，但是移动类型是前后移动，只需要调整顺序即可，此时移动类型是inner，则需要修改catLevel和parentId和顺序</p>
<p>​         如果此时移动后目标节点的parentID和待移动节点的不相同，但是移动类型是前后移动，则需要调整顺序和parentId，此时移动类型是inner，则需要修改catLevel和parentId和顺序</p>
<p>通过这两步的操作能看到一些共性，如果抽取移动类型作为大的分类，则在这种分类下，</p>
<p>如果是前后移动，则分为下面几种情况：</p>
<p>​    同级别下的前后移动：界定标准为catLevel相同，但是又可以分为parentID相同和parentID不同，parent相同时，只需要修改顺序即可；parentID不同时，需要修改parentID和顺序</p>
<p>​    不同级别下的前后移动：界定标准为catLevel不同，此时无论如何都要修改parentID，顺序和catLevel</p>
<p>如果是inner类型移动，则分为一下的几种情况。</p>
<p>​     此时不论是同级inner，还是跨级innner，都需要修改parentID，顺序和catLevel</p>
<p>哪种情况需要更新子节点呢？</p>
<p>那就要看要拖拽的节点是否含有子节点，如果有子节点，则需要更新子节点的catLevel，不需要更新它之间的顺序和parentId，只需要更新catLevel即可。这种更新子节点的Level应该归类，目前的目标是只要有子节点就更新它的catLevel，</p>
<p>（2）如果待移动节点和目标节点的catLevel不同，则认为是跨级移动。如果是移动到父节点中，则需要设置catLevel，parentID和顺序。此时需要分两种情况来考虑，如果是移动到父节点中，则需要设置catLevel，parentID和顺序，如果是移动到兄弟节点中，则需要设置</p>
<p>包含移动到父节点同级目录，兄弟节点中。</p>
<h3 id="设置菜单拖动开关"><a href="#设置菜单拖动开关" class="headerlink" title="设置菜单拖动开关"></a>设置菜单拖动开关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-switch v-model=&quot;draggable&quot; active-text=&quot;开启拖拽&quot; inactive-text=&quot;关闭拖拽&quot;&gt;&lt;/el-switch&gt;</span><br></pre></td></tr></table></figure>



<p>但是现在存在的一个问题是每次拖拽的时候，都会发送请求，更新数据库这样频繁的与数据库交互，现在想要实现一个拖拽过程中不更新数据库，拖拽完成后，统一提交拖拽后的数据。</p>
<p>现在还存在一个问题，如果是将一个菜单连续的拖拽，最终还放到了原来的位置，但是updateNode中却出现了很多节点更新信息，这样显然也是一个问题。</p>
<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button type=&quot;danger&quot; plain size=&quot;small&quot; @click=&quot;batchDelete&quot;&gt;批量删除&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line">   <span class="function"><span class="title">batchDelete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> checkNodes = <span class="built_in">this</span>.$refs.menuTree.getCheckedNodes();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//  console.log(&quot;被选中的节点：&quot;,checkNodes);</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> catIds = [];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; checkNodes.length; i++) &#123;</span><br><span class="line">       catIds.push(checkNodes[i].catId);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">this</span>.$confirm(<span class="string">`确定要删除?`</span>, <span class="string">&quot;提示&quot;</span>, &#123;</span><br><span class="line">       <span class="attr">confirmButtonText</span>: <span class="string">&quot;确定&quot;</span>,</span><br><span class="line">       <span class="attr">cancelButtonText</span>: <span class="string">&quot;取消&quot;</span>,</span><br><span class="line">       <span class="attr">type</span>: <span class="string">&quot;warning&quot;</span></span><br><span class="line">     &#125;)</span><br><span class="line">       .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.$http(&#123;</span><br><span class="line">           <span class="attr">url</span>: <span class="built_in">this</span>.$http.adornUrl(<span class="string">&quot;/product/category/delete&quot;</span>),</span><br><span class="line">           <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">           <span class="attr">data</span>: <span class="built_in">this</span>.$http.adornData(catIds, <span class="literal">false</span>)</span><br><span class="line">         &#125;).then(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">             <span class="attr">message</span>: <span class="string">&quot;菜单批量删除成功&quot;</span>,</span><br><span class="line">             <span class="attr">type</span>: <span class="string">&quot;success&quot;</span></span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//重新刷新页面</span></span><br><span class="line">           <span class="built_in">this</span>.getMeus();</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">//取消删除</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>



<h2 id="17-品牌管理菜单"><a href="#17-品牌管理菜单" class="headerlink" title="17. 品牌管理菜单"></a>17. 品牌管理菜单</h2><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428164054517.png" alt="image-20200428164054517"></p>
<p>（2）将“”逆向工程得到的resources\src\views\modules\product文件拷贝到gulimall/renren-fast-vue/src/views/modules/product目录下，也就是下面的两个文件</p>
<p>brand.vue  brand-add-or-update.vue</p>
<p>但是显示的页面没有新增和删除功能，这是因为权限控制的原因，</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428170325515.png" alt="image-20200428170325515"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button v-if=&quot;isAuth(&#x27;product:brand:save&#x27;)&quot; type=&quot;primary&quot; @click=&quot;addOrUpdateHandle()&quot;&gt;新增&lt;/el-button&gt;</span><br><span class="line">&lt;el-button v-if=&quot;isAuth(&#x27;product:brand:delete&#x27;)&quot; type=&quot;danger&quot; @click=&quot;deleteHandle()&quot; :disabled=&quot;dataListSelections.length &lt;= 0&quot;&gt;批量删除&lt;/el-button&gt;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>查看“isAuth”的定义位置：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428170437592.png" alt="image-20200428170437592"></p>
<p>它是在“index.js”中定义，现在将它设置为返回值为true，即可显示添加和删除功能。</p>
<p>再次刷新页面能够看到，按钮已经出现了：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428170644511.png" alt="image-20200428170644511"></p>
<h3 id="添加“显示状态按钮”"><a href="#添加“显示状态按钮”" class="headerlink" title="添加“显示状态按钮”"></a>添加“显示状态按钮”</h3><p>brand.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">  &lt;el-switch</span><br><span class="line">    v-model=&quot;scope.row.showStatus&quot;</span><br><span class="line">    active-color=&quot;#13ce66&quot;</span><br><span class="line">    inactive-color=&quot;#ff4949&quot;</span><br><span class="line">    @change=&quot;updateBrandStatus(scope.row)&quot;</span><br><span class="line">    :active-value = &quot;1&quot;</span><br><span class="line">    :inactive-value	= &quot;0&quot;</span><br><span class="line">  &gt;&lt;/el-switch&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>brand-add-or-update.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-form-item label=&quot;显示状态&quot; prop=&quot;showStatus&quot;&gt;</span><br><span class="line">   &lt;el-switch v-model=&quot;dataForm.showStatus&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt;&lt;/el-switch&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新开关的状态</span></span><br><span class="line">    <span class="function"><span class="title">updateBrandStatus</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;最新状态&quot;</span>, data);</span><br><span class="line">      <span class="keyword">let</span> &#123;brandId,showStatus&#125; = data;</span><br><span class="line">      <span class="built_in">this</span>.$http(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="built_in">this</span>.$http.adornUrl(<span class="string">&quot;/product/brand/update&quot;</span>),</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="built_in">this</span>.$http.adornData(&#123;brandId,showStatus&#125;, <span class="literal">false</span>)</span><br><span class="line">      &#125;).then(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;状态更新成功&quot;</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;success&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>







<h3 id="添加上传"><a href="#添加上传" class="headerlink" title="添加上传"></a>添加上传</h3><p>和传统的单体应用不同，这里我们选择将数据上传到分布式文件服务器上。</p>
<p>这里我们选择将图片放置到阿里云上，使用对象存储。</p>
<p>阿里云上使使用对象存储方式：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428182755992.png" alt="image-20200428182755992"></p>
<p>创建Bucket</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428183041570.png" alt="image-20200428183041570"></p>
<p>上传文件：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428183213694.png" alt="image-20200428183213694"></p>
<p>上传成功后，取得图片的URL</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428183644020.png" alt="image-20200428183644020"></p>
<p>这种方式是手动上传图片，实际上我们可以在程序中设置自动上传图片到阿里云对象存储。</p>
<p>上传模型：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428184029655.png" alt="image-20200428184029655"></p>
<p>查看阿里云关于文件上传的帮助： <a href="https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.768.549d59aaWuZMGJ">https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.768.549d59aaWuZMGJ</a> </p>
<h4 id="1）添加依赖包"><a href="#1）添加依赖包" class="headerlink" title="1）添加依赖包"></a>1）添加依赖包</h4><p>在Maven项目中加入依赖项（推荐方式）</p>
<p>在 Maven 工程中使用 OSS Java SDK，只需在 pom.xml 中加入相应依赖即可。以 3.8.0 版本为例，在 <dependencies> 内加入如下内容：</dependencies></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2）上传文件流"><a href="#2）上传文件流" class="headerlink" title="2）上传文件流"></a>2）上传文件流</h4><p>以下代码用于上传文件流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">String endpoint = <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。</span></span><br><span class="line">String accessKeyId = <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>;</span><br><span class="line">String accessKeySecret = <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件流。</span></span><br><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&lt;yourlocalFile&gt;&quot;</span>);</span><br><span class="line">ossClient.putObject(<span class="string">&quot;&lt;yourBucketName&gt;&quot;</span>, <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span>, inputStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭OSSClient。</span></span><br><span class="line">ossClient.shutdown();</span><br></pre></td></tr></table></figure>

<p>endpoint的取值：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428190553350.png" alt="image-20200428190553350"></p>
<p>accessKeyId和accessKeySecret需要创建一个RAM账号：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428190532924.png" alt="image-20200428190532924"></p>
<p>创建用户完毕后，会得到一个“AccessKey ID”和“AccessKeySecret”，然后复制这两个值到代码的“AccessKey ID”和“AccessKeySecret”。</p>
<p>另外还需要添加访问控制权限：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428191518591.png" alt="image-20200428191518591"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">        String endpoint = <span class="string">&quot;oss-cn-shanghai.aliyuncs.com&quot;</span>;</span><br><span class="line">        <span class="comment">// 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。</span></span><br><span class="line">        String accessKeyId = <span class="string">&quot;LTAI4G4W1RA4JXz2QhoDwHhi&quot;</span>;</span><br><span class="line">        String accessKeySecret = <span class="string">&quot;R99lmDOJumF2x43ZBKT259Qpe70Oxw&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上传文件流。</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Administrator\\Pictures\\timg.jpg&quot;</span>);</span><br><span class="line">        ossClient.putObject(<span class="string">&quot;gulimall-images&quot;</span>, <span class="string">&quot;time.jpg&quot;</span>, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;上传成功.&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>更为简单的使用方式，是使用SpringCloud Alibaba</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428195507730.png" alt="image-20200428195507730"></p>
<p>详细使用方法，见： <a href="https://help.aliyun.com/knowledge_detail/108650.html">https://help.aliyun.com/knowledge_detail/108650.html</a>  </p>
<p>（1）添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）创建“AccessKey ID”和“AccessKeySecret”</p>
<p>（3）配置key，secret和endpoint相关信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">access-key:</span> <span class="string">LTAI4G4W1RA4JXz2QhoDwHhi</span></span><br><span class="line"><span class="attr">secret-key:</span> <span class="string">R99lmDOJumF2x43ZBKT259Qpe70Oxw</span></span><br><span class="line"><span class="attr">oss:</span></span><br><span class="line">  <span class="attr">endpoint:</span> <span class="string">oss-cn-shanghai.aliyuncs.com</span></span><br></pre></td></tr></table></figure>



<p>（4）注入OSSClient并进行文件上传下载等操作</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428224840535.png" alt="image-20200428224840535"></p>
<p>但是这样来做还是比较麻烦，如果以后的上传任务都交给gulimall-product来完成，显然耦合度高。最好单独新建一个Module来完成文件上传任务。</p>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><h4 id="1）新建gulimall-third-party"><a href="#1）新建gulimall-third-party" class="headerlink" title="1）新建gulimall-third-party"></a>1）新建gulimall-third-party</h4><h4 id="2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中"><a href="#2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中" class="headerlink" title="2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中"></a>2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bigdata.gulimall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimall-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 另外也需要在“pom.xml”文件中，添加如下的依赖管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3）在主启动类中开启服务的注册和发现"><a href="#3）在主启动类中开启服务的注册和发现" class="headerlink" title="3）在主启动类中开启服务的注册和发现"></a>3）在主启动类中开启服务的注册和发现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure>



<h4 id="4）在nacos中注册"><a href="#4）在nacos中注册" class="headerlink" title="4）在nacos中注册"></a>4）在nacos中注册</h4><p>（1）创建命名空间“ gulimall-third-party ”</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200429075831984.png" alt="image-20200429075831984"></p>
<p>（2）在“ gulimall-third-party”命名空间中，创建“ gulimall-third-party.yml”文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alicloud:</span></span><br><span class="line">      <span class="attr">access-key:</span> <span class="string">LTAI4G4W1RA4JXz2QhoDwHhi</span></span><br><span class="line">      <span class="attr">secret-key:</span> <span class="string">R99lmDOJumF2x43ZBKT259Qpe70Oxw</span></span><br><span class="line">      <span class="attr">oss:</span></span><br><span class="line">        <span class="attr">endpoint:</span> <span class="string">oss-cn-shanghai.aliyuncs.com</span></span><br></pre></td></tr></table></figure>



<h4 id="5）编写配置文件"><a href="#5）编写配置文件" class="headerlink" title="5）编写配置文件"></a>5）编写配置文件</h4><p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gulimall-third-party</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.14</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.bigdata.gulimall.product:</span> <span class="string">debug</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>bootstrap.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.name</span>=<span class="string">gulimall-third-party</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">192.168.137.14:8848</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">f995d8ee-c53a-4d29-8316-a1ef54775e00</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">gulimall-third-party.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>



<h4 id="6）-编写测试类"><a href="#6）-编写测试类" class="headerlink" title="6） 编写测试类"></a>6） 编写测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.gulimall.thirdparty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClient;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GulimallThirdPartyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OSSClient ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">        String endpoint = <span class="string">&quot;oss-cn-shanghai.aliyuncs.com&quot;</span>;</span><br><span class="line">        <span class="comment">// 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。</span></span><br><span class="line">        String accessKeyId = <span class="string">&quot;LTAI4G4W1RA4JXz2QhoDwHhi&quot;</span>;</span><br><span class="line">        String accessKeySecret = <span class="string">&quot;R99lmDOJumF2x43ZBKT259Qpe70Oxw&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//上传文件流。</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Administrator\\Pictures\\timg.jpg&quot;</span>);</span><br><span class="line">        ossClient.putObject(<span class="string">&quot;gulimall-images&quot;</span>, <span class="string">&quot;time3.jpg&quot;</span>, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;上传成功.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p> <a href="https://help.aliyun.com/document_detail/31926.html?spm=a2c4g.11186623.6.1527.228d74b8V6IZuT">https://help.aliyun.com/document_detail/31926.html?spm=a2c4g.11186623.6.1527.228d74b8V6IZuT</a> </p>
<p><strong>背景</strong></p>
<p>采用JavaScript客户端直接签名（参见<a href="https://help.aliyun.com/document_detail/31925.html#concept-frd-4gy-5db">JavaScript客户端签名直传</a>）时，AccessKeyID和AcessKeySecret会暴露在前端页面，因此存在严重的安全隐患。因此，OSS提供了服务端签名后直传的方案。</p>
<p><strong>原理介绍</strong></p>
<p><a href="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/6875011751/p1472.png"><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/6875011751/p1472.png" alt="img"></a></p>
<p>服务端签名后直传的原理如下：</p>
<ol>
<li>用户发送上传Policy请求到应用服务器。</li>
<li>应用服务器返回上传Policy和签名给用户。</li>
<li>用户直接上传数据到OSS。</li>
</ol>
<p>编写“com.bigdata.gulimall.thirdparty.controller.OssController”类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.gulimall.thirdparty.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.common.utils.BinaryUtil;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.model.MatchMode;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.model.PolicyConditions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OSS ossClient;</span><br><span class="line">    <span class="meta">@Value</span> (<span class="string">&quot;$&#123;spring.cloud.alicloud.oss.endpoint&#125;&quot;</span>)</span><br><span class="line">    String endpoint ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.oss.bucket&#125;&quot;)</span></span><br><span class="line">    String bucket ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.access-key&#125;&quot;)</span></span><br><span class="line">    String accessId ;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.secret-key&#125;&quot;)</span></span><br><span class="line">    String accessKey ;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/oss/policy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">policy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String host = <span class="string">&quot;https://&quot;</span> + bucket + <span class="string">&quot;.&quot;</span> + endpoint; <span class="comment">// host的格式为 bucketname.endpoint</span></span><br><span class="line"></span><br><span class="line">        String format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        String dir = format; <span class="comment">// 用户上传文件时指定的前缀。</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; respMap=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> expireTime = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="number">1000</span>;</span><br><span class="line">            Date expiration = <span class="keyword">new</span> Date(expireEndTime);</span><br><span class="line">            PolicyConditions policyConds = <span class="keyword">new</span> PolicyConditions();</span><br><span class="line">            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="number">0</span>, <span class="number">1048576000</span>);</span><br><span class="line">            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);</span><br><span class="line"></span><br><span class="line">            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);</span><br><span class="line">            <span class="keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            String encodedPolicy = BinaryUtil.toBase64String(binaryData);</span><br><span class="line">            String postSignature = ossClient.calculatePostSignature(postPolicy);</span><br><span class="line"></span><br><span class="line">            respMap= <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">            respMap.put(<span class="string">&quot;accessid&quot;</span>, accessId);</span><br><span class="line">            respMap.put(<span class="string">&quot;policy&quot;</span>, encodedPolicy);</span><br><span class="line">            respMap.put(<span class="string">&quot;signature&quot;</span>, postSignature);</span><br><span class="line">            respMap.put(<span class="string">&quot;dir&quot;</span>, dir);</span><br><span class="line">            respMap.put(<span class="string">&quot;host&quot;</span>, host);</span><br><span class="line">            respMap.put(<span class="string">&quot;expire&quot;</span>, String.valueOf(expireEndTime / <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Assert.fail(e.getMessage());</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试： <a href="http://localhost:30000/oss/policy">http://localhost:30000/oss/policy</a> </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;accessid&quot;</span>:<span class="string">&quot;LTAI4G4W1RA4JXz2QhoDwHhi&quot;</span>,<span class="attr">&quot;policy&quot;</span>:<span class="string">&quot;eyJleHBpcmF0aW9uIjoiMjAyMC0wNC0yOVQwMjo1ODowNy41NzhaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMTA0ODU3NjAwMF0sWyJzdGFydHMtd2l0aCIsIiRrZXkiLCIyMDIwLTA0LTI5LyJdXX0=&quot;</span>,<span class="attr">&quot;signature&quot;</span>:<span class="string">&quot;s42iRxtxGFmHyG40StM3d9vOfFk=&quot;</span>,<span class="attr">&quot;dir&quot;</span>:<span class="string">&quot;2020-04-29/&quot;</span>,<span class="attr">&quot;host&quot;</span>:<span class="string">&quot;https://gulimall-images.oss-cn-shanghai.aliyuncs.com&quot;</span>,<span class="attr">&quot;expire&quot;</span>:<span class="string">&quot;1588129087&quot;</span>&#125;</span><br></pre></td></tr></table></figure>



<p>以后在上传文件时的访问路径为“ <a href="http://localhost:88/api/thirdparty/oss/policy%E2%80%9D%EF%BC%8C">http://localhost:88/api/thirdparty/oss/policy”，</a></p>
<p>在“gulimall-gateway”中配置路由规则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">third_party_route</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://gulimall-gateway</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/thirdparty/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RewritePath=/api/thirdparty/(?&lt;segment&gt;/?.*),/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>



<p>测试是否能够正常跳转： <a href="http://localhost:88/api/thirdparty/oss/policy">http://localhost:88/api/thirdparty/oss/policy</a> </p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200429111408164.png" alt="image-20200429111408164"></p>
<h3 id="上传组件"><a href="#上传组件" class="headerlink" title="上传组件"></a>上传组件</h3><p>放置项目提供的upload文件夹到components目录下，一个是单文件上传，另外一个是多文件上传</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS D:\Project\gulimall\renren-fast-vue\src\components\upload&gt; ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\Project\gulimall\renren-fast-vue\src\components\upload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----  2020/4/29 星期三     12:0           3122 multiUpload.vue</span><br><span class="line">                                2</span><br><span class="line">-a----  2019/11/11 星期一     21:            343 policy.js</span><br><span class="line">                               20</span><br><span class="line">-a----  2020/4/29 星期三     12:0           3053 singleUpload.vue</span><br><span class="line">                                1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:\Project\gulimall\renren-fast-vue\src\components\upload&gt;</span><br></pre></td></tr></table></figure>



<p>修改这两个文件的配置后</p>
<p>开始执行上传，但是在上传过程中，出现了如下的问题：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200429124629150.png" alt="image-20200429124629150"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Access</span> <span class="keyword">to</span> XMLHttpRequest at <span class="string">&#x27;http://gulimall-images.oss-cn-shanghai.aliyuncs.com/&#x27;</span> <span class="keyword">from</span> origin <span class="string">&#x27;http://localhost:8001&#x27;</span> has been blocked <span class="keyword">by</span> CORS <span class="keyword">policy</span>: Response <span class="keyword">to</span> preflight request doesn<span class="string">&#x27;t pass access control check: No &#x27;</span><span class="keyword">Access</span>-Control-Allow-Origin<span class="string">&#x27; header is present on the requested resource.</span></span><br></pre></td></tr></table></figure>

<p>这又是一个跨域的问题，解决方法就是在阿里云上开启跨域访问：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200429124940091.png" alt="image-20200429124940091"></p>
<p>再次执行文件上传。</p>
<h2 id="18-JSR303校验"><a href="#18-JSR303校验" class="headerlink" title="18. JSR303校验"></a>18. JSR303校验</h2><h3 id="步骤1：使用校验注解"><a href="#步骤1：使用校验注解" class="headerlink" title="步骤1：使用校验注解"></a>步骤1：使用校验注解</h3><p>在Java中提供了一系列的校验方式，它这些校验方式在“javax.validation.constraints”包中，提供了如@Email，@NotNull等注解。</p>
<p>在非空处理方式上提供了@NotNull，@Blank和@</p>
<p>（1）@NotNull</p>
<p>The annotated element must not be null. Accepts any type.<br>注解元素禁止为null，能够接收任何类型</p>
<p>（2）@NotEmpty</p>
<p>the annotated element must not be null nor empty.</p>
<p>该注解修饰的字段不能为null或””</p>
<p>Supported types are:</p>
<p>支持以下几种类型</p>
<p>CharSequence (length of character sequence is evaluated)</p>
<p>字符序列（字符序列长度的计算）</p>
<p>Collection (collection size is evaluated)<br>集合长度的计算</p>
<p>Map (map size is evaluated)<br>map长度的计算</p>
<p>Array (array length is evaluated)<br>数组长度的计算</p>
<p>（3）@NotBlank</p>
<p>The annotated element must not be null and must contain at least one non-whitespace character. Accepts CharSequence.<br>该注解不能为null，并且至少包含一个非空白字符。接收字符序列。</p>
<h3 id="步骤2：在请求方法种，使用校验注解-Valid，开启校验，"><a href="#步骤2：在请求方法种，使用校验注解-Valid，开启校验，" class="headerlink" title="步骤2：在请求方法种，使用校验注解@Valid，开启校验，"></a>步骤2：在请求方法种，使用校验注解@Valid，开启校验，</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand)</span></span>&#123;</span><br><span class="line">brandService.save(brand);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> R.ok();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>测试： <a href="http://localhost:88/api/product/brand/save">http://localhost:88/api/product/brand/save</a> </p>
<p>在postman种发送上面的请求</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2020-04-29T09:20:46.383+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Bad Request&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;NotBlank.brandEntity.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.java.lang.String&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;arguments&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;brandEntity.name&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">&quot;arguments&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;不能为空&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;objectName&quot;</span>: <span class="string">&quot;brandEntity&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;rejectedValue&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;bindingFailure&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Validation failed for object=&#x27;brandEntity&#x27;. Error count: 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/product/brand/save&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够看到”defaultMessage”: “不能为空”，这些错误消息定义在“hibernate-validator”的“\org\hibernate\validator\ValidationMessages_zh_CN.properties”文件中。在该文件中定义了很多的错误规则：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">javax.validation.constraints.AssertFalse.message</span>     = <span class="string">只能为false</span></span><br><span class="line"><span class="meta">javax.validation.constraints.AssertTrue.message</span>      = <span class="string">只能为true</span></span><br><span class="line"><span class="meta">javax.validation.constraints.DecimalMax.message</span>      = <span class="string">必须小于或等于&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.DecimalMin.message</span>      = <span class="string">必须大于或等于&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Digits.message</span>          = <span class="string">数字的值超出了允许范围(只允许在&#123;integer&#125;位整数和&#123;fraction&#125;位小数范围内)</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Email.message</span>           = <span class="string">不是一个合法的电子邮件地址</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Future.message</span>          = <span class="string">需要是一个将来的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.FutureOrPresent.message</span> = <span class="string">需要是一个将来或现在的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Max.message</span>             = <span class="string">最大不能超过&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Min.message</span>             = <span class="string">最小不能小于&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Negative.message</span>        = <span class="string">必须是负数</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NegativeOrZero.message</span>  = <span class="string">必须是负数或零</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NotBlank.message</span>        = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NotEmpty.message</span>        = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NotNull.message</span>         = <span class="string">不能为null</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Null.message</span>            = <span class="string">必须为null</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Past.message</span>            = <span class="string">需要是一个过去的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.PastOrPresent.message</span>   = <span class="string">需要是一个过去或现在的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Pattern.message</span>         = <span class="string">需要匹配正则表达式&quot;&#123;regexp&#125;&quot;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Positive.message</span>        = <span class="string">必须是正数</span></span><br><span class="line"><span class="meta">javax.validation.constraints.PositiveOrZero.message</span>  = <span class="string">必须是正数或零</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Size.message</span>            = <span class="string">个数必须在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.CreditCardNumber.message</span>        = <span class="string">不合法的信用卡号码</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Currency.message</span>                = <span class="string">不合法的货币 (必须是&#123;value&#125;其中之一)</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.EAN.message</span>                     = <span class="string">不合法的&#123;type&#125;条形码</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Email.message</span>                   = <span class="string">不是一个合法的电子邮件地址</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Length.message</span>                  = <span class="string">长度需要在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.CodePointLength.message</span>         = <span class="string">长度需要在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.LuhnCheck.message</span>               = <span class="string">$&#123;validatedValue&#125;的校验码不合法, Luhn模10校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Mod10Check.message</span>              = <span class="string">$&#123;validatedValue&#125;的校验码不合法, 模10校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Mod11Check.message</span>              = <span class="string">$&#123;validatedValue&#125;的校验码不合法, 模11校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.ModCheck.message</span>                = <span class="string">$&#123;validatedValue&#125;的校验码不合法, $&#123;modType&#125;校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.NotBlank.message</span>                = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.NotEmpty.message</span>                = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.ParametersScriptAssert.message</span>  = <span class="string">执行脚本表达式&quot;&#123;script&#125;&quot;没有返回期望结果</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Range.message</span>                   = <span class="string">需要在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.SafeHtml.message</span>                = <span class="string">可能有不安全的HTML内容</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.ScriptAssert.message</span>            = <span class="string">执行脚本表达式&quot;&#123;script&#125;&quot;没有返回期望结果</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.URL.message</span>                     = <span class="string">需要是一个合法的URL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.time.DurationMax.message</span>        = <span class="string">必须小于$&#123;inclusive == true ? &#x27;或等于&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days += &#x27;天&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours += &#x27;小时&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes += &#x27;分钟&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds += &#x27;秒&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis += &#x27;毫秒&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos += &#x27;纳秒&#x27;&#125;</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.time.DurationMin.message</span>        = <span class="string">必须大于$&#123;inclusive == true ? &#x27;或等于&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days += &#x27;天&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours += &#x27;小时&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes += &#x27;分钟&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds += &#x27;秒&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis += &#x27;毫秒&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos += &#x27;纳秒&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>想要自定义错误消息，可以覆盖默认的错误提示信息，如@NotBlank的默认message是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotBlank &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;</span>&#123;javax.validation.constraints.NotBlank.message&#125;<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>

<p>可以在添加注解的时候，修改message：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名必须非空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<p>当再次发送请求时，得到的错误提示信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2020-04-29T09:36:04.125+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Bad Request&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;NotBlank.brandEntity.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.java.lang.String&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;arguments&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;brandEntity.name&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">&quot;arguments&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;品牌名必须非空&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;objectName&quot;</span>: <span class="string">&quot;brandEntity&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;rejectedValue&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;bindingFailure&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Validation failed for object=&#x27;brandEntity&#x27;. Error count: 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/product/brand/save&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是这种返回的错误结果并不符合我们的业务需要。</p>
<h3 id="步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。"><a href="#步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。" class="headerlink" title="步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。"></a>步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand, BindingResult result)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( result.hasErrors())&#123;</span><br><span class="line">           Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           <span class="comment">//1.获取错误的校验结果</span></span><br><span class="line">           result.getFieldErrors().forEach((item)-&gt;&#123;</span><br><span class="line">               <span class="comment">//获取发生错误时的message</span></span><br><span class="line">               String message = item.getDefaultMessage();</span><br><span class="line">               <span class="comment">//获取发生错误的字段</span></span><br><span class="line">               String field = item.getField();</span><br><span class="line">               map.put(field,message);</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> R.error(<span class="number">400</span>,<span class="string">&quot;提交的数据不合法&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">	brandService.save(brand);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种是针对于该请求设置了一个内容校验，如果针对于每个请求都单独进行配置，显然不是太合适，实际上可以统一的对于异常进行处理。</p>
<h3 id="步骤4：统一异常处理"><a href="#步骤4：统一异常处理" class="headerlink" title="步骤4：统一异常处理"></a>步骤4：统一异常处理</h3><p>可以使用SpringMvc所提供的@ControllerAdvice，通过“basePackages”能够说明处理哪些路径下的异常。</p>
<p>（1）抽取一个异常处理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.gulimall.product.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bigdata.common.utils.R;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集中处理所有异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.bigdata.gulimall.product.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallExceptionAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">handleValidException</span><span class="params">(MethodArgumentNotValidException exception)</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        BindingResult bindingResult = exception.getBindingResult();</span><br><span class="line">        bindingResult.getFieldErrors().forEach(fieldError -&gt; &#123;</span><br><span class="line">            String message = fieldError.getDefaultMessage();</span><br><span class="line">            String field = fieldError.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;数据校验出现问题&#123;&#125;,异常类型&#123;&#125;&quot;</span>,exception.getMessage(),exception.getClass());</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="number">400</span>,<span class="string">&quot;数据校验出现问题&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）测试： <a href="http://localhost:88/api/product/brand/save">http://localhost:88/api/product/brand/save</a> </p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200429183334783.png" alt="image-20200429183334783"></p>
<p>（3）默认异常处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> R <span class="title">handleException</span><span class="params">(Throwable throwable)</span></span>&#123;</span><br><span class="line">     log.error(<span class="string">&quot;未知异常&#123;&#125;,异常类型&#123;&#125;&quot;</span>,throwable.getMessage(),throwable.getClass());</span><br><span class="line">     <span class="keyword">return</span> R.error(BizCodeEnum.UNKNOW_EXEPTION.getCode(),BizCodeEnum.UNKNOW_EXEPTION.getMsg());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>（4）错误状态码</p>
<p>上面代码中，针对于错误状态码，是我们进行随意定义的，然而正规开发过程中，错误状态码有着严格的定义规则，如该在项目中我们的错误状态码定义</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200429183748249.png" alt="image-20200429183748249"></p>
<p>为了定义这些错误状态码，我们可以单独定义一个常量类，用来存储这些错误状态码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.common.exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 错误码和错误信息定义类</span></span><br><span class="line"><span class="comment"> * 1. 错误码定义规则为5为数字</span></span><br><span class="line"><span class="comment"> * 2. 前两位表示业务场景，最后三位表示错误码。例如：100001。10:通用 001:系统未知异常</span></span><br><span class="line"><span class="comment"> * 3. 维护错误码后需要维护错误描述，将他们定义为枚举形式</span></span><br><span class="line"><span class="comment"> * 错误码列表：</span></span><br><span class="line"><span class="comment"> *  10: 通用</span></span><br><span class="line"><span class="comment"> *      001：参数格式校验</span></span><br><span class="line"><span class="comment"> *  11: 商品</span></span><br><span class="line"><span class="comment"> *  12: 订单</span></span><br><span class="line"><span class="comment"> *  13: 购物车</span></span><br><span class="line"><span class="comment"> *  14: 物流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">BizCodeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UNKNOW_EXEPTION(<span class="number">10000</span>,<span class="string">&quot;系统未知异常&quot;</span>),</span><br><span class="line"></span><br><span class="line">    VALID_EXCEPTION( <span class="number">10001</span>,<span class="string">&quot;参数格式校验失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    BizCodeEnum(<span class="keyword">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（5）测试： <a href="http://localhost:88/api/product/brand/save">http://localhost:88/api/product/brand/save</a> </p>
<img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200429191830967.png" alt="image-20200429191830967" style="zoom:67%;">

<h2 id="19-分组校验功能（完成多场景的复杂校验）"><a href="#19-分组校验功能（完成多场景的复杂校验）" class="headerlink" title="19. 分组校验功能（完成多场景的复杂校验）"></a>19. 分组校验功能（完成多场景的复杂校验）</h2><h3 id="1、给校验注解，标注上groups，指定什么情况下才需要进行校验"><a href="#1、给校验注解，标注上groups，指定什么情况下才需要进行校验" class="headerlink" title="1、给校验注解，标注上groups，指定什么情况下才需要进行校验"></a>1、给校验注解，标注上groups，指定什么情况下才需要进行校验</h3><p>如：指定在更新和添加的时候，都需要进行校验</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotEmpty</span></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名必须非空&quot;,groups = &#123;UpdateGroup.class,AddGroup.class&#125;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，没有指定分组的校验注解，默认是不起作用的。想要起作用就必须要加groups。</p>
<h3 id="2、业务方法参数上使用-Validated注解"><a href="#2、业务方法参数上使用-Validated注解" class="headerlink" title="2、业务方法参数上使用@Validated注解"></a>2、业务方法参数上使用@Validated注解</h3><p>@Validated的value方法：</p>
<p>Specify one or more validation groups to apply to the validation step kicked off by this annotation.<br> 指定一个或多个验证组以应用于此注释启动的验证步骤。 </p>
<p>JSR-303 defines validation groups as custom annotations which an application declares for the sole purpose of using<br>them as type-safe group arguments, as implemented in SpringValidatorAdapter.</p>
<p> JSR-303 将验证组定义为自定义注释，应用程序声明的唯一目的是将它们用作类型安全组参数，如 SpringValidatorAdapter 中实现的那样。 </p>
<p>Other SmartValidator implementations may support class arguments in other ways as well.</p>
<p> 其他SmartValidator 实现也可以以其他方式支持类参数。 </p>
<h3 id="3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。"><a href="#3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。" class="headerlink" title="3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。"></a>3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。</h3><h2 id="20-自定义校验功能"><a href="#20-自定义校验功能" class="headerlink" title="20. 自定义校验功能"></a>20. 自定义校验功能</h2><h3 id="1、编写一个自定义的校验注解"><a href="#1、编写一个自定义的校验注解" class="headerlink" title="1、编写一个自定义的校验注解"></a>1、编写一个自定义的校验注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; ListValueConstraintValidator.class&#125;)</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;</span>&#123;com.bigdata.common.valid.ListValue.message&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int[] value() default &#123;&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、编写一个自定义的校验器"><a href="#2、编写一个自定义的校验器" class="headerlink" title="2、编写一个自定义的校验器"></a>2、编写一个自定义的校验器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">ListValue</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ListValue constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] value = constraintAnnotation.value();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : value) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  set.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、关联自定义的校验器和自定义的校验注解"><a href="#3、关联自定义的校验器和自定义的校验注解" class="headerlink" title="3、关联自定义的校验器和自定义的校验注解"></a>3、关联自定义的校验器和自定义的校验注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Constraint(validatedBy = &#123; ListValueConstraintValidator.class&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="4、使用实例"><a href="#4、使用实例" class="headerlink" title="4、使用实例"></a>4、使用实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示状态[0-不显示；1-显示]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ListValue(value = &#123;0,1&#125;,groups =&#123;AddGroup.class&#125;)</span></span><br><span class="line"><span class="keyword">private</span> Integer showStatus;</span><br></pre></td></tr></table></figure>

<h2 id="21-商品SPU和SKU管理"><a href="#21-商品SPU和SKU管理" class="headerlink" title="21. 商品SPU和SKU管理"></a>21. 商品SPU和SKU管理</h2><p>重新执行“sys_menus.sql”</p>
<h2 id="22-点击子组件，父组件触发事件"><a href="#22-点击子组件，父组件触发事件" class="headerlink" title="22. 点击子组件，父组件触发事件"></a>22. 点击子组件，父组件触发事件</h2><p>现在想要实现点击菜单的左边，能够实现在右边展示数据</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200430215649355.png" alt="image-20200430215649355"></p>
<p>父子组件传递数据：</p>
<p>1）子组件给父组件传递数据，事件机制；</p>
<p>在category中绑定node-click事件，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-tree :data=&quot;menus&quot; :props=&quot;defaultProps&quot; node-key=&quot;catId&quot; ref=&quot;menuTree&quot; @node-click=&quot;nodeClick&quot;	&gt;&lt;/el-tree&gt;</span><br></pre></td></tr></table></figure>

<p>2）子组件给父组件发送一个事件，携带上数据；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">nodeClick</span>(<span class="params">data,Node,component</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;子组件&quot;</span>,data,Node,component);</span><br><span class="line">   <span class="built_in">this</span>.$emit(<span class="string">&quot;tree-node-click&quot;</span>,data,Node,component);</span><br><span class="line">&#125;, </span><br></pre></td></tr></table></figure>

<p>this.$emit(事件名,”携带的数据”);</p>
<p>3）父组件中的获取发送的事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;category @tree-node-click=&quot;treeNodeClick&quot;&gt;&lt;/category&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取发送的事件数据</span></span><br><span class="line"><span class="function"><span class="title">treeNodeClick</span>(<span class="params">data,Node,component</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;attgroup感知到的category的节点被点击&quot;</span>,data,Node,component);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;刚才被点击的菜单ID&quot;</span>,data.catId);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h2 id="23-规格参数新增与VO"><a href="#23-规格参数新增与VO" class="headerlink" title="23. 规格参数新增与VO"></a>23. 规格参数新增与VO</h2><p>规格参数新增时，请求的URL：Request URL: </p>
<p><a href="http://localhost:88/api/product/attr/base/list/0?t=1588731762158&amp;page=1&amp;limit=10&amp;key=">http://localhost:88/api/product/attr/base/list/0?t=1588731762158&amp;page=1&amp;limit=10&amp;key=</a></p>
<p>当有新增字段时，我们往往会在entity实体类中新建一个字段，并标注数据库中不存在该字段，然而这种方式并不规范</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1588732021702.png" alt="1588732021702"></p>
<p>比较规范的做法是，新建一个vo文件夹，将每种不同的对象，按照它的功能进行了划分。在java中，涉及到了这几种类型</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1588732152646.png" alt="1588732152646"></p>
<p>Request URL: <a href="http://localhost:88/api/product/attr/save%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5%E6%98%AF%EF%BC%8C%E5%AE%83%E5%9C%A8%E4%BF%9D%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%BF%9D%E5%AD%98%E4%BA%86attr%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BF%9D%E5%AD%98attrgroup%EF%BC%8C%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E6%88%91%E4%BB%AC%E6%96%B0%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AAvo/AttrVo%EF%BC%8C%E5%9C%A8%E5%8E%9FAttrEntity%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%A2%9E%E5%8A%A0%E4%BA%86attrGroupId%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%BD%BF%E5%BE%97%E4%BF%9D%E5%AD%98%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B9%9F%E4%BF%9D%E5%AD%98%E4%BA%86%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82">http://localhost:88/api/product/attr/save，现在的情况是，它在保存的时候，只是保存了attr，并没有保存attrgroup，为了解决这个问题，我们新建了一个vo/AttrVo，在原AttrEntity基础上增加了attrGroupId字段，使得保存新增数据的时候，也保存了它们之间的关系。</a></p>
<p>通过” BeanUtils.copyProperties(attr,attrEntity);”能够实现在两个Bean之间拷贝数据，但是两个Bean的字段要相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAttr</span><span class="params">(AttrVo attr)</span> </span>&#123;</span><br><span class="line">     AttrEntity attrEntity = <span class="keyword">new</span> AttrEntity();</span><br><span class="line">     BeanUtils.copyProperties(attr,attrEntity);</span><br><span class="line">     <span class="keyword">this</span>.save(attrEntity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>问题：现在有两个查询，一个是查询部分，另外一个是查询全部，但是又必须这样来做吗？还是有必要的，但是可以在后台进行设计，两种查询是根据catId是否为零进行区分的。</p>
<h2 id="24-查询分组关联属性和删除关联"><a href="#24-查询分组关联属性和删除关联" class="headerlink" title="24. 查询分组关联属性和删除关联"></a>24. 查询分组关联属性和删除关联</h2><p>获取属性分组的关联的所有属性</p>
<p>API：<a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/LnjzZHPj">https://easydoc.xyz/doc/75716633/ZUqEdvA4/LnjzZHPj</a></p>
<p>发送请求：/product/attrgroup/{attrgroupId}/attr/relation</p>
<p>获取当前属性分组所关联的属性</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1588766303205.png" alt="1588766303205"></p>
<p>如何查找：既然给出了attr_group_id，那么到中间表中查询出来所关联的attr_id，然后得到最终的所有属性即可。</p>
<p>可能出现null值的问题</p>
<h2 id="25-查询分组未关联的属性"><a href="#25-查询分组未关联的属性" class="headerlink" title="25. 查询分组未关联的属性"></a>25. 查询分组未关联的属性</h2><p>/product/attrgroup/{attrgroupId}/noattr/relation</p>
<p>API：<a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/d3EezLdO">https://easydoc.xyz/doc/75716633/ZUqEdvA4/d3EezLdO</a></p>
<p>获取属性分组里面还没有关联的本分类里面的其他基本属性，方便添加新的关联</p>
<p>Request URL: <a href="http://localhost:88/api/product/attrgroup/1/noattr/relation?t=1588780783441&amp;page=1&amp;limit=10&amp;key=">http://localhost:88/api/product/attrgroup/1/noattr/relation?t=1588780783441&amp;page=1&amp;limit=10&amp;key=</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1588780868214.png" alt="1588780868214"></p>
<p>属性分组，对应于“pms_attr_group”表，每个分组下，需要查看到关联了哪些属性信息，销售属性不需要和分组进行关联，但是规格参数要和属性分组进行关联。</p>
<p>规格参数：对应于<code>pms_attr</code>表，attr_type=1，需要显示分组信息</p>
<p>销售属性：对应于pms_attr`表，attr_type=0，不需要显示分组信息</p>
<p>分组ID为9的分组：Request URL: <a href="http://localhost:88/api/product/attrgroup/9/noattr/relation?t=1588822258669&amp;page=1&amp;limit=10&amp;key=">http://localhost:88/api/product/attrgroup/9/noattr/relation?t=1588822258669&amp;page=1&amp;limit=10&amp;key=</a></p>
<p>对应的数据库字段</p>
<p>attr_group_id  attr_group_name    sort  descript                icon    catelog_id  </p>
<hr>
<pre><code>        9  主体                    1  型号 平台                   wu               454
       10  显卡                    1  显存容量                    wu               454
       11  输入设备                  1  鼠标 键盘                   wu               454
       12  主板                    1  显卡类型 芯片组                wu               454
       13  规格                    1  尺寸                      wu               454
</code></pre>
<p>查询attrgroupId=9的属性分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrgroupId);</span><br></pre></td></tr></table></figure>

<p>获取到分类信息：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Long catelogId = attrGroupEntity.getCatelogId()<span class="comment">;</span></span><br></pre></td></tr></table></figure>



<p>目标：获取属性分组没有关联的其他属性</p>
<p>也就是获取attrgroupId=9的属性分组中，关联的分类catelog_id =454 （台式机），其他基本属性</p>
<p>在该属性分组中，现在已经关联的属性：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1588822997675.png" alt="1588822997675"></p>
<p>本分类下，存在哪些基本属性？</p>
<p>没有关联的其他属性</p>
<p>已经关联的属性，这些属性是如何关联上的？</p>
<p>答：在创建规格参数的时候，已经设置了需要关联哪些属性分组。</p>
<p>想要知道还没有关联哪些，先查看关联了哪些，如何排除掉这些就是未关联的</p>
<p>在中间表中显示了属性和属性分组之间的关联关系，在属性表中显示了所有的属性，</p>
<p>先查询中间表，得到所有已经关联的属性的id，然后再次查询属性表，排除掉已经建立关联的属性ID，将剩下的属性ID和属性建立起关联关系</p>
<h2 id="26-添加属性和分组的关联关系"><a href="#26-添加属性和分组的关联关系" class="headerlink" title="26. 添加属性和分组的关联关系"></a>26. 添加属性和分组的关联关系</h2><p>请求类型：Request URL: <a href="http://localhost:88/api/product/attrgroup/attr/relation">http://localhost:88/api/product/attrgroup/attr/relation</a></p>
<p>请求方式：POST</p>
<p>请求数据：[{“attrId”:10,”attrGroupId”:9}]</p>
<p>API：<a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/VhgnaedC">https://easydoc.xyz/doc/75716633/ZUqEdvA4/VhgnaedC</a></p>
<p>响应数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;code&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本质就是在中间表pms_attr_attrgroup_relation中，添加一条记录的过程</p>
<h2 id="27-发布商品"><a href="#27-发布商品" class="headerlink" title="27. 发布商品"></a>27. 发布商品</h2><p>获取所有会员等级：/member/memberlevel/list</p>
<p>API：<a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/jCFganpf">https://easydoc.xyz/doc/75716633/ZUqEdvA4/jCFganpf</a></p>
<p>在“gulimall-gateway”中修改“”文件，添加对于member的路由</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gulimall-member</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://gulimall-member</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/member/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;/?.*),/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>



<p>在“gulimall-member”中，创建“bootstrap.properties”文件，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.name</span>=<span class="string">gulimall-member</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">192.168.137.14:8848</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">795521fa-77ef-411e-a8d8-0889fdfe6964</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">gulimall-member.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>



<p>获取分类关联的品牌：/product/categorybrandrelation/brands/list</p>
<p>API：<a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/HgVjlzWV">https://easydoc.xyz/doc/75716633/ZUqEdvA4/HgVjlzWV</a></p>
<p>遇到PubSub问题</p>
<ol>
<li>首先安装pubsub-js</li>
</ol>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">`npm install <span class="comment">--save pubsub-js`</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>订阅方组件</li>
</ol>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span>`</span><br></pre></td></tr></table></figure>

<p>该this.PubSub为PubSub。</p>
<p>获取分类下所有分组&amp;关联属性</p>
<p>请求类型：/product/attrgroup/{catelogId}/withattr</p>
<p>请求方式：GET</p>
<p>请求URL：<a href="http://localhost:88/api/product/attrgroup/225/withattr?t=1588864569478">http://localhost:88/api/product/attrgroup/225/withattr?t=1588864569478</a></p>
<p>mysql默认的隔离级别为读已提交，为了能够在调试过程中，获取到数据库中的数据信息，可以调整隔离级别为读未提交：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>

<p>但是它对于当前的事务窗口生效，如果想要设置全局的，需要加上global字段。</p>
<h2 id="28-商品管理"><a href="#28-商品管理" class="headerlink" title="28. 商品管理"></a>28. 商品管理</h2><p>当新建时：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">t:</span> <span class="number">1588983621569</span></span><br><span class="line"><span class="symbol">status:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">key:</span> </span><br><span class="line"><span class="symbol">brandId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">catelogId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">page:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">limit:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当上架时：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">t:</span> <span class="number">1588983754030</span></span><br><span class="line"><span class="symbol">status:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">key:</span> </span><br><span class="line"><span class="symbol">brandId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">catelogId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">page:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">limit:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当下架时：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">t:</span> <span class="number">1588983789089</span></span><br><span class="line"><span class="symbol">status:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">key:</span> </span><br><span class="line"><span class="symbol">brandId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">catelogId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">page:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">limit:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p>在SPU中，写出的日期数据都不符合规则：<br><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200509083248660.png" alt="image-20200509083248660"></p>
<p>想要符合规则，可以设置写出数据的规则：</p>
<p>spring.jackson</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jackson:</span></span><br><span class="line">  <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure>



<p>SKU检索：</p>
<p>Request URL: <a href="http://localhost:88/api/product/skuinfo/list?t=1588989437944&amp;page=1&amp;limit=10&amp;key=&amp;catelogId=0&amp;brandId=0&amp;min=0&amp;max=0">http://localhost:88/api/product/skuinfo/list?t=1588989437944&amp;page=1&amp;limit=10&amp;key=&amp;catelogId=0&amp;brandId=0&amp;min=0&amp;max=0</a></p>
<p>请求体：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">t:</span> <span class="number">1588989437944</span></span><br><span class="line"><span class="symbol">page:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">limit:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">key:</span> </span><br><span class="line"><span class="symbol">catelogId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">brandId:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">min:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">max:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>API： <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/ucirLq1D">https://easydoc.xyz/doc/75716633/ZUqEdvA4/ucirLq1D</a> </p>
<h2 id="29-仓库管理"><a href="#29-仓库管理" class="headerlink" title="29. 仓库管理"></a>29. 仓库管理</h2><p> 库存信息表：wms_ware_info</p>
<p>【1】仓库列表功能： </p>
<p>【2】查询商品库存：</p>
<p>【3】查询采购需求：</p>
<p>【4】 合并采购需求：</p>
<p>合并整单选中parcharseID：Request URL: <a href="http://localhost:88/api/ware/purchase/merge">http://localhost:88/api/ware/purchase/merge</a></p>
<p>请求数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;purchaseId: <span class="number">1</span>, items: [<span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line">items: [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<p>合并整单未选择parcharseID :Request URL: <a href="http://localhost:88/api/ware/purchase/merge">http://localhost:88/api/ware/purchase/merge</a></p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200509170916557.png" alt="image-20200509170916557"></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">items</span>:<span class="meta"> [1, 2]</span></span><br></pre></td></tr></table></figure>



<p>涉及到两张表：wms_purchase_detail，wms_purchase</p>
<p>现在采购单中填写数据，然后关联用户，关联用户后，</p>
<p>总的含义，就是根据采购单中的信息，更新采购需求，在采购单中填写采购人员，采购单号，采购的时候，更新采购细节表中的采购人员ID和采购状态。</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200509191108806.png" alt="image-20200509191108806"></p>
<p>领取采购单</p>
<p><a href="http://localhost:88/api/ware/purchase/received">http://localhost:88/api/ware/purchase/received</a></p>
<p>（1）某个人领取了采购单后，先看采购单是否处于未分配状态，只有采购单是新建或以领取状态时，才更新采购单的状态</p>
<p>（2）</p>
<p>【1】仓库列表功能： <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/mZgdqOWe">https://easydoc.xyz/doc/75716633/ZUqEdvA4/mZgdqOWe</a> </p>
<p>【2】查询商品库存： <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/hwXrEXBZ">https://easydoc.xyz/doc/75716633/ZUqEdvA4/hwXrEXBZ</a> </p>
<p>【3】查询采购需求： <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/Ss4zsV7R">https://easydoc.xyz/doc/75716633/ZUqEdvA4/Ss4zsV7R</a> </p>
<p>【4】 合并采购需求：<a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/cUlv9QvK">https://easydoc.xyz/doc/75716633/ZUqEdvA4/cUlv9QvK</a> </p>
<p>【5】查询未领取的采购单： <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/hI12DNrH">https://easydoc.xyz/doc/75716633/ZUqEdvA4/hI12DNrH</a> </p>
<p>【6】领取采购单： <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/vXMBBgw1">https://easydoc.xyz/doc/75716633/ZUqEdvA4/vXMBBgw1</a> </p>
<p>完成采购，在完成采购过程中，需要涉及到设置SKU的name信息到仓库中，这是通过远程调用“gulimall-product”来实现根据sku_id查询得到sku_name的，如果这个过程发生了异常，事务不想要回滚，目前采用的方式是通过捕获异常的方式，防止事务回滚，是否还有其他的方式呢？这个问题留待以后解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStock</span><span class="params">(Long skuId, Long wareId, Integer skuNum)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;WareSkuEntity&gt; wareSkuEntities = wareSkuDao.selectList(<span class="keyword">new</span> QueryWrapper&lt;WareSkuEntity&gt;().eq(<span class="string">&quot;sku_id&quot;</span>, skuId).eq(<span class="string">&quot;ware_id&quot;</span>, wareId));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(wareSkuEntities == <span class="keyword">null</span> || wareSkuEntities.size() ==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">           WareSkuEntity wareSkuEntity = <span class="keyword">new</span> WareSkuEntity();</span><br><span class="line">           wareSkuEntity.setSkuId(skuId);</span><br><span class="line">           wareSkuEntity.setWareId(wareId);</span><br><span class="line">           wareSkuEntity.setStock(skuNum);</span><br><span class="line">           wareSkuEntity.setStockLocked(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//远程查询SKU的name，若失败无需回滚</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               R info = productFeignService.info(skuId);</span><br><span class="line">               <span class="keyword">if</span>(info.getCode() == <span class="number">0</span>)&#123;</span><br><span class="line">                   Map&lt;String,Object&gt; data=(Map&lt;String,Object&gt;)info.get(<span class="string">&quot;skuInfo&quot;</span>);</span><br><span class="line">                   wareSkuEntity.setSkuName((String) data.get(<span class="string">&quot;skuName&quot;</span>));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           wareSkuDao.insert(wareSkuEntity);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//插入</span></span><br><span class="line">           wareSkuDao.addStock(skuId,wareId,skuNum);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="30-获取spu规格"><a href="#30-获取spu规格" class="headerlink" title="30. 获取spu规格"></a>30. 获取spu规格</h2><p>在SPU管理页面，获取商品规格的时候，出现400异常，浏览器显示跳转不了</p>
<p>问题现象：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200510182051355.png" alt="image-20200510182051355"></p>
<p>出现问题的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">attrUpdateShow</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(row);</span><br><span class="line">  <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/product-attrupdate&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123; <span class="attr">spuId</span>: row.id, <span class="attr">catalogId</span>: row.catalogId &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>暂时不知道如何解决问题。只能留待以后解决。</p>
<p>经过测试发现，问题和上面的代码没有关系，问题出现在“attrupdate.vue”上，该vue页面无法通过浏览器访问，当输入访问URL（ <a href="http://localhost:8001/#/product-attrupdate">http://localhost:8001/#/product-attrupdate</a> ）的时候，就会出现404，而其他的请求则不会出现这种情况，不知为何。</p>
<p>通过POSTMAN进行请求的时候，能够请求到数据。</p>
<p>经过分析发现，是因为在数据库中没有该页面的导航所导致的，为了修正这个问题，可以在“sys-menu”表中添加一行，内容位：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200510231012714.png" alt="image-20200510231012714"></p>
<p>这样当再次访问的时候，在“平台属性”下，会出现“规格维护”菜单，</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200510231041708.png" alt="image-20200510231041708"></p>
<p>当再次点击“规格”的时候，显示出菜单</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200510231200130.png" alt="image-20200510231200130"></p>
<p>不过这种菜单并不符合我们的需要，我们需要让它以弹出框的形式出现。</p>
<h2 id="31-修改商品规格"><a href="#31-修改商品规格" class="headerlink" title="31. 修改商品规格"></a>31. 修改商品规格</h2><p>API： <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/GhnJ0L85">https://easydoc.xyz/doc/75716633/ZUqEdvA4/GhnJ0L85</a> </p>
<p>URL：/product/attr/update/{spuId}</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><h3 id="1-在open-fen中会将调用的数据转换为JSON，接收方接收后，将JSON转换为对象，此时调用方和被调用方的处理JSON的对象不一定都是同一个类，只要它们的字段类型吻合即可。"><a href="#1-在open-fen中会将调用的数据转换为JSON，接收方接收后，将JSON转换为对象，此时调用方和被调用方的处理JSON的对象不一定都是同一个类，只要它们的字段类型吻合即可。" class="headerlink" title="1.  在open fen中会将调用的数据转换为JSON，接收方接收后，将JSON转换为对象，此时调用方和被调用方的处理JSON的对象不一定都是同一个类，只要它们的字段类型吻合即可。"></a>1.  在open fen中会将调用的数据转换为JSON，接收方接收后，将JSON转换为对象，此时调用方和被调用方的处理JSON的对象不一定都是同一个类，只要它们的字段类型吻合即可。</h3><p>调用方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;gulimall-coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CouponFenService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/coupon/spubounds/save&quot;)</span></span><br><span class="line">    <span class="function">R <span class="title">saveSpuBounds</span><span class="params">(<span class="meta">@RequestBody</span> SpuBoundTo spuBoundTo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/coupon/skufullreduction/saveInfo&quot;)</span></span><br><span class="line">    <span class="function">R <span class="title">saveSkuReduction</span><span class="params">(<span class="meta">@RequestBody</span> SkuReductionTo skuReductionTo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被调用方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@RequestBody</span> SpuBoundsEntity spuBounds)</span></span>&#123;</span><br><span class="line">spuBoundsService.save(spuBounds);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> R.ok();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(&quot;/saveInfo&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> R <span class="title">saveInfo</span><span class="params">(<span class="meta">@RequestBody</span> SkuReductionTo skuReductionTo)</span></span>&#123;</span><br><span class="line">      skuFullReductionService.saveSkuReduction(skuReductionTo);</span><br><span class="line">      <span class="keyword">return</span> R.ok();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>调用方JSON化时的对象SpuBoundTo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpuBoundTo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long spuId;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal buyBounds;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal growBounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被调用方JSON数据对象化时的对象SpuBoundsEntity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品spu积分设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cosmoswong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> cosmoswong@sina.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-23 23:38:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;sms_spu_bounds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpuBoundsEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * id</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@TableId</span></span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Long spuId;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 成长积分</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> BigDecimal growBounds;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 购物积分</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> BigDecimal buyBounds;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 优惠生效情况[1111（四个状态位，从右到左）;0 - 无优惠，成长积分是否赠送;1 - 无优惠，购物积分是否赠送;2 - 有优惠，成长积分是否赠送;3 - 有优惠，购物积分是否赠送【状态位0：不赠送，1：赠送】]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Integer work;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-事务究竟要如何加上？"><a href="#2-事务究竟要如何加上？" class="headerlink" title="2. 事务究竟要如何加上？"></a>2. 事务究竟要如何加上？</h3><p>存在Batch操作的时候，才需要加上事务，单个操作无需添加事务控制。</p>
<p>SpringBoot中的是事务</p>
<p>批量操作的时候，才需要事务</p>
<p>一个事务标注的方法上，方法内存在这些操作：</p>
<p>（1）批量更新一个表中字段</p>
<p>（2）更新多张表中的操作</p>
<p>实际上不论是哪种类型，方法中所有对于数据库的写操作，都会被整体当做一个事务，在这个事务过程中，如果某个操作出现了异常，则整体都不会被提交。这就是对于SpringBoot中的@Transactional的理解。</p>
<p>@EnableTransactionManagement和@Transactional的区别？</p>
<p> <a href="https://blog.csdn.net/abysscarry/article/details/80189232">https://blog.csdn.net/abysscarry/article/details/80189232</a><br> <a href="https://blog.csdn.net/Driver_tu/article/details/99679145">https://blog.csdn.net/Driver_tu/article/details/99679145</a> </p>
<p> <a href="https://www.cnblogs.com/leaveast/p/11765503.html">https://www.cnblogs.com/leaveast/p/11765503.html</a> </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-文档参考地址"><a href="#1-文档参考地址" class="headerlink" title="1. 文档参考地址"></a>1. 文档参考地址</h3><p> <a href="http://www.jayh.club/#/02.PassJava%E6%9E%B6%E6%9E%84%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97">http://www.jayh.club/#/02.PassJava%E6%9E%B6%E6%9E%84%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97</a> </p>
<p> <a href="https://blog.csdn.net/ok_wolf/article/details/105400748">https://blog.csdn.net/ok_wolf/article/details/105400748</a> </p>
<p><a href="https://www.cnblogs.com/javalbb/p/12690862.html">https://www.cnblogs.com/javalbb/p/12690862.html</a></p>
<p> <a href="https://blog.csdn.net/ok_wolf/article/details/105456170">https://blog.csdn.net/ok_wolf/article/details/105456170</a> </p>
<p> <a href="https://easydoc.xyz/doc/75716633/ZUqEdvA4/jCFganpf">https://easydoc.xyz/doc/75716633/ZUqEdvA4/jCFganpf</a> </p>
<h3 id="2-开机启动docker"><a href="#2-开机启动docker" class="headerlink" title="2. 开机启动docker"></a>2. 开机启动docker</h3><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200422221237751.png" alt="image-20200422221237751"></p>
<p>在Docker中设置开机启动容器</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200423005200485.png" alt="image-20200423005200485"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看防火墙状态</span></span><br><span class="line">[root@hadoop-104 module]# systemctl status firewalld</span><br><span class="line">  firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2020-04-22 21:26:23 EDT; 10min ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 5947 (firewalld)</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─5947 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line"></span><br><span class="line">Apr 22 21:26:20 hadoop-104 systemd[1]: Starting firewalld - dynamic firewall daemon...</span><br><span class="line">Apr 22 21:26:23 hadoop-104 systemd[1]: Started firewalld - dynamic firewall daemon.</span><br><span class="line"><span class="meta">#</span><span class="bash">查看防火墙是否是开机启动</span></span><br><span class="line">[root@hadoop-104 module]# systemctl list-unit-files|grep firewalld</span><br><span class="line">firewalld.service                             enabled </span><br><span class="line"><span class="meta">#</span><span class="bash">关闭开机启动防火墙</span></span><br><span class="line">[root@hadoop-104 module]# systemctl disable firewalld             </span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line"><span class="meta">#</span><span class="bash">停止防火墙</span></span><br><span class="line">[root@hadoop-104 module]# systemctl stop firewalld         </span><br><span class="line"><span class="meta">#</span><span class="bash">再次查看防火墙</span></span><br><span class="line">[root@hadoop-104 module]# systemctl list-unit-files|grep firewalld</span><br><span class="line">firewalld.service                             disabled</span><br><span class="line">[root@hadoop-104 module]# </span><br></pre></td></tr></table></figure>



<h3 id="3-查看命令的安装位置"><a href="#3-查看命令的安装位置" class="headerlink" title="3. 查看命令的安装位置"></a>3. 查看命令的安装位置</h3><p>whereis mysql：查看mysql的安装位置</p>
<h3 id="4-vscode中生成代码片段"><a href="#4-vscode中生成代码片段" class="headerlink" title="4. vscode中生成代码片段"></a>4. vscode中生成代码片段</h3><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425165814903.png" alt="image-20200425165814903"></p>
<p>新建一个全局的代码片段，名字为vue，然后回车：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200425165929332.png" alt="image-20200425165929332"></p>
<p>将下面的代码片段粘贴到“vue.code-snippets”</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Place your 全局 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and </span></span><br><span class="line">    <span class="comment">// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope </span></span><br><span class="line">    <span class="comment">// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is </span></span><br><span class="line">    <span class="comment">// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: </span></span><br><span class="line">    <span class="comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. </span></span><br><span class="line">    <span class="comment">// Placeholders with the same ids are connected.</span></span><br><span class="line">    <span class="comment">// Example:</span></span><br><span class="line">    <span class="comment">// &quot;Print to console&quot;: &#123;</span></span><br><span class="line">    <span class="comment">// 	&quot;scope&quot;: &quot;javascript,typescript&quot;,</span></span><br><span class="line">    <span class="comment">// 	&quot;prefix&quot;: &quot;log&quot;,</span></span><br><span class="line">    <span class="comment">// 	&quot;body&quot;: [</span></span><br><span class="line">    <span class="comment">// 		&quot;console.log(&#x27;$1&#x27;);&quot;,</span></span><br><span class="line">    <span class="comment">// 		&quot;$2&quot;</span></span><br><span class="line">    <span class="comment">// 	],</span></span><br><span class="line">    <span class="comment">// 	&quot;description&quot;: &quot;Log output to console&quot;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="attr">&quot;生成vue模板&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span>: <span class="string">&quot;vue&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;&lt;!-- $1 --&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;template&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;div class=&#x27;$2&#x27;&gt;$5&lt;/div&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;/template&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;script&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//例如：import 《组件名称》 from &#x27;《组件路径》&#x27;;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;export default &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//import引入的组件需要注入到对象中才能使用&quot;</span>,</span><br><span class="line">            <span class="string">&quot;components: &#123;&#125;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;data() &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//这里存放数据&quot;</span>,</span><br><span class="line">            <span class="string">&quot;return &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//监听属性 类似于data概念&quot;</span>,</span><br><span class="line">            <span class="string">&quot;computed: &#123;&#125;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//监控data中的数据变化&quot;</span>,</span><br><span class="line">            <span class="string">&quot;watch: &#123;&#125;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//方法集合&quot;</span>,</span><br><span class="line">            <span class="string">&quot;methods: &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//生命周期 - 创建完成（可以访问当前this实例）&quot;</span>,</span><br><span class="line">            <span class="string">&quot;created() &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//生命周期 - 挂载完成（可以访问DOM元素）&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mounted() &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;beforeCreate() &#123;&#125;, //生命周期 - 创建之前&quot;</span>,</span><br><span class="line">            <span class="string">&quot;beforeMount() &#123;&#125;, //生命周期 - 挂载之前&quot;</span>,</span><br><span class="line">            <span class="string">&quot;beforeUpdate() &#123;&#125;, //生命周期 - 更新之前&quot;</span>,</span><br><span class="line">            <span class="string">&quot;updated() &#123;&#125;, //生命周期 - 更新之后&quot;</span>,</span><br><span class="line">            <span class="string">&quot;beforeDestroy() &#123;&#125;, //生命周期 - 销毁之前&quot;</span>,</span><br><span class="line">            <span class="string">&quot;destroyed() &#123;&#125;, //生命周期 - 销毁完成&quot;</span>,</span><br><span class="line">            <span class="string">&quot;activated() &#123;&#125;, //如果页面有keep-alive缓存功能，这个函数会触发&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;/script&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;style lang=&#x27;scss&#x27; scoped&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;//@import url($3); 引入公共css类&quot;</span>,</span><br><span class="line">            <span class="string">&quot;$4&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;/style&gt;&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;生成VUE模板&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;http-get请求&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span>: <span class="string">&quot;httpget&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;this.\\$http(&#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span>,</span><br><span class="line">            <span class="string">&quot;method: &#x27;get&#x27;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;params: this.\\$http.adornParams(&#123;&#125;)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;)&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;httpGET请求&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;http-post请求&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span>: <span class="string">&quot;httppost&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;this.\\$http(&#123;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span>,</span><br><span class="line">            <span class="string">&quot;method: &#x27;post&#x27;,&quot;</span>,</span><br><span class="line">            <span class="string">&quot;data: this.\\$http.adornData(data, false)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123; &#125;);&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;httpPOST请求&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多详细说明见： <a href="https://blog.csdn.net/z772330927/article/details/105730430/">https://blog.csdn.net/z772330927/article/details/105730430/</a> </p>
<h3 id="5-vscode快捷键"><a href="#5-vscode快捷键" class="headerlink" title="5. vscode快捷键"></a>5. vscode快捷键</h3><p>ctrl+shift+f 全局搜索</p>
<p>alt+shift+f 格式化代码</p>
<h3 id="6-关闭eslint的语法检查"><a href="#6-关闭eslint的语法检查" class="headerlink" title="6.  关闭eslint的语法检查"></a>6.  关闭eslint的语法检查</h3><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200428171043110.png" alt="image-20200428171043110"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-安装mybatisx插件"><a href="#7-安装mybatisx插件" class="headerlink" title="7. 安装mybatisx插件"></a>7. 安装mybatisx插件</h3><p>在Marketplace中搜索“mybatisx”，安装后重启IDEA，使用时会自动在@Mapper标注的接口上，产生小图标，然后alt+enter，generate statement，就会自动的在xml文件中生成SQL。</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/1588730028929.png" alt="1588730028929"></p>
<h3 id="8-mysql的批量删除"><a href="#8-mysql的批量删除" class="headerlink" title="8. mysql的批量删除"></a>8. mysql的批量删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span>  `pms_attr_attrgroup_relation` <span class="keyword">WHERE</span> (attr_id<span class="operator">=</span> ? <span class="keyword">AND</span> attr_group_id ) <span class="keyword">OR</span> (attr_id<span class="operator">=</span> ? <span class="keyword">AND</span> attr_group_id )</span><br></pre></td></tr></table></figure>



<h3 id="9-String-join"><a href="#9-String-join" class="headerlink" title="9. String.join"></a>9. String.join</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.String <span class="meta">@NotNull</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(<span class="meta">@NotNull</span> CharSequence delimiter,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@NotNull</span> Iterable&lt;? extends CharSequence&gt; elements)</span></span></span><br></pre></td></tr></table></figure>

<p>Returns a new String composed of copies of the CharSequence elements joined together with a copy of the specified delimiter.</p>
<p> 返回一个由CharSequence元素的副本和指定分隔符的副本组成的新字符串。 </p>
<p>For example,</p>
<pre><code> List&lt;String&gt; strings = new LinkedList&lt;&gt;();
 strings.add(&quot;Java&quot;);strings.add(&quot;is&quot;);
 strings.add(&quot;cool&quot;);
 String message = String.join(&quot; &quot;, strings);
 //message returned is: &quot;Java is cool&quot;

 Set&lt;String&gt; strings = new LinkedHashSet&lt;&gt;();
 strings.add(&quot;Java&quot;); strings.add(&quot;is&quot;);
 strings.add(&quot;very&quot;); strings.add(&quot;cool&quot;);
 String message = String.join(&quot;-&quot;, strings);
 //message returned is: &quot;Java-is-very-cool&quot;
</code></pre>
<p>Note that if an individual element is null, then “null” is added.</p>
<p> 注意，如果单个元素为null，则添加“null”。 </p>
<p>Params:<br>delimiter – a sequence of characters that is used to separate each of the elements in the resulting String<br>               用于分隔结果字符串中的每个元素的字符序列 </p>
<p>elements – an Iterable that will have its elements joined together.<br>                  将其元素连接在一起的可迭代的。 </p>
<p>Returns:<br>a new String that is composed from the elements argument<br> 由elements参数组成的新字符串 </p>
<p>Throws:<br>NullPointerException – If delimiter or elements is null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter,</span></span></span><br><span class="line"><span class="params"><span class="function">        Iterable&lt;? extends CharSequence&gt; elements)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);</span><br><span class="line">    <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够看到实际上它就是通过创建StringJoiner，然后遍历elements，加入每个元素来完成的。</p>
<p>StringJoiner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringJoiner</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<p>StringJoiner is used to construct a sequence of characters separated by a delimiter and optionally starting with a supplied prefix and ending with a supplied suffix.<br> tringJoiner用于构造由分隔符分隔的字符序列，可以选择以提供的前缀开始，以提供的后缀结束。 </p>
<p>Prior to adding something to the StringJoiner, its sj.toString() method will, by default, return prefix + suffix. However, if the setEmptyValue method is called, the emptyValue supplied will be returned instead. This can be used, for example, when creating a string using set notation to indicate an empty set, i.e. “{}”, where the prefix is “{“, the suffix is “}” and nothing has been added to the StringJoiner.<br> 在向StringJoiner添加内容之前，它的sj.toString()方法在默认情况下会返回前缀+后缀。但是，如果调用setEmptyValue方法，则返回所提供的emptyValue。例如，当使用set符号创建一个字符串来表示一个空集时，可以使用这种方法。“{}”，其中前缀是“{”，后缀是“}”，没有向StringJoiner添加任何内容。 </p>
<p>apiNote:<br>The String “[George:Sally:Fred]” may be constructed as follows:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>);</span><br><span class="line">sj.add(<span class="string">&quot;George&quot;</span>).add(<span class="string">&quot;Sally&quot;</span>).add(<span class="string">&quot;Fred&quot;</span>);</span><br><span class="line">String desiredString = sj.toString();</span><br></pre></td></tr></table></figure>

<p>A StringJoiner may be employed to create formatted output from a java.util.stream.Stream using java.util.stream.Collectors.joining(CharSequence). For example:<br> 使用StringJoiner从java.util.stream创建格式化输出流，使用java.util.stream.Collectors.joining (CharSequence进行)。例如: </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(1, 2, 3, 4)</span>;</span><br><span class="line">String commaSeparatedNumbers = numbers.stream<span class="literal">()</span></span><br><span class="line">    .map(i -&gt; i.<span class="keyword">to</span><span class="constructor">String()</span>)</span><br><span class="line">    .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span>joining(<span class="string">&quot;, &quot;</span>));</span><br></pre></td></tr></table></figure>



<p>通过分析源码发现，在“”内部维护了一个StringBuilder，所有加入到它内部的元素都会先拼接上分割符，然后再拼接上加入的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">add</span><span class="params">(CharSequence newElement)</span> </span>&#123;</span><br><span class="line">       prepareBuilder().append(newElement);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">prepareBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">         value.append(delimiter);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         value = <span class="keyword">new</span> StringBuilder().append(prefix);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h3 id="10-在Service中微服务比较多的时候，可以配置将一些微服务放置到compound中，组成一个小组"><a href="#10-在Service中微服务比较多的时候，可以配置将一些微服务放置到compound中，组成一个小组" class="headerlink" title="10. 在Service中微服务比较多的时候，可以配置将一些微服务放置到compound中，组成一个小组"></a>10. 在Service中微服务比较多的时候，可以配置将一些微服务放置到compound中，组成一个小组</h3><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200508222508833.png" alt="image-20200508222508833"></p>
<p>以后再运行时，直接选择这个compound即可很方便的运行或停止一组微服务：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200508223524543.png" alt="image-20200508223524543"></p>
<p>另外可以单独为每个微服务，设置需要的运行时最大堆内存大小：</p>
<p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/image-20200508222812353.png" alt="image-20200508222812353"></p>
<h3 id="11-mysql的dateTime和timestamp的区别？"><a href="#11-mysql的dateTime和timestamp的区别？" class="headerlink" title="11. mysql的dateTime和timestamp的区别？"></a>11. mysql的dateTime和timestamp的区别？</h3><p><a href="https://www.cnblogs.com/mxwz/p/7520309.html">MySQL中datetime和timestamp的区别及使用</a></p>
<p><strong>TIMESTAMP和DATETIME的相同点：</strong></p>
<p>1&gt; 两者都可用来表示YYYY-MM-DD HH:MM:SS[.fraction]类型的日期。</p>
<p><strong>TIMESTAMP和DATETIME的不同点：</strong></p>
<p>1&gt; 两者的存储方式不一样</p>
<p>对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。</p>
<p>而对于DATETIME，不做任何改变，基本上是原样输入和输出。</p>
<p>2&gt; 两者所能存储的时间范围不一样</p>
<p>timestamp所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’。</p>
<p>datetime所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</p>
<p>总结：TIMESTAMP和DATETIME除了存储范围和存储方式不一样，没有太大区别。当然，对于跨时区的业务，TIMESTAMP更为合适。</p>
<p> <a href="https://www.cnblogs.com/Jashinck/p/10472398.html">https://www.cnblogs.com/Jashinck/p/10472398.html</a> </p>
<h3 id="12-SpringBoot中的事务"><a href="#12-SpringBoot中的事务" class="headerlink" title="12. SpringBoot中的事务"></a>12. SpringBoot中的事务</h3><p> <a href="https://blog.csdn.net/Z__Sheng/article/details/89489053">https://blog.csdn.net/Z__Sheng/article/details/89489053</a> </p>
<h3 id="13-IDEA-RESTFUll-clinet"><a href="#13-IDEA-RESTFUll-clinet" class="headerlink" title="13. IDEA RESTFUll clinet"></a>13. IDEA RESTFUll clinet</h3><p><a href="https://blog.csdn.net/qq_37502106/article/details/103183492">IntelliJ IDEA 使用 rest client</a></p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="1-TypeError-vm-previewHandle-is-not-a-function"><a href="#1-TypeError-vm-previewHandle-is-not-a-function" class="headerlink" title="1. TypeError: _vm.previewHandle is not a function"></a>1. TypeError: _vm.previewHandle is not a function</h3>]]></content>
      <categories>
        <category>谷粒商城项目</category>
      </categories>
      <tags>
        <tag>谷粒商城第一阶段</tag>
      </tags>
  </entry>
  <entry>
    <title>谷粒商城</title>
    <url>/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[<h1 id="分布式基础篇"><a href="#分布式基础篇" class="headerlink" title="分布式基础篇"></a>分布式基础篇</h1><h2 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h2><h3 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1.项目背景"></a>1.项目背景</h3><h4 id="1-1-电商模式"><a href="#1-1-电商模式" class="headerlink" title="1.1 电商模式"></a>1.1 电商模式</h4><p>市面上有 5 种常见的电商模式 B2B、B2C、C2B、C2C、O2O；</p>
<ol>
<li>B2B: B2B (Business to Business)， 是指商家与商家建立的商业关系。 如：阿里巴巴</li>
<li>B2C: B2C (Business to Consumer)， 就是我们经常看到的供应商直接把商品卖给用户，即“商对客” 模式，也就是通常说的商业零售，直接面向消费者销售产品和服务。如：苏宁易购、京东、 天猫、小米商城</li>
<li>C2B：C2B (Customer to Business)，即消费者对企业。先有消费者需求产生而后有企业生产，即先 有消费者提出需求，后有生产企业按需求组织生产</li>
<li>C2C:  C2C (Customer to Consumer) ，客户之间自己把东西放上网去卖，如：淘宝，闲鱼</li>
<li>O2O：O2O 即 Online To Offline，也即将线下商务的机会与互联网结合在了一起，让互联网成为线 下交易的前台。线上快速支付，线下优质服务。如：饿了么，美团，淘票票，京东到家</li>
</ol>
<p><strong>谷粒商城是一个 B2C 模式的电商平台，商家销售自营商品给客户。</strong></p>
<h3 id="2-项目架构图"><a href="#2-项目架构图" class="headerlink" title="2. 项目架构图"></a>2. 项目架构图</h3><h4 id="2-1、项目微服务架构图"><a href="#2-1、项目微服务架构图" class="headerlink" title="2.1、项目微服务架构图"></a>2.1、项目微服务架构图</h4><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="谷粒商城微服务架构图"></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">前后分离开发，分为内网部署和外网部署，外网是面向公众访问的。</span><br><span class="line">访问前端项目，可以有手机APP，电脑网页；内网部署的是后端集群，</span><br><span class="line">前端在页面上操作发送请求到后端，在这途中会经过Nginx集群，</span><br><span class="line">Nginx把请求转交给API网关(springcloud gateway)（网关可以根据当</span><br><span class="line">前请求动态地路由到指定的服务，看当前请求是想调用商品服务还是购</span><br><span class="line">物车服务还是检索服务），从路由过来如果请求很多，可以负载均衡地调</span><br><span class="line">用商品服务器中一台（商品服务复制了多份），当商品服务器出现问题也</span><br><span class="line">可以在网关层面对服务进行熔断或降级（使用阿里的sentinel组件），网关</span><br><span class="line">还有其他的功能如认证授权、限流（只放行部分到服务器）等。</span><br><span class="line"></span><br><span class="line">到达服务器后进行处理（springboot为微服务），服务与服务可能会相互</span><br><span class="line">调用（使用feign组件），有些请求可能经过登录才能进行（基于OAuth2<span class="number">.0</span>的</span><br><span class="line">认证中心。安全和权限使用springSecurity控制）</span><br><span class="line"></span><br><span class="line">服务可能保存了一些数据或者需要使用缓存，我们使用redis集群（分片+哨兵集</span><br><span class="line">群）。持久化使用mysql，读写分离和分库分表。</span><br><span class="line"></span><br><span class="line">服务和服务之间会使用消息队列（RabbitMQ），来完成异步解耦，分布式事务</span><br><span class="line">的一致性。有些服务可能需要全文检索，检索商品信息，使用ElaticSearch。</span><br><span class="line"></span><br><span class="line">服务可能需要存取数据，使用阿里云的对象存储服务OSS。</span><br><span class="line"></span><br><span class="line">项目上线后为了快速定位问题，使用ELK对日志进行处理，使用LogStash收</span><br><span class="line">集业务里的各种日志，把日志存储到<span class="built_in">ES</span>中，用Kibana可视化页面从<span class="built_in">ES</span>中检</span><br><span class="line">索出相关信息，帮助我们快速定位问题所在。</span><br><span class="line"></span><br><span class="line">在分布式系统中，由于我们每个服务都可能部署在很多台机器，服务和服务</span><br><span class="line">可能相互调用，就得知道彼此都在哪里，所以需要将所有服务都注册到注册</span><br><span class="line">中心。服务从注册中心发现其他服务所在位置（使用阿里Nacos作为注册</span><br><span class="line">中心）。</span><br><span class="line"></span><br><span class="line">每个服务的配置众多，为了实现改一处配置相同配置就同步更改，就需要配</span><br><span class="line">置中心，也使用阿里的Nacos，服务从配置中心中动态取配置。</span><br><span class="line"></span><br><span class="line">服务追踪，追踪服务调用链哪里出现问题，使用springcloud提供的Sleuth、</span><br><span class="line">Zipkin、Metrics，把每个服务的信息交给开源的Prometheus进行聚合分析，</span><br><span class="line">再由Grafana进行可视化展示，提供Prometheus提供的AlterManager实时</span><br><span class="line">得到服务的警告信息，以短信/邮件的方式告知服务开发人员。</span><br><span class="line"></span><br><span class="line">还提供了持续集成和持续部署。项目发布起来后，因为微服务众多，每一个都打</span><br><span class="line">包部署到服务器太麻烦，有了持续集成后开发人员可以将修改后的代码提交到</span><br><span class="line">github，运维人员可以通过自动化工具Jenkins Pipeline将github中获取的代码打</span><br><span class="line">包成docker镜像，最终是由k8s集成docker服务，将服务以docker容器的方式运行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="2-2、微服务划分图"><a href="#2-2、微服务划分图" class="headerlink" title="2.2、微服务划分图"></a>2.2、微服务划分图</h4><p><img src="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%92%E5%88%86%E5%9B%BE.png" alt="微服务划分图"></p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">反映了需要创建的微服务以及相关技术。</span><br><span class="line"></span><br><span class="line">前后分离开发。前端项目分为admin-vue（工作人员使用的后台管理系统）、</span><br><span class="line"><span class="keyword">shop-vue（面向公众访问的web网站）、app（公众）、小程序（公众）</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">商品服务：商品的增删改查、商品的上下架、商品详情</span><br><span class="line">支付服务</span><br><span class="line">优惠服务</span><br><span class="line">用户服务：用户的个人中心、收货地址</span><br><span class="line">仓储服务：商品的库存</span><br><span class="line">秒杀服务</span><br><span class="line">订单服务：订单增删改查</span><br><span class="line">检索服务：商品的检索ES</span><br><span class="line">中央认证服务：登录、注册、单点登录、社交登录</span><br><span class="line">购物车服务</span><br><span class="line">后台管理系统：添加优惠信息等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<h4 id="2-3、项目技术-amp-特色"><a href="#2-3、项目技术-amp-特色" class="headerlink" title="2.3、项目技术&amp;特色"></a>2.3、项目技术&amp;特色</h4><figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line">前后分离开发，并开发基于vue的后台管理系统</span><br><span class="line">SpringCloud全新的解决方案</span><br><span class="line">应用监控、限流、网关、熔断降级等分布式方案，全方位涉及</span><br><span class="line">透彻讲解分布式事务，分布式锁等分布式系统的难点</span><br><span class="line">压力测试与性能优化</span><br><span class="line">各种集群技术的区别以及使用</span><br><span class="line">CI/CD 使用</span><br><span class="line"><span class="meta">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4、项目前置要求"><a href="#2-4、项目前置要求" class="headerlink" title="2.4、项目前置要求"></a>2.4、项目前置要求</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">熟悉SpringBoot以及常见整合方案</span><br><span class="line">了解SpringCloud</span><br><span class="line">熟悉 git  maven</span><br><span class="line">熟悉 linux redis docker 基本操作</span><br><span class="line">了解 <span class="selector-tag">html</span>，css，js，vue</span><br><span class="line">熟练使用idea开发项目</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、分布式基础概念"><a href="#二、分布式基础概念" class="headerlink" title="二、分布式基础概念"></a>二、分布式基础概念</h2><h3 id="2-1-微服务"><a href="#2-1-微服务" class="headerlink" title="2.1 微服务"></a>2.1 微服务</h3><p>&emsp;&emsp;微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自 己的进程中，并使用轻量级机制通信，通常是 HTTP API。这些服务围绕业务能力来构建， 并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据 存储技术，并保持最低限度的集中式管理。 </p>
<p><strong>简而言之：拒绝大型单体应用，基于业务边界进行服务微化拆分，各个服务独立部署运行。</strong></p>
<h3 id="2-2-集群-amp-分布式-amp-节点"><a href="#2-2-集群-amp-分布式-amp-节点" class="headerlink" title="2.2 集群&amp;分布式&amp;节点"></a>2.2 集群&amp;分布式&amp;节点</h3><p>&emsp;&emsp;集群是个物理状态，分布式是个工作方式，只要是一堆机器，也可以叫做集群，他们是不是一起协作干活，这谁也不知道。</p>
<p>《分布式系统原理与范型》定义：</p>
<p>&emsp;&emsp;分布式系统是若干独立计算机的集合，这些计算机对于用户来说像单个系统,<br>分布式系统 (distributed system) 是建立网络之上的软件系统</p>
<p>分布式是指根据不同的业务分布在不同的地方,集群指的是将几台服务器集中在一起，实现同一业务</p>
<p>例如：京东是一个分布式系统，众多业务运行在不同的机器上，所有业务构成<br>一个大型的分布式业务集群，每一个小的业务，比如用户系统，访问压力大的<br>时候一台服务器是不够的，我们就应该将用户系统部署到多个服务器，也就是<br>每一个业务系统也可以做集群化</p>
<p>分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的</p>
<p>节点：集群中的一个服务器</p>
<h3 id="2-3-远程调用-OpenFein"><a href="#2-3-远程调用-OpenFein" class="headerlink" title="2.3 远程调用(OpenFein)"></a>2.3 远程调用(OpenFein)</h3><p>&emsp;&emsp;在分布式系统中，各个服务可能处于不同主机，但是服务之间不可避免的需要<br>互相调用，我们称之为远程调用，SpringCloud中使用HTTP+JSON的方式来完成远程调用。</p>
<h3 id="2-4-负载均衡"><a href="#2-4-负载均衡" class="headerlink" title="2.4 负载均衡"></a>2.4 负载均衡</h3><p>分布式系统中，A 服务需要调用B服务，B服务在多台机器中都存在，<br>A调用任意一个服务器均可完成功能</p>
<p>为了使每一个服务器都不要太忙或者太闲，我们可以负载均衡调用每一个服务器，<br>提升网站的健壮性</p>
<p>常见的负载均衡算法：<br><strong>轮询：</strong>为第一个请求选择健康池中的每一个后端服务器，然后按顺序往后依<br>次选择，直到最后一个，然后循环</p>
<p><strong>最小连接：</strong>优先选择链接数最少，也就是压力最小的后端服务器，在会话较<br>长的情况下可以考虑采取这种方式</p>
<p><strong>散列：</strong>根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程 度上保证特定用户能连接到相同的服务器。如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器，可以考虑采取这种方式。</p>
<h3 id="2-5-服务注册-发现-amp-注册中心-Nacos注册中心"><a href="#2-5-服务注册-发现-amp-注册中心-Nacos注册中心" class="headerlink" title="2.5 服务注册/发现&amp;注册中心(Nacos注册中心)"></a>2.5 服务注册/发现&amp;注册中心(Nacos注册中心)</h3><p>&emsp;&emsp;A服务调用B服务，A服务不知道B服务当前在哪几台服务器上有，哪些正常的，哪些服务已经下线，解决这个问题可以引入注册中心。如果某些服务下线，我们其他人可以实时的感知到其他服务的状态，从而避免调用不可用的服务。</p>
<h3 id="2-6-配置中心-Nacos配置中心"><a href="#2-6-配置中心-Nacos配置中心" class="headerlink" title="2.6 配置中心(Nacos配置中心)"></a>2.6 配置中心(Nacos配置中心)</h3><p>每一个服务最终都有大量配置，并且每个服务都可能部署在多个服务器上，我们经常需要变更配置，我们可以让每个服务在配置中心获取自己的配置。配置中心用来集中管理微服务的配置信息</p>
<h3 id="2-7-服务熔断-amp-服务降级"><a href="#2-7-服务熔断-amp-服务降级" class="headerlink" title="2.7 服务熔断&amp;服务降级"></a>2.7 服务熔断&amp;服务降级</h3><p>在微服务架构中，微服务之间通过网络来进行通信，存在相互依赖，当其中一个服务不可用时，有可能会造成雪崩效应，要防止这种情况，必须要有容错机制来保护服务。</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">rpc</span></span><br><span class="line"><span class="comment">情景：</span></span><br><span class="line"><span class="comment">订单服务</span> --&gt; <span class="comment">商品服务</span> --&gt; <span class="comment">库存服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">库存服务出现故障导致响应慢，导致商品服务需要等待，可能等到10s后库存服</span></span><br><span class="line"><span class="comment">务才能响应。库存服务的不可用导致商品服务阻塞，商品服务等的期间，订单服</span></span><br><span class="line"><span class="comment">务也处于阻塞。一个服务不可用导致整个服务链都阻塞。如果是高并发，第一个</span></span><br><span class="line"><span class="comment">请求调用后阻塞10s得不到结果，第二个请求直接阻塞10s。更多的请求进来导致</span></span><br><span class="line"><span class="comment">请求积压，全部阻塞，最终服务器的资源耗尽。导致雪崩</span></span><br><span class="line"></span><br><span class="line"><span class="comment">1、服务熔断</span></span><br><span class="line"><span class="comment">设置服务的超时，当被调用的服务经常失败到达某个阈值，我们可以开启断路保</span></span><br><span class="line"><span class="comment">护机制，后来的请求不再去调用这个服务，本地直接返回默认的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">2、服务降级</span></span><br><span class="line"><span class="comment">在运维期间，当系统处于高峰期，系统资源紧张，我们可以让非核心业务降级</span></span><br><span class="line"><span class="comment">运行，降级：某些服务不处理，或者简单处理【抛异常，返回NULL，调用</span> </span><br><span class="line"><span class="comment">Mock数据，调用</span> <span class="comment">FallBack</span> <span class="comment">处理逻辑】</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-8-API-网关"><a href="#2-8-API-网关" class="headerlink" title="2.8 API 网关"></a>2.8 API 网关</h3><p>在微服务架构中，API Gateway 作为整体架构的重要组件，抽象服务中需要的公共功能，同时它提供了客户端负载均衡，服务自动熔断，灰度发布，统一认证，限流监控，日志统计等丰富功能，帮助我们解决很多API管理的难题</p>
]]></content>
      <categories>
        <category>谷粒商城项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h1><p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/snipaste_20211231_105008.png"></p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>&emsp;&emsp;在物理层上所传送的数据单位是⽐特。 <strong>物理层(physical layer)的作⽤是实现相邻计算机节点之间数据⽐特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong>。 使其上⾯的数据链路层不必考虑⽹络的具体传输介质是什么。“透明传送⽐特流”表示经实际电路传送后的⽐特流没有发⽣变化，对传送的 ⽐特流来说，这个电路好像是看不⻅的。物理层主要任务是确定传输媒体接口有关的一些特性。  </p>
<hr>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p><strong>数据链路层的研究思想</strong>：</p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/snipaste_20211231_110150.png"></p>
<p>链路：网络中两个节点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤、和微波。分为有线链路、无线链路。</p>
<p>数据链路：网络中两个节点之间的<strong>逻辑通道</strong>，把实现控制数据<strong>传输协议</strong>的硬件和软件加到链路上就构成了数据链路。</p>
<p>帧：链路层的协议数据单元，封装网络层数据报。</p>
<p><strong>数据链路层功能：</strong></p>
<p>&emsp;&emsp;数据链路层在物理层提供服务的基础之上向网络层提供服务，其最基本的任务是将源自网络层的来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p>
<p>&emsp;&emsp;在两个相邻节点之间传送数据时，数据链路层将⽹络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每⼀帧包括数据和必要的控制信 息（如同步信息，地址信息，差错控制等）</p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8A%9F%E8%83%BD.png" alt="数据链路层功能"></p>
<p><strong>组帧方法：</strong>字符计数法、字符填充法、零比特填充法（5 “1” 1 “0”）、违规编码法（曼彻斯特编码中用“高-高”、“低-低”来定界帧的起始和终止）。</p>
<p><strong>差错控制：</strong></p>
<ul>
<li>检错编码：包括奇偶校验码和循环冗余码CRC</li>
<li>纠错编码：海明码</li>
</ul>
<p><strong>流量控制</strong></p>
<ul>
<li>停止等待协议</li>
<li>选择重传协议（SR）</li>
<li>后退N帧协议（GBN）</li>
</ul>
<hr>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><strong>&emsp;&emsp;在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8A%9F%E8%83%BD.png" alt="网络层功能"></p>
<p>&emsp;&emsp;互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p>
<hr>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p><strong>&emsp;&emsp;运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>复用</strong>：应用层所有的应用进程都可以通过传输层再传输到网络层。</p>
<p><strong>分用</strong>：传输层从网络层收到数据后交付指明的应用进程。</p>
<p><strong>运输层主要使用以下两种协议:</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。(可靠,面向连接,时延大,适用于大文件。)</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8A%9F%E8%83%BD.png" alt="传输层功能"></p>
<h3 id="TCP-UDP-协议"><a href="#TCP-UDP-协议" class="headerlink" title="TCP, UDP 协议"></a>TCP, UDP 协议</h3><p>区别：</p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="TCP与UDP的区别"></p>
<p><strong>UDP协议：</strong></p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%8D%8F%E8%AE%AE.png" alt="UDP协议"></p>
<p><strong>TCP协议：</strong></p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE.png" alt="TCP协议"></p>
<p><strong>TCP连接管理：</strong></p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.png" alt="TCP连接管理"></p>
<h3 id="TCP的连接建立（三次握手）"><a href="#TCP的连接建立（三次握手）" class="headerlink" title="TCP的连接建立（三次握手）"></a>TCP的连接建立（三次握手）</h3><p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p>&emsp;&emsp;SYN洪泛攻击：这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP  SYN，SYN是TCP三次握手的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样会更加浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。（解决方法：SYN cookies）</p>
<p><strong>为什么要三次握手？</strong></p>
<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p><strong>第 2 次握手传回了 ACK，为什么还要传回 SYN？</strong></p>
<p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="TCP的连接释放（四次挥手）"><a href="#TCP的连接释放（四次挥手）" class="headerlink" title="TCP的连接释放（四次挥手）"></a>TCP的连接释放（四次挥手）</h3><p>参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的资源将被释放。</p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE%EF%BC%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89.png" alt="TCP连接释放（四次挥手）"></p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>关于tcp连接三次握手四次挥手可参考：<a href="https://blog.csdn.net/qq_38950316/article/details/81087809?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&utm_relevant_index=1">TCP的三次握手与四次挥手理解</a></p>
<p><strong>TCP协议如何保证可靠传输</strong>：</p>
<ol>
<li>应⽤数据被分割成 TCP 认为最适合发送的数据块。 </li>
<li>TCP 给发送的每⼀个包进⾏编号，接收⽅对数据包进⾏排序，把有序数据传送给应⽤层。</li>
<li> 校验和： TCP 将保持它首部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂段。 </li>
<li> TCP 的接收端会丢弃重复的数据。 </li>
<li>流量控制： TCP 连接的每⼀⽅都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端 缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，防止 包丢失。TCP 使⽤的流量控制协议是可变大小的滑动窗⼝协议。 （TCP 利⽤滑动窗⼝实现流量 控制） </li>
<li>拥塞控制： 当⽹络拥塞时，减少数据的发送。 </li>
<li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对⽅ 确认。在收到确认后再发下⼀个分组。</li>
<li> 超时重传： 当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果 不能及时收到⼀个确认，将重发这个报⽂段</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>**&emsp;&emsp;应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如**域名系统 DNS**，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="应用层"></p>
<hr>
<h1 id="TCP协议可靠传输"><a href="#TCP协议可靠传输" class="headerlink" title="TCP协议可靠传输"></a>TCP协议可靠传输</h1><h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p>&emsp;&emsp;自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中<strong>数据链路层</strong>和<strong>传输层</strong>的错误纠正协议之 ⼀。它通过使⽤<strong>确认</strong>和<strong>超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。ARQ包括<strong>停⽌等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p>
<h3 id="停止等待ARQ协议-："><a href="#停止等待ARQ协议-：" class="headerlink" title="停止等待ARQ协议 ："></a><strong>停止等待ARQ协议</strong> ：</h3><p>&emsp;&emsp;停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对方确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送 成功，需要重新发送，直到收到确认后再发下⼀个分组； 在停⽌等待协议中，若接收⽅收到重复分组，就丢弃该分组，但同时还要发送确认； 优点： 简单 ；缺点： 信道利⽤率低，等待时间⻓</p>
<p><strong>1) 无差错情况:</strong></p>
<p>&emsp;&emsp;发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>&emsp;&emsp;停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>&emsp;&emsp;连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h2 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h2><p><strong>&emsp;&emsp;TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>&emsp;&emsp;在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h1 id="在浏览器中输入url地址到显示主页的过程"><a href="#在浏览器中输入url地址到显示主页的过程" class="headerlink" title="在浏览器中输入url地址到显示主页的过程"></a>在浏览器中输入url地址到显示主页的过程</h1><p>图解（图片来源：《图解 HTTP》）：</p>
<p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="打开一个网页的过程"></p>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<hr>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p><img src="/2021/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p>
<hr>
<h1 id="各种协议与-HTTP-协议之间的关系"><a href="#各种协议与-HTTP-协议之间的关系" class="headerlink" title="各种协议与 HTTP 协议之间的关系"></a>各种协议与 HTTP 协议之间的关系</h1><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与http协议之间的关系"></p>
<h1 id="HTTP-长连接-短连接"><a href="#HTTP-长连接-短连接" class="headerlink" title="HTTP 长连接, 短连接"></a>HTTP 长连接, 短连接</h1><p>&emsp;&emsp;&emsp;在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p>
<p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection:</span><span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>
<p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP 长连接、短连接究竟是什么？》</a></p>
<h1 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h1><p>&emsp;&emsp;HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<hr>
<h1 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h1><p>&emsp;&emsp;Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>&emsp;&emsp;<strong>Cookie 一般用来保存用户信息</strong> 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。</p>
<p>&emsp;&emsp;<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<hr>
<h1 id="HTTP-1-0-和-HTTP-1-1-的主要区别"><a href="#HTTP-1-0-和-HTTP-1-1-的主要区别" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 的主要区别"></a>HTTP 1.0 和 HTTP 1.1 的主要区别</h1><blockquote>
<p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A</a>? 的一些内容。</p>
</blockquote>
<p>HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：</p>
<ol>
<li><strong>长连接</strong> : <strong>在 HTTP/1.0 中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1 起，默认使用长连接</strong> ,默认开启 Connection： keep-alive。 <strong>HTTP/1.1 的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则<strong>引入了更多的缓存控制策略</strong>例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等<strong>更多可供选择的缓存头来控制缓存策略。</strong></li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持<strong>断点续传</strong>功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<hr>
<h1 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h1><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h1 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h1><ol>
<li><p><strong>端口</strong> ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
</li>
<li><p><strong>安全性和资源消耗</strong>：</p>
<p>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</li>
<li></li>
</ul>
</li>
</ol>
<p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md#42-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">javaguide/计算机网络</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="人工智能、模式识别、机器学习、深度学习？"><a href="#人工智能、模式识别、机器学习、深度学习？" class="headerlink" title="人工智能、模式识别、机器学习、深度学习？"></a><strong>人工智能、模式识别、机器学习、深度学习？</strong></h1><p>​        后三者都是实现人工智能的途径，其中我们需要把深度学习与模式识别、机器学习这两个领域区分开来。</p>
<h2 id="1-模式识别："><a href="#1-模式识别：" class="headerlink" title="1. 模式识别："></a>1. 模式识别：</h2><p>​        模式识别是指对表征事物或现象的各种形式的(数值的、文字的和逻辑关系的)信息进行处理和分析，以对事物或现象进行<strong>描述、辨认、分类和解释</strong>的过程，是信息科学和人工智能的重要组成部分。我们把环境与客体统称为“模式”。随着计算机技术的发展，人类会研究复杂的信息处理过程，一个重要形式是生命体对环境及客体的识别。以光学字符识别之“汉字识别”为例：首先将汉字图像进行处理，抽取主要表达特征并将特征与汉字的代码存在计算机中。就像老师教我们“这个字叫什么、如何写”记在大脑中。这一过程叫做“训练”。识别过程就是将输入的汉字图像经处理后与计算机中的所有字进行比较，找出最相近的字就是识别结果，这一过程叫做“匹配”。</p>
<h2 id="2-机器学习："><a href="#2-机器学习：" class="headerlink" title="2. 机器学习："></a>2. 机器学习：</h2><p>​        计算机程序可以在给定某种类别的任务 T 和性能度量 P 下学习经验 E ，如果其在任务 T 中的性能恰好可以用 P 度量，则随着经验 E 而提高。机器从已知的经验数据（样本）中，通过某种特定的方法（算法），自己去寻找提炼（训练/学习）出一些规律（模型）；提炼出的规律就可以用来判断一些未知的事情（预测）。</p>
<p>​        机器学习(Machine Learning，ML)是人工智能的子领域，也是人工智能的核心。它囊括了几乎所有对世界影响最大的方法(包括深度学习)。机器学习理论主要是设计和分析一些让计算机可以自动学习的算法。</p>
<p>​        举个例子，假设要构建一个识别猫的程序。传统上如果我们想让计算机进行识别，需要输入一串指令，例如猫长着毛茸茸的毛、顶着一对三角形的的耳朵等，然后计算机根据这些指令执行下去。但是如果我们对程序展示一只老虎的照片，程序应该如何反应呢？更何况通过传统方式要制定全部所需的规则，而且在此过程中必然会涉及到一些困难的概念，比如对毛茸茸的定义。因此，更好的方式是让机器自学。</p>
<p>​        我们可以为计算机提供大量的猫的照片，系统将以自己特有的方式查看这些照片。随着实验的反复进行，系统会不断学习更新，最终能够准确地判断出哪些是猫，哪些不是猫。</p>
<p>模式识别与机器学习的区别是：前者喂给机器的是各种<strong>特征描述</strong>，从而让机器对未知的事物进行判断；后者喂给机器的是某一事物的<strong>海量样本</strong>，让机器通过样本来自己发现特征，最后去判断某些未知的事物。</p>
<h2 id="3-深度学习"><a href="#3-深度学习" class="headerlink" title="3. 深度学习"></a>3. 深度学习</h2><p>&emsp;&emsp;深度学习是一种特殊的机器学习。深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。 深度学习是一个复杂的机器学习算法，在语音和图像识别方面取得的效果，远远超过先前相关技术。<br>&emsp;&emsp;深度学习的灵感来源于人类大脑的工作方式，是利用深度神经网络来解决特征表达的一种学习过程。深度神经网络本身并非是一个全新的概念，可理解为包含多个隐含层的神经网络结构。为了提高深层神经网络的训练效果，人们对神经元的连接方法以及激活函数等方面做出了调整。其目的在于建立、模拟人脑进行分析学习的神经网络，模仿人脑的机制来解释数据，如文本、图像、声音。</p>
<h3 id="机器学习与深度学习的比较"><a href="#机器学习与深度学习的比较" class="headerlink" title="机器学习与深度学习的比较"></a><strong>机器学习与深度学习的比较</strong></h3><p><strong>1、应用场景</strong></p>
<p>​        机器学习在指纹识别、特征物体检测等领域的应用基本达到了商业化的要求。深度学习主要应用于文字识别、人脸技术、语义分析、智能监控等领域。目前在智能硬件、教育、医疗等行业也在快速布局。</p>
<p><strong>2、所需数据量</strong></p>
<p>​        机器学习能够适应各种数据量，特别是数据量较小的场景。如果数据量迅速增加，那么深度学习的效果将更加突出，这是因为深度学习算法需要大量数据才能完美理解。</p>
<p><strong>3、执行时间</strong></p>
<p>​        执行时间是指训练算法所需要的时间量。一般来说，深度学习算法需要大量时间进行训练。这是因为该算法包含有很多参数，因此训练它们需要比平时更长的时间。相对而言，机器学习算法的执行时间更少。</p>
<p><strong>4、解决问题的方法</strong></p>
<p>​        机器学习算法遵循标准程序以解决问题。它将问题拆分成数个部分，对其进行分别解决，而后再将结果结合起来以获得所需的答案。深度学习则以集中方式解决问题，而不必进行问题拆分。</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180830211736920.png" alt="三者关系图"></p>
<p>​        深度学习的优点在于学习能力强、覆盖范围广、数据驱动，其缺点在于计算量大、硬件需求高、模型设计复杂。这是事实，但是作为安全研究人员，我们更需要关注的不是怎么搭房子（怎么设计深度学习系统），而是怎么拆房子（如何对其进行攻击）以及如果搭更坚固的房子（如何进行针对性防御）。</p>
<p>​        这里非常关键的一点，就是模型的可解释性问题：深度学习存在所谓的黑箱问题，由此带来了不可解释性，而这一点如果不能解决（事实上目前为止还没有很好解决）将会导致在深度学习在对安全性很敏感的领域中应用的受限。比如将其应用在医疗领域时，深度学习系统根据医学影像判断病人为癌症，但是不能解释为什么给出这个判断，而人类医学专家认为不是癌症，那么这时存在两种情况，一种是深度学习系统错了；第二种则是专家错了，可是由于系统无法给出解释，所以专家未必采纳系统意见，则造成病人的损失。无论是哪种情况，都可以看到不解决深度学习的可解释性问题，其未来的应用发展是一定会受到限制的。</p>
<h2 id="深度学习典型模型"><a href="#深度学习典型模型" class="headerlink" title="深度学习典型模型"></a>深度学习典型模型</h2><p>典型的深度学习模型有卷积神经网络( convolutional neural network)、DBN和堆栈自编码网络(stacked auto-encoder network)模型等，</p>
<h3 id="卷积神经网络模型"><a href="#卷积神经网络模型" class="headerlink" title="卷积神经网络模型"></a>卷积神经网络模型</h3><p>​        在无监督预训练出现之前，训练深度神经网络通常非常困难，而其中一个特例是卷积神经网络。卷积神经网络受视觉系统的结构启发而产生。第一个卷积神经网络计算模型是在Fukushima(D的神经认知机中提出的，基于神经元之间的局部连接和分层组织图像转换，将有相同参数的神经元应用于前一层神经网络的不同位置，得到一种平移不变神经网络结构形式。后来，Le Cun等人在该思想的基础上，用误差梯度设计并训练卷积神经网络，在一些模式识别任务上得到优越的性能。至今，基于卷积神经网络的模式识别系统是最好的实现系统之一，尤其在手写体字符识别任务上表现出非凡的性能。</p>
<h3 id="深度信任网络模型"><a href="#深度信任网络模型" class="headerlink" title="深度信任网络模型"></a>深度信任网络模型</h3><p>​        DBN可以解释为贝叶斯概率生成模型，由多层随机隐变量组成，上面的两层具有无向对称连接，下面的层得到来自上一层的自顶向下的有向连接，最底层单元的状态为可见输入数据向量。DBN由若2F结构单元堆栈组成，结构单元通常为RBM（RestIlcted Boltzmann Machine，受限玻尔兹曼机）。堆栈中每个RBM单元的可视层神经元数量等于前一RBM单元的隐层神经元数量。根据深度学习机制，采用输入样例训练第一层RBM单元，并利用其输出训练第二层RBM模型，将RBM模型进行堆栈通过增加层来改善模型性能。在无监督预训练过程中，DBN编码输入到顶层RBM后，解码顶层的状态到最底层的单元，实现输入的重构。RBM作为DBN的结构单元，与每一层DBN共享参数。</p>
<h3 id="堆栈自编码网络模型"><a href="#堆栈自编码网络模型" class="headerlink" title="堆栈自编码网络模型"></a>堆栈自编码网络模型</h3><p>​        堆栈自编码网络的结构与DBN类似，由若干结构单元堆栈组成，不同之处在于其结构单元为自编码模型( auto-en-coder)而不是RBM。自编码模型是一个两层的神经网络，第一层称为编码层，第二层称为解码层。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>​        香港中文大学的多媒体实验室是最早应用深度学习进行计算机视觉研究的华人团队。在世界级人工智能竞赛LFW（大规模人脸识别竞赛）上，该实验室曾力压FaceBook夺得冠军，使得人工智能在该领域的识别能力首次超越真人。 </p>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>​        微软研究人员通过与hinton合作，首先将RBM和DBN引入到语音识别声学模型训练中，并且在大词汇量语音识别系统中获得巨大成功，使得语音识别的错误率相对减低30%。但是，DNN还没有有效的并行快速算法，很多研究机构都是在利用大规模数据语料通过GPU平台提高DNN声学模型的训练效率。 在国际上，IBM、google等公司都快速进行了DNN语音识别的研究，并且速度飞快。国内方面，阿里巴巴、科大讯飞、百度、中科院自动化所等公司或研究单位，也在进行深度学习在语音识别上的研究。</p>
<h3 id="自然语言处理等其他领域"><a href="#自然语言处理等其他领域" class="headerlink" title="自然语言处理等其他领域"></a>自然语言处理等其他领域</h3><p>​        很多机构在开展研究，2013年，Tomas Mikolov，Kai Chen，Greg Corrado，Jeffrey Dean发表论文Efficient Estimation of Word Representations in Vector Space建立word2vector模型，与传统的词袋模型（bag of words）相比，word2vector能够更好地表达语法信息。深度学习在自然语言处理等领域主要应用于机器翻译以及语义挖掘等方面。</p>
<p>参考链接: <a href="https://blog.csdn.net/yalecaltech/article/details/117249408">如何攻击深度学习系统？–可解释性及鲁棒性研究</a></p>
<p>​                <a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/3729729?fr=aladdin">深度学习（人工神经网络的研究的概念）_百度百科 (baidu.com)</a></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客</title>
    <url>/2021/12/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div><div class="fold_hider"><div class="close hider_title">显/隐</div></div><div class="fold">
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">something</span> you want to fold, <span class="meta">include</span> <span class="meta">code</span> block.</span><br></pre></td></tr></table></figure>

</div></div>

<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span>something you want <span class="keyword">to</span> fold, include code block.</span><br></pre></td></tr></table></figure>

</div></div>

<p>hello</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
