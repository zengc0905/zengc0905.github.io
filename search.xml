<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetCode刷题笔记</title>
    <url>/2021/12/30/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="leetcode-top100"><a href="#leetcode-top100" class="headerlink" title="leetcode top100"></a>leetcode top100</h1><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="#437 路径总和 III"></a>#437 路径总和 III</h2><p>&emsp;&emsp;给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<span id="more"></span>

<p><strong>方法一：深度优先搜索</strong></p>
<ul>
<li>时间复杂度：O(N^2^)，其中 NN为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(N)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 O(N^2^)。</li>
<li>空间复杂度：O(N)，递归需要消耗栈空间</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = pathNum(root,targetSum);</span><br><span class="line">        res += pathSum(root.left,targetSum);</span><br><span class="line">        res += pathSum(root.right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须以node节点开始，路径和为targetSum的路径的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathNum</span><span class="params">(TreeNode node,<span class="keyword">int</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val == targetSum)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        count += pathNum(node.left, targetSum - node.val);</span><br><span class="line">        count += pathNum(node.right, targetSum - node.val);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<p><strong>方法二：前缀和（进阶），利用HashMap记录每个节点到根节点的路径和</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N为二叉树中节点的个数。利用前缀和只需遍历一次二叉树即可</li>
<li>空间复杂度：O(N)</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum1</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//prifexMap中记录每个节点到根节点的路径和，key为路径和,value为某个节点到根节点路径和为key的节点个数</span></span><br><span class="line">        HashMap&lt;Long, Integer&gt; prifexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        prifexMap.put(<span class="number">0L</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(root,targetSum,prifexMap,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//curprifex为当前节点node（不办含node）到根节点的路径和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> targetSum, HashMap&lt;Long, Integer&gt; prifexMap, <span class="keyword">long</span> curPrifex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        curPrifex += node.val;</span><br><span class="line">        res += prifexMap.getOrDefault(curPrifex - targetSum,<span class="number">0</span>);</span><br><span class="line">        prifexMap.put(curPrifex,prifexMap.getOrDefault(curPrifex,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        res += dfs(node.left,targetSum,prifexMap,curPrifex);</span><br><span class="line">        res += dfs(node.right,targetSum,prifexMap,curPrifex);</span><br><span class="line">        <span class="comment">//回溯，恢复prifexMap</span></span><br><span class="line">        prifexMap.put(curPrifex,prifexMap.get(curPrifex) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="#438 找到字符串中所有字母异位词"></a>#438 找到字符串中所有字母异位词</h2><blockquote>
<p>&emsp;&emsp;给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
</blockquote>
<p>解题思路：滑动窗口+数组</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">     <span class="comment">//滑动窗口 + 数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams1</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = p.length();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len1 &lt; len2) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span>[] sCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len2; i &lt; len1; i++) &#123;</span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            sCount[s.charAt(i - len2) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">                list.add(i - len2 + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<hr>
<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="#448 找到所有数组中消失的数字"></a>#448 找到所有数组中消失的数字</h2><blockquote>
<p>&emsp;&emsp;给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
</ul>
</blockquote>
<p>解题思路：用一个哈希表记录数组nums 中的数字，由于数字范围均在1-n中，记录数字后我们再利用哈希表检查 1-n 中的每一个数是否出现，从而找到缺失的数字。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Set&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            hashSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashSet.contains(i))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div> <br>

<p>上述方法空间复杂度为O(N)，可利用原数组nums优化空间复杂度为O(1)。遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 1~n中，增加以后，这些数必然大于 n。最后遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数i+1。这样就找到了缺失的数字。<br>&emsp;&emsp;另外需要注意的是，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模来还原出它本来的值。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (nums[i] - <span class="number">1</span>) % n;</span><br><span class="line">            nums[temp] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n)&#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div> <br>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2021/12/29/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-java概述"><a href="#1-java概述" class="headerlink" title="1.java概述"></a>1.java概述</h1><h2 id="1-1-面向对象和面向过程的区别"><a href="#1-1-面向对象和面向过程的区别" class="headerlink" title="1.1 面向对象和面向过程的区别"></a>1.1 面向对象和面向过程的区别</h2><ul>
<li>面向过程：⾯向过程性能⽐⾯向对象⾼。 因为类调⽤时需要实例化，开销⽐᫾⼤，⽐᫾消耗资 源，所以当性能是最重要的考量因素的时候，⽐如单⽚机、嵌⼊式开发、Linux/Unix 等⼀般采 ⽤⾯向过程开发。但是，⾯向过程没有⾯向对象易维护、易复⽤、易扩展。</li>
<li>⾯向对象 ：⾯向对象易维护、易复⽤、易扩展。 因为⾯向对象有封装、继承、多态性的特性， 所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，⾯向对象性能⽐⾯向过 程低。</li>
</ul>
<p>⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏，⽽ Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的 ⼆进制机器码。</p>
<h2 id="1-2-Java语言编译与解释共存"><a href="#1-2-Java语言编译与解释共存" class="headerlink" title="1.2 Java语言编译与解释共存"></a>1.2 Java语言编译与解释共存</h2><p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><strong>编译型</strong> ：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型</strong> ：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h2 id="1-3-什么是字节码"><a href="#1-3-什么是字节码" class="headerlink" title="1.3 什么是字节码"></a>1.3 什么是字节码</h2><p>​        在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何 特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统编译型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时⽐较⾼效，⽽ 且，由于字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统 的计算机上运⾏。</p>
<p>java程序的运行步骤：</p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_095023.png"></p>
<p>在class到机器码这一步，JVM 类加载器⾸先加载字节码⽂件，然后 通过解释器逐⾏解释执⾏，这种⽅式的执⾏速度会相对⽐较慢。⽽且，有些⽅法和代码块是经常需要被 调⽤的(也就是所谓的热点代码)，所以后⾯引进了 JIT 编译器，⽽ JIT 属于运⾏时编译。当 JIT 编 译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。⽽我们知道，机器 码的运⾏效率肯定是⾼于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的 语⾔</p>
<h2 id="1-4-JVM-JDK-JRE的区别与联系"><a href="#1-4-JVM-JDK-JRE的区别与联系" class="headerlink" title="1.4 JVM,JDK,JRE的区别与联系"></a>1.4 JVM,JDK,JRE的区别与联系</h2><ul>
<li>java虚拟机（JVM）Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows， Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。（一次编译，到处运行）</li>
<li>JDK 是 Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器 （javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</li>
<li>JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机 （JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</li>
</ul>
<h2 id="1-4-java和c-的区别"><a href="#1-4-java和c-的区别" class="headerlink" title="1.4 java和c++的区别"></a>1.4 java和c++的区别</h2><ul>
<li>都是⾯向对象的语⾔，都⽀持封装、继承和多态</li>
<li> Java 不提供指针来直接访问内存，程序内存更加安全 </li>
<li>Java 的类是单继承的，C++ ⽀持多重继承，虽然 Java 的类不可以多继承，但是接⼝可以多继承。 </li>
<li>Java 有⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</li>
</ul>
<h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h1><h2 id="2-1-java-基本数据类型与相应的包装类"><a href="#2-1-java-基本数据类型与相应的包装类" class="headerlink" title="2.1 java 基本数据类型与相应的包装类"></a>2.1 java 基本数据类型与相应的包装类</h2><p>Java 中有 8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code></li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">位数</th>
<th align="center">字节</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int</code></td>
<td align="center">32</td>
<td align="center">4</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>short</code></td>
<td align="center">16</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center">64</td>
<td align="center">8</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center"><code>byte</code></td>
<td align="center">8</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">16</td>
<td align="center">2</td>
<td align="center">‘u0000’</td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center">32</td>
<td align="center">4</td>
<td align="center">0f</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">64</td>
<td align="center">8</td>
<td align="center">0d</td>
</tr>
<tr>
<td align="center"><code>boolean</code></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</p>
<p>java编程思想第四版：2.2.2节</p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_100713.png"></p>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure>

<p>输出false。</p>
<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而<code>Integer i1 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<p><em><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</em></p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_111337.png"></p>
<p><strong>自动装箱与拆箱：</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>上面这两行代码对应的字节码为：</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java<span class="regexp">/lang/I</span>nteger.valueOf (I)Ljava<span class="regexp">/lang/I</span>nteger;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava<span class="regexp">/lang/I</span>nteger;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava<span class="regexp">/lang/I</span>nteger;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java<span class="regexp">/lang/I</span>nteger.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> <span class="keyword">RETURN</span></span><br></pre></td></tr></table></figure>



</div></div>

<p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h2 id="2-2-java-重载和重写的区别"><a href="#2-2-java-重载和重写的区别" class="headerlink" title="2.2 java 重载和重写的区别"></a>2.2 java 重载和重写的区别</h2><ul>
<li>重载就是同样的⼀个⽅法能够根据输⼊数据的不同，做出不同的处理 。发⽣在同⼀个类中，⽅法名必须相同，参数类型不同、个数不同、顺序不同，⽅法返回值和访问修饰符可以不同。</li>
<li>重写就是当⼦类继承⾃⽗类的相同⽅法，输⼊数据⼀样，但要做出有别于⽗类的响应时，你就要覆盖⽗类⽅法。<strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892</a> ）：<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
</li>
</ul>
<p>综上：重载就是同⼀个类中多个同名⽅法根据不同的传参来执⾏不同的逻辑处理；重写发⽣在运⾏期，是⼦类对⽗类的允许访问的⽅法的实现过程进⾏重新编写。</p>
<h2 id="2-3-静态方法为何不能调用非静态成员"><a href="#2-3-静态方法为何不能调用非静态成员" class="headerlink" title="2.3 静态方法为何不能调用非静态成员"></a>2.3 静态方法为何不能调用非静态成员</h2><ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h2 id="2-4-泛型"><a href="#2-4-泛型" class="headerlink" title="2.4 泛型"></a>2.4 泛型</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<strong>泛型的本质是<u>参数化类型</u>，也就是说所操作的数据类型被指定为一个参数。</strong></p>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<p>泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</p>
<p>常用的通配符：<strong>T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h2 id="2-5-，equals-，hashCode"><a href="#2-5-，equals-，hashCode" class="headerlink" title="2.5 ==，equals() ，hashCode()"></a>2.5 ==，equals() ，hashCode()</h2><p>== 和 equals() 的区别:</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<p><strong>hashCode():</strong></p>
<p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<p>为什么重写 equals() 时必须重写 hashCode() 方法？</p>
<ul>
<li>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</li>
</ul>
<h2 id="2-6-java面向对象"><a href="#2-6-java面向对象" class="headerlink" title="2.6 java面向对象"></a>2.6 java面向对象</h2><h3 id="2-6-1-成员变量与局部变量的区别"><a href="#2-6-1-成员变量与局部变量的区别" class="headerlink" title="2.6.1 成员变量与局部变量的区别"></a>2.6.1 成员变量与局部变量的区别</h3><ol>
<li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而<strong>局部变量不能被访问控制修饰符及 <code>static</code> 所修饰</strong>；但是，<strong>成员变量和局部变量都能被 <code>final</code> 所修饰</strong>。</li>
<li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h3 id="2-6-2-构造方法"><a href="#2-6-2-构造方法" class="headerlink" title="2.6.2 构造方法"></a>2.6.2 构造方法</h3><p>构造方法主要作用是完成对类对象的初始化工作。</p>
<p>特点：</p>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="2-6-3-面向对象的三大特征"><a href="#2-6-3-面向对象的三大特征" class="headerlink" title="2.6.3 面向对象的三大特征"></a>2.6.3 面向对象的三大特征</h3><p><strong>封装</strong></p>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。，</p>
<p><strong>继承</strong></p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>多态</strong></p>
<p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p>多态的特点:</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
<li>父类方法加上static, private，final等关键字无法被重写</li>
</ul>
<h2 id="2-7-String-，StringBuffer，StringBuilder"><a href="#2-7-String-，StringBuffer，StringBuilder" class="headerlink" title="2.7 String ，StringBuffer，StringBuilder"></a>2.7 String ，StringBuffer，StringBuilder</h2><h3 id="string："><a href="#string：" class="headerlink" title="string："></a>string：</h3><p><strong>不可变性：</strong></p>
<p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="StringBuilder与StringBuffer："><a href="#StringBuilder与StringBuffer：" class="headerlink" title="StringBuilder与StringBuffer："></a><strong>StringBuilder<code>与</code>StringBuffer：</strong></h3><p>都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p><strong>线程安全性</strong>:</p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code>与<code>StringBuild </code>每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>单线程情况下：<code>StringBUild</code>性能最优</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h2 id="2-8-Object类常见方法总结"><a href="#2-8-Object类常见方法总结" class="headerlink" title="2.8 Object类常见方法总结"></a>2.8 Object类常见方法总结</h2><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

</div></div>

<h2 id="2-9-深拷贝和浅拷贝及引用拷贝"><a href="#2-9-深拷贝和浅拷贝及引用拷贝" class="headerlink" title="2.9 深拷贝和浅拷贝及引用拷贝"></a>2.9 深拷贝和浅拷贝及引用拷贝</h2><ul>
<li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
</li>
<li><p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</li>
</ul>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>​        浅拷贝的示例代码如下，这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>
<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>测试 ：</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="keyword">new</span> Address(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>测试 ：</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="keyword">new</span> Address(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line">Person person1Copy = person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure>

</div></div>

<p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>
<p><strong>通过对象序列化实现深拷贝</strong></p>
<p>将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。</p>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p>二者的引用是同一个对象，并没有创建出一个新的对象</p>
<p>因为是同一个对象的引用，所以两者改一个，另一个对象的值也随之改变</p>
<h2 id="2-11-反射"><a href="#2-11-反射" class="headerlink" title="2.11 反射"></a>2.11 反射</h2><h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3><p>​        JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>​        要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_202647.png" alt="从jvm层面理解反射"></p>
<p>参考链接：<a href="https://blog.csdn.net/sinat_38259539/article/details/71799078?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">Java基础之—反射（非常重要）</a></p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>​        像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p>
<p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<div><div class="fold_hider"><div class="close hider_title">点击展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="2-12-异常"><a href="#2-12-异常" class="headerlink" title="2.12 异常"></a>2.12 异常</h2><h3 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h3><p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_204101.png"></p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_204202.png"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="受检查异常"><a href="#受检查异常" class="headerlink" title="受检查异常"></a>受检查异常</h3><p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<h3 id="不受检查异常"><a href="#不受检查异常" class="headerlink" title="不受检查异常"></a><strong>不受检查异常</strong></h3><p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul>
<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h3 id="使用-try-with-resources-来代替try-catch-finally"><a href="#使用-try-with-resources-来代替try-catch-finally" class="headerlink" title="使用 try-with-resources 来代替try-catch-finally"></a>使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3><ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/关闭</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">             BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</div></div>



<h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h3><p>方法 1：通过 <code>Scanner</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="built_in">new</span> Scanner(<span class="keyword">System</span>.<span class="keyword">in</span>);</span><br><span class="line">String s  = <span class="keyword">input</span>.nextLine();</span><br><span class="line"><span class="keyword">input</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 <code>BufferedReader</code></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(System.<span class="keyword">in</span>));</span><br><span class="line"><span class="keyword">String</span> s = input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_210112.png" alt="按操作方式分类结构图"></p>
<p><img src="/2021/12/29/java%E5%9F%BA%E7%A1%80/snipaste_20211229_210138.png" alt="按操作对象分类结构图"></p>
<h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<p>参考：<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.md#java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%8E%E4%B9%88%E5%8A%9E">JavaGuide/java基础知识总结.md at main · Snailclimb/JavaGuide (github.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s快速入门</title>
    <url>/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1、K8s快速入门"><a href="#1、K8s快速入门" class="headerlink" title="1、K8s快速入门"></a>1、K8s快速入门</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>kubernetes简称k8s。是用于自动部署，扩展和管理容器化应用程序的开源系统。</p>
<p>中文官网：<a href="https://kubernetes.io/Zh/">https://kubernetes.io/Zh/</a><br>中文社区：<a href="https://www.kubernetes.org.cn/">https://www.kubernetes.org.cn/</a><br>官方文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a><br>社区文档：<a href="https://docs.kubernetes.org.cn/">https://docs.kubernetes.org.cn/</a></p>
<p>部署方式的进化：</p>
<p> <img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/container_evolution.svg" alt="部署演进"> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503105948619.png" alt="image-20200503105948619"></p>
<p>![image-20200503110101659](G:/java_work/谷粒商城/Guli Mall/文档/开发阶段文档md/images/image-20200503110101659.png)</p>
<h3 id="2）架构"><a href="#2）架构" class="headerlink" title="2）架构"></a>2）架构</h3><h4 id="（1）整体主从方式"><a href="#（1）整体主从方式" class="headerlink" title="（1）整体主从方式"></a>（1）整体主从方式</h4><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110244940.png" alt="image-20200503110244940"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110350256.png" alt="image-20200503110350256"></p>
<h4 id="（2）master节点架构"><a href="#（2）master节点架构" class="headerlink" title="（2）master节点架构"></a>（2）master节点架构</h4><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%5Cimage-20200503110458806.png" alt="image-20200503110458806"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110631219.png" alt="image-20200503110631219"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110732773.png" alt="image-20200503110732773"></p>
<h4 id="（3）Node节点架构"><a href="#（3）Node节点架构" class="headerlink" title="（3）Node节点架构"></a>（3）Node节点架构</h4><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503110804361.png" alt="image-20200503110804361"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503111032457.png" alt="image-20200503111032457"></p>
<h3 id="3）概念"><a href="#3）概念" class="headerlink" title="3）概念"></a>3）概念</h3><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112551188.png" alt="image-20200503112551188"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112627449.png" alt="image-20200503112627449"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112723747.png" alt="image-20200503112723747"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503112810938.png" alt="image-20200503112810938"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503113055314.png" alt="image-20200503113055314"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503113619233.png" alt="image-20200503113619233"></p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503113701902.png" alt="image-20200503113701902"></p>
<h3 id="4）快速体验"><a href="#4）快速体验" class="headerlink" title="4）快速体验"></a>4）快速体验</h3><h4 id="（1）安装minikube"><a href="#（1）安装minikube" class="headerlink" title="（1）安装minikube"></a>（1）安装minikube</h4><p><a href="https://github.com/kubernetes/minikube/releases">https://github.com/kubernetes/minikube/releases</a><br>下载minikuber-windows-amd64.exe 改名为minikube.exe<br>打开virtualBox，打开cmd<br>运行<br>minikube start –vm-driver=virtualbox –registry-mirror=<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a><br>等待20分钟即可。</p>
<h4 id="（2）体验nginx部署升级"><a href="#（2）体验nginx部署升级" class="headerlink" title="（2）体验nginx部署升级"></a>（2）体验nginx部署升级</h4><ol>
<li><p>提交一个nginx deployment<br>kubectl apply -f <a href="https://k8s.io/examples/application/deployment.yaml">https://k8s.io/examples/application/deployment.yaml</a></p>
</li>
<li><p>升级 nginx deployment<br>kubectl apply -f <a href="https://k8s.io/examples/application/deployment-update.yaml">https://k8s.io/examples/application/deployment-update.yaml</a></p>
</li>
<li><p>扩容 nginx deployment</p>
</li>
</ol>
<h2 id="2、K8s集群安装"><a href="#2、K8s集群安装" class="headerlink" title="2、K8s集群安装"></a>2、K8s集群安装</h2><h3 id="1）kubeadm"><a href="#1）kubeadm" class="headerlink" title="1）kubeadm"></a>1）kubeadm</h3><p>kubeadm是官方社区推出的一个用于快速部署kuberneters集群的工具。<br>这个工具能通过两条指令完成一个kuberneters集群的部署</p>
<p>创建一个master节点</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ kuberneters <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

<p>将一个node节点加入到当前集群中</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ kubeadm join &lt;Master节点的<span class="built_in">IP</span>和端口&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2）前置要求"><a href="#2）前置要求" class="headerlink" title="2）前置要求"></a>2）前置要求</h3><p>一台或多台机器，操作系统Centos7.x-86_x64<br>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多<br>集群中所有的机器之间网络互通<br>可以访问外网，需要拉取镜像<br>禁止Swap分区</p>
<h3 id="3）部署步骤"><a href="#3）部署步骤" class="headerlink" title="3）部署步骤"></a>3）部署步骤</h3><ol>
<li>在所有的节点上安装Docker和kubeadm</li>
<li>不是Kubernetes Master</li>
<li>部署容器网络插件</li>
<li>部署Kubernetes Node，将节点加入Kubernetes集群中</li>
<li>部署DashBoard web页面，可视化查看Kubernetes资源</li>
</ol>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503144120720.png" alt="image-20200503144120720"></p>
<h3 id="4）环境准备"><a href="#4）环境准备" class="headerlink" title="4）环境准备"></a>4）环境准备</h3><h4 id="（1）准备工作"><a href="#（1）准备工作" class="headerlink" title="（1）准备工作"></a>（1）准备工作</h4><ul>
<li>我们可以使用vagrant快速创建三个虚拟机。虚拟机启动前先设置virtualbox的主机网络。现在全部统一为192.168.56.1，以后所有虚拟机都是56.x的ip地址。</li>
</ul>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503175351320.png" alt="image-20200503175351320"></p>
<ul>
<li>在全局设定中，找到一个空间比较大的磁盘用用来存放镜像。 </li>
</ul>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503180202640.png" alt="image-20200503180202640"></p>
<h4 id="（2）启动三个虚拟机"><a href="#（2）启动三个虚拟机" class="headerlink" title="（2）启动三个虚拟机"></a>（2）启动三个虚拟机</h4><ul>
<li>使用我们提供的vagrant文件，复制到非中文无空格目录下，运行vagrant up启动三个虚拟机。其实vagrant完全可以一键部署全部K8s集群<br><a href="https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster">https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster</a><br><a href="http://github.com/davidkbainbridge/k8s-playground">http://github.com/davidkbainbridge/k8s-playground</a></li>
</ul>
<p>下面是vagrantfile，使用它来创建三个虚拟机，分别为k8s-node1，k8s-node2和k8s-node3.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Vagrant.configure(&quot;2&quot;)</span> <span class="string">do</span> <span class="string">|config|</span></span><br><span class="line">   <span class="string">(1..3).each</span> <span class="string">do</span> <span class="string">|i|</span></span><br><span class="line">        <span class="string">config.vm.define</span> <span class="string">&quot;k8s-node#&#123;i&#125;&quot;</span> <span class="string">do</span> <span class="string">|node|</span></span><br><span class="line">            <span class="comment"># 设置虚拟机的Box</span></span><br><span class="line">            <span class="string">node.vm.box</span> <span class="string">=</span> <span class="string">&quot;centos/7&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置虚拟机的主机名</span></span><br><span class="line">            <span class="string">node.vm.hostname=&quot;k8s-node#&#123;i&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置虚拟机的IP</span></span><br><span class="line">            <span class="string">node.vm.network</span> <span class="string">&quot;private_network&quot;</span><span class="string">,</span> <span class="attr">ip:</span> <span class="string">&quot;192.168.56.#&#123;99+i&#125;&quot;</span><span class="string">,</span> <span class="attr">netmask:</span> <span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置主机与虚拟机的共享目录</span></span><br><span class="line">            <span class="comment"># node.vm.synced_folder &quot;~/Documents/vagrant/share&quot;, &quot;/home/vagrant/share&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># VirtaulBox相关配置</span></span><br><span class="line">            <span class="string">node.vm.provider</span> <span class="string">&quot;virtualbox&quot;</span> <span class="string">do</span> <span class="string">|v|</span></span><br><span class="line">                <span class="comment"># 设置虚拟机的名称</span></span><br><span class="line">                <span class="string">v.name</span> <span class="string">=</span> <span class="string">&quot;k8s-node#&#123;i&#125;&quot;</span></span><br><span class="line">                <span class="comment"># 设置虚拟机的内存大小</span></span><br><span class="line">                <span class="string">v.memory</span> <span class="string">=</span> <span class="number">4096</span></span><br><span class="line">                <span class="comment"># 设置虚拟机的CPU个数</span></span><br><span class="line">                <span class="string">v.cpus</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line">            <span class="string">end</span></span><br><span class="line">        <span class="string">end</span></span><br><span class="line">   <span class="string">end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li>进入到三个虚拟机，开启root的密码访问权限</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Vagrant ssh xxx进入到系统后</span><br><span class="line"></span><br><span class="line">su root 密码为vagrant</span><br><span class="line"></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">PermitRootLogin yes </span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"></span><br><span class="line">所有的虚拟机设为4核4G</span><br></pre></td></tr></table></figure>





<p>关于在”网络地址转换”的连接方式下，三个节点的eth0，IP地址相同的问题。</p>
<p><strong>问题描述：</strong>查看k8s-node1的路由表：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[root@k8s-node1 ~]</span># ip route show</span><br><span class="line">default via <span class="number">10</span>.<span class="number">0</span>.<span class="number">2</span>.<span class="number">2</span> dev eth0 proto dhcp metric <span class="number">100</span> </span><br><span class="line"><span class="number">10.0.2.0</span>/<span class="number">24</span> dev eth0 proto kernel scope link src <span class="number">10</span>.<span class="number">0</span>.<span class="number">2</span>.<span class="number">15</span> metric <span class="number">100</span> </span><br><span class="line"><span class="number">192.168.56.0</span>/<span class="number">24</span> dev eth1 proto kernel scope link src <span class="number">192</span>.<span class="number">168</span>.<span class="number">56</span>.<span class="number">100</span> metric <span class="number">101</span> </span><br><span class="line"><span class="string">[root@k8s-node1 ~</span></span><br></pre></td></tr></table></figure>

<p>能够看到路由表中记录的是，通过端口eth0进行数据包的收发。</p>
<p>分别查看k8s-node1，k8s-node2和k8s-node3的eth0所绑定的IP地址，发现它们都是相同的，全都是10.0.2.15，这些地址是供kubernetes集群通信用的，区别于eth1上的IP地址，是通远程管理使用的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# ip addr</span><br><span class="line">...</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0</span><br><span class="line">       valid_lft 84418sec preferred_lft 84418sec</span><br><span class="line">    inet6 fe80::5054:ff:fe8a:fee6/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:a3:ca:c0 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.56.100/24 brd 192.168.56.255 scope global noprefixroute eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::a00:27ff:fea3:cac0/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p><strong>原因分析：</strong>这是因为它们使用是端口转发规则，使用同一个地址，通过不同的端口来区分。但是这种端口转发规则在以后的使用中会产生很多不必要的问题，所以需要修改为NAT网络类型。</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503184536343.png" alt="image-20200503184536343"></p>
<p><strong>解决方法：</strong></p>
<ul>
<li>选择三个节点，然后执行“管理”-&gt;”全局设定”-&gt;“网络”，添加一个NAT网络。</li>
</ul>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503184919936.png"></p>
<ul>
<li>分别修改每台设备的网络类型，并刷新重新生成MAC地址。</li>
</ul>
<img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503185344246.png" style="zoom: 200%;">



<ul>
<li>再次查看三个节点的IP</li>
</ul>
<img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503190101156.png" alt="image-20200503190101156" style="zoom:50%;">





<h4 id="（3）设置Linux环境（三个节点都执行）"><a href="#（3）设置Linux环境（三个节点都执行）" class="headerlink" title="（3）设置Linux环境（三个节点都执行）"></a>（3）设置Linux环境（三个节点都执行）</h4><ul>
<li>关闭防火墙</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭Linux</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> <span class="regexp">/etc/</span>selinux/config</span><br><span class="line">setenforce <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关闭swap </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a #临时关闭</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab #永久关闭</span><br><span class="line">free -g #验证，swap必须为0</span><br></pre></td></tr></table></figure>

<ul>
<li>添加主机名与IP对应关系：</li>
</ul>
<p>查看主机名：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hostname</span></span><br></pre></td></tr></table></figure>

<p>如果主机名不正确，可以通过“hostnamectl set-hostname &lt;newhostname&gt; :指定新的hostname”命令来进行修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line">10.0.2.15 k8s-node1</span><br><span class="line">10.0.2.4 k8s-node2</span><br><span class="line">10.0.2.5 k8s-node3</span><br></pre></td></tr></table></figure>



<p>将桥接的IPV4流量传递到iptables的链：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line"></span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>应用规则：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">sysctl <span class="comment">--system</span></span><br></pre></td></tr></table></figure>





<p>疑难问题：遇见提示是只读的文件系统，运行如下命令</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mount</span> -o remount rw /</span><br></pre></td></tr></table></figure>

<ul>
<li>date 查看时间（可选）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install ntpupdate</span><br><span class="line"></span><br><span class="line">ntpupdate time.window.com #同步最新时间</span><br></pre></td></tr></table></figure>



<h3 id="5）所有节点安装docker、kubeadm、kubelet、kubectl"><a href="#5）所有节点安装docker、kubeadm、kubelet、kubectl" class="headerlink" title="5）所有节点安装docker、kubeadm、kubelet、kubectl"></a>5）所有节点安装docker、kubeadm、kubelet、kubectl</h3><p>Kubenetes默认CRI（容器运行时）为Docker，因此先安装Docker。</p>
<h4 id="（1）安装Docker"><a href="#（1）安装Docker" class="headerlink" title="（1）安装Docker"></a>（1）安装Docker</h4><p>1、卸载之前的docker</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker <span class="string">\</span></span><br><span class="line">                  docker-client <span class="string">\</span></span><br><span class="line">                  docker-client-latest <span class="string">\</span></span><br><span class="line">                  docker-common <span class="string">\</span></span><br><span class="line">                  docker-latest <span class="string">\</span></span><br><span class="line">                  docker-latest-logrotate <span class="string">\</span></span><br><span class="line">                  docker-logrotate <span class="string">\</span></span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>2、安装Docker  -CE</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line"><span class="bash">    --add-repo \</span></span><br><span class="line"><span class="bash">    https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum -y install docker-ce docker-ce-cli containerd.io</span>   </span><br></pre></td></tr></table></figure>

<p>3、配置镜像加速</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://ke9h1pt4.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>4、启动Docker &amp;&amp; 设置docker开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>



<p>基础环境准备好，可以给三个虚拟机备份一下；</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200503192940651.png" alt="image-20200503192940651"></p>
<h4 id="（2）添加阿里与Yum源"><a href="#（2）添加阿里与Yum源" class="headerlink" title="（2）添加阿里与Yum源"></a>（2）添加阿里与Yum源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>更多详情见： <a href="https://developer.aliyun.com/mirror/kubernetes">https://developer.aliyun.com/mirror/kubernetes</a> </p>
<h4 id="（3）安装kubeadm，kubelet和kubectl"><a href="#（3）安装kubeadm，kubelet和kubectl" class="headerlink" title="（3）安装kubeadm，kubelet和kubectl"></a>（3）安装kubeadm，kubelet和kubectl</h4><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">yum list<span class="string">|grep kube</span></span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-1.17.3 kubeadm-1.17.3 kubectl-1.17.3</span><br></pre></td></tr></table></figure>

<p>开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>



<p>查看kubelet的状态：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl status kubelet</span></span><br></pre></td></tr></table></figure>

<p>查看kubelet版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node2 ~]# kubelet --version</span><br><span class="line">Kubernetes v1.17.3</span><br></pre></td></tr></table></figure>



<h3 id="6）部署k8s-master"><a href="#6）部署k8s-master" class="headerlink" title="6）部署k8s-master"></a>6）部署k8s-master</h3><h4 id="（1）master节点初始化"><a href="#（1）master节点初始化" class="headerlink" title="（1）master节点初始化"></a>（1）master节点初始化</h4><p>在Master节点上，创建并执行master_images.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">images=(</span><br><span class="line">	kube-apiserver:v1.17.3</span><br><span class="line">    kube-proxy:v1.17.3</span><br><span class="line">	kube-controller-manager:v1.17.3</span><br><span class="line">	kube-scheduler:v1.17.3</span><br><span class="line">	coredns:1.6.5</span><br><span class="line">	etcd:3.4.3-0</span><br><span class="line">    pause:3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line"><span class="comment">#   docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName  k8s.gcr.io/$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>




<p>初始化kubeadm</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubeadm init \</span></span><br><span class="line"><span class="bash">--apiserver-advertise-address=10.0.2.15 \</span></span><br><span class="line"><span class="bash">--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \</span></span><br><span class="line"><span class="bash">--kubernetes-version   v1.17.3 \</span></span><br><span class="line"><span class="bash">--service-cidr=10.96.0.0/16  \</span></span><br><span class="line"><span class="bash">--pod-network-cidr=10.244.0.0/16</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>–apiserver-advertise-address=10.0.2.21 ：这里的IP地址是master主机的地址，为上面的eth0网卡的地址；</li>
<li></li>
</ul>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 opt]# kubeadm init \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --apiserver-advertise-address=10.0.2.15 \</span></span><br><span class="line"><span class="bash">&gt; --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \</span></span><br><span class="line"><span class="bash">&gt; --kubernetes-version   v1.17.3 \</span></span><br><span class="line"><span class="bash">&gt; --service-cidr=10.96.0.0/16  \</span></span><br><span class="line"><span class="bash">&gt; --pod-network-cidr=10.244.0.0/16</span></span><br><span class="line">W0503 14:07:12.594252   10124 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]</span><br><span class="line">[init] Using Kubernetes version: v1.17.3</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-node1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.0.2.15]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [k8s-node1 localhost] and IPs [10.0.2.15 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [k8s-node1 localhost] and IPs [10.0.2.15 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">W0503 14:07:30.908642   10124 manifests.go:225] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">W0503 14:07:30.911330   10124 manifests.go:225] the default kube-apiserver authorization-mode is &quot;Node,RBAC&quot;; using &quot;Node,RBAC&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 22.506521 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.18&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node k8s-node1 as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;</span><br><span class="line">[mark-control-plane] Marking the node k8s-node1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: sg47f3.4asffoi6ijb8ljhq</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"><span class="meta">#</span><span class="bash">表示kubernetes已经初始化成功了</span></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.0.2.15:6443 --token sg47f3.4asffoi6ijb8ljhq \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:81fccdd29970cbc1b7dc7f171ac0234d53825bdf9b05428fc9e6767436991bfb </span><br><span class="line">[root@k8s-node1 opt]# </span><br></pre></td></tr></table></figure>





<p>由于默认拉取镜像地址k8s.cr.io国内无法访问，这里指定阿里云仓库地址。可以手动按照我们的images.sh先拉取镜像。</p>
<p>地址变为：registry.aliyuncs.com/googole_containers也可以。<br>科普：无类别域间路由（Classless Inter-Domain Routing 、CIDR）是一个用于给用户分配IP地址以及在互联网上有效第路由IP数据包的对IP地址进行归类的方法。<br>拉取可能失败，需要下载镜像。</p>
<p>运行完成提前复制：加入集群的令牌。</p>
<h4 id="（2）测试Kubectl（主节点执行）"><a href="#（2）测试Kubectl（主节点执行）" class="headerlink" title="（2）测试Kubectl（主节点执行）"></a>（2）测试Kubectl（主节点执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>详细部署文档：<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes <span class="comment">#获取所有节点</span></span></span><br></pre></td></tr></table></figure>

<p>目前Master状态为notready。等待网络加入完成即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> journalctl -u kubelet <span class="comment">#查看kubelet日志</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 10.0.2.15:6443 --token sg47f3.4asffoi6ijb8ljhq \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:81fccdd29970cbc1b7dc7f171ac0234d53825bdf9b05428fc9e6767436991bfb </span><br></pre></td></tr></table></figure>

<h3 id="7）安装POD网络插件（CNI）"><a href="#7）安装POD网络插件（CNI）" class="headerlink" title="7）安装POD网络插件（CNI）"></a>7）安装POD网络插件（CNI）</h3><p>在master节点上执行按照POD网络插件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">kubectl apply -f \</span><br><span class="line">https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/coreos/</span>flanne<span class="regexp">/master/</span>Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>以上地址可能被墙，可以直接获取本地已经下载的flannel.yml运行即可，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl apply -f  kube-flannel.yml    </span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm created</span><br><span class="line">daemonset.apps/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.apps/kube-flannel-ds-s390x created</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>

<p>同时flannel.yml中指定的images访问不到可以去docker hub找一个wget yml地址<br>vi 修改yml 所有amd64的地址修改了即可<br>等待大约3分钟<br>kubectl get pods -n kube-system 查看指定名称空间的pods<br>kubectl get pods -all-namespace 查看所有名称空间的pods</p>
<p>$ ip link set cni0 down 如果网络出现问题，关闭cni0，重启虚拟机继续测试<br>执行watch kubectl get pod -n kube-system -o wide 监控pod进度<br>等待3-10分钟，完全都是running以后继续</p>
<p>查看命名空间：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@k8s-node1 k8s</span>]<span class="meta"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line"><span class="literal">default</span>           Active   <span class="number">30</span>m</span><br><span class="line">kube-node-lease   Active   <span class="number">30</span>m</span><br><span class="line">kube-<span class="keyword">public</span>       Active   <span class="number">30</span>m</span><br><span class="line">kube-system       Active   <span class="number">30</span>m</span><br><span class="line">[<span class="meta">root@k8s-node1 k8s</span>]<span class="meta">#</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get pods --all-namespaces       </span><br><span class="line">NAMESPACE     NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-546565776c-9sbmk            0/1     Pending   0          31m</span><br><span class="line">kube-system   coredns-546565776c-t68mr            0/1     Pending   0          31m</span><br><span class="line">kube-system   etcd-k8s-node1                      1/1     Running   0          31m</span><br><span class="line">kube-system   kube-apiserver-k8s-node1            1/1     Running   0          31m</span><br><span class="line">kube-system   kube-controller-manager-k8s-node1   1/1     Running   0          31m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-6xwth         1/1     Running   0          2m50s</span><br><span class="line">kube-system   kube-proxy-sz2vz                    1/1     Running   0          31m</span><br><span class="line">kube-system   kube-scheduler-k8s-node1            1/1     Running   0          31m</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p> 查看master上的节点信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get nodes</span><br><span class="line">NAME        STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-node1   Ready    master   34m   v1.17.3   #status为ready才能够执行下面的命令</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>

<p>最后再次执行，并且分别在“k8s-node2”和“k8s-node3”上也执行这里命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 10.0.2.15:6443 --token sg47f3.4asffoi6ijb8ljhq \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:81fccdd29970cbc1b7dc7f171ac0234d53825bdf9b05428fc9e6767436991bfb </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 opt]# kubectl get nodes;</span><br><span class="line">NAME        STATUS     ROLES    AGE   VERSION</span><br><span class="line">k8s-node1   Ready      master   47m   v1.17.3</span><br><span class="line">k8s-node2   NotReady   &lt;none&gt;   75s   v1.17.3</span><br><span class="line">k8s-node3   NotReady   &lt;none&gt;   76s   v1.17.3</span><br><span class="line">[root@k8s-node1 opt]# </span><br></pre></td></tr></table></figure>



<p>监控pod进度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch kubectl get pod -n kube-system -o wide</span><br></pre></td></tr></table></figure>

<p>等到所有的status都变为running状态后，再次查看节点信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]#  kubectl get nodes;                         </span><br><span class="line">NAME        STATUS   ROLES    AGE     VERSION</span><br><span class="line">k8s-node1   Ready    master   3h50m   v1.17.3</span><br><span class="line">k8s-node2   Ready    &lt;none&gt;   3h3m    v1.17.3</span><br><span class="line">k8s-node3   Ready    &lt;none&gt;   3h3m    v1.17.3</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>





<h3 id="8）加入kubenetes的Node节点"><a href="#8）加入kubenetes的Node节点" class="headerlink" title="8）加入kubenetes的Node节点"></a>8）加入kubenetes的Node节点</h3><p>在node节点中执行，向集群中添加新的节点，执行在kubeadm init 输出的kubeadm join命令；<br>确保node节点成功：<br>token过期怎么办<br>kubeadm token create –print-join-command</p>
<h3 id="9）入门操作kubernetes集群"><a href="#9）入门操作kubernetes集群" class="headerlink" title="9）入门操作kubernetes集群"></a>9）入门操作kubernetes集群</h3><p>1、在主节点上部署一个tomcat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8</span><br></pre></td></tr></table></figure>



<p>获取所有的资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS              RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-cfd8g   0/1     ContainerCreating   0          41s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   70m</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   0/1     1            0           41s</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   1         1         0       41s</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>



<p>kubectl get pods -o wide 可以获取到tomcat部署信息，能够看到它被部署到了k8s-node2上了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get all -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE    IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/tomcat6-7b84fb5fdc-cfd8g   1/1     Running   0          114s   10.244.2.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   71m   &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE    CONTAINERS   IMAGES               SELECTOR</span><br><span class="line">deployment.apps/tomcat6   1/1     1            1           114s   tomcat       tomcat:6.0.53-jre8   app=tomcat6</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE    CONTAINERS   IMAGES               SELECTOR</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   1         1         1       114s   tomcat       tomcat:6.0.53-jre8   app=tomcat6,pod-template-hash=7b84fb5fdc</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>



<p>查看node2节点上，下载了哪些镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node2 opt]# docker images</span><br><span class="line">REPOSITORY                                                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy   v1.17.3             0d40868643c6        2 weeks ago         117MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause        3.2                 80d28bedfe5d        2 months ago        683kB</span><br><span class="line">quay.io/coreos/flannel                                           v0.11.0-amd64       ff281650a721        15 months ago       52.6MB</span><br><span class="line">tomcat                                                           6.0.53-jre8         49ab0583115a        2 years ago         290MB</span><br><span class="line">[root@k8s-node2 opt]# </span><br></pre></td></tr></table></figure>



<p>查看Node2节点上，正在运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node2 opt]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                            COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">9194cc4f0b7a        tomcat                                                           &quot;catalina.sh run&quot;        2 minutes ago       Up 2 minutes                            k8s_tomcat_tomcat6-7b84fb5fdc-cfd8g_default_0c9ebba2-992d-4c0e-99ef-3c4c3294bc59_0</span><br><span class="line">f44af0c7c345        registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2    &quot;/pause&quot;                 3 minutes ago       Up 3 minutes                            k8s_POD_tomcat6-7b84fb5fdc-cfd8g_default_0c9ebba2-992d-4c0e-99ef-3c4c3294bc59_0</span><br><span class="line">ef74c90491e4        ff281650a721                                                     &quot;/opt/bin/flanneld -…&quot;   20 minutes ago      Up 20 minutes                           k8s_kube-flannel_kube-flannel-ds-amd64-5xs5j_kube-system_11a94346-316d-470b-9668-c15ce183abec_0</span><br><span class="line">c8a524e5a193        registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy   &quot;/usr/local/bin/kube…&quot;   25 minutes ago      Up 25 minutes                           k8s_kube-proxy_kube-proxy-mvlnk_kube-system_519de79a-e8d8-4b1c-a74e-94634cebabce_0</span><br><span class="line">4590685c519a        registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2    &quot;/pause&quot;                 26 minutes ago      Up 26 minutes                           k8s_POD_kube-flannel-ds-amd64-5xs5j_kube-system_11a94346-316d-470b-9668-c15ce183abec_0</span><br><span class="line">54e00af5cde4        registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2    &quot;/pause&quot;                 26 minutes ago      Up 26 minutes                           k8s_POD_kube-proxy-mvlnk_kube-system_519de79a-e8d8-4b1c-a74e-94634cebabce_0</span><br><span class="line">[root@k8s-node2 opt]# </span><br></pre></td></tr></table></figure>



<p>在node1上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get pods</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">tomcat6-7b84fb5fdc-cfd8g   1/1     Running   0          5m35s</span><br><span class="line"></span><br><span class="line">[root@k8s-node1 k8s]# kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE     NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">default       tomcat6-7b84fb5fdc-cfd8g            1/1     Running   0          163m</span><br><span class="line">kube-system   coredns-546565776c-9sbmk            1/1     Running   0          3h52m</span><br><span class="line">kube-system   coredns-546565776c-t68mr            1/1     Running   0          3h52m</span><br><span class="line">kube-system   etcd-k8s-node1                      1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-apiserver-k8s-node1            1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-controller-manager-k8s-node1   1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-5xs5j         1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-6xwth         1/1     Running   0          3h24m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-fvnvx         1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-proxy-7tkvl                    1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-proxy-mvlnk                    1/1     Running   0          3h6m</span><br><span class="line">kube-system   kube-proxy-sz2vz                    1/1     Running   0          3h52m</span><br><span class="line">kube-system   kube-scheduler-k8s-node1            1/1     Running   0          3h52m</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<p>从前面看到tomcat部署在Node2上，现在模拟因为各种原因宕机的情况，将node2关闭电源，观察情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get nodes</span><br><span class="line">NAME        STATUS     ROLES    AGE     VERSION</span><br><span class="line">k8s-node1   Ready      master   4h4m    v1.17.3</span><br><span class="line">k8s-node2   NotReady   &lt;none&gt;   3h18m   v1.17.3</span><br><span class="line">k8s-node3   Ready      &lt;none&gt;   3h18m   v1.17.3</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE    IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">tomcat6-7b84fb5fdc-cfd8g   1/1     Running   0          177m   10.244.2.2   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504104925236.png" alt="image-20200504104925236"></p>
<p>2、暴露nginx访问</p>
<p>在master上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment tomcat6 --port=80 --target-port=8080 --type=NodePort </span><br></pre></td></tr></table></figure>

<p>pod的80映射容器的8080；server会带来pod的80</p>
<p>查看服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        12h</span><br><span class="line">tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   49s</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get svc -o wide</span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE     SELECTOR</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        12h     &lt;none&gt;</span><br><span class="line">tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   3m30s   app=tomcat6</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p> <a href="http://192.168.56.100:30526/">http://192.168.56.100:30526/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%5Cimage-20200504105723874.png" alt="image-20200504105723874"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-qt5jm   1/1     Running   0          13m</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        12h</span><br><span class="line">service/tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   9m50s</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   1/1     1            1           11h</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   1         1         1       11h</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>



<p>3、动态扩容测试</p>
<p>kubectl get deployment</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get deployment</span><br><span class="line">NAME      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">tomcat6   2/2     2            2           11h</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>


<p>应用升级： kubectl set image (–help查看帮助)<br>扩容：kubectl scale –replicas=3 deployment tomcat6</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl scale --replicas=3 deployment tomcat6</span><br><span class="line">deployment.apps/tomcat6 scaled</span><br><span class="line">[root@k8s-node1 ~]# </span><br><span class="line"></span><br><span class="line">[root@k8s-node1 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">tomcat6-7b84fb5fdc-hdgmc   1/1     Running   0          61s   10.244.2.5   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">tomcat6-7b84fb5fdc-qt5jm   1/1     Running   0          19m   10.244.1.2   k8s-node3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">tomcat6-7b84fb5fdc-vlrh6   1/1     Running   0          61s   10.244.2.4   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[root@k8s-node1 ~]# kubectl get svc -o wide    </span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        13h   &lt;none&gt;</span><br><span class="line">tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   16m   app=tomcat6</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>





<p>扩容了多份，所有无论访问哪个node的指定端口，都可以访问到tomcat6</p>
<p> <a href="http://192.168.56.101:30526/">http://192.168.56.101:30526/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504111008668.png" alt="image-20200504111008668"></p>
<p> <a href="http://192.168.56.102:30526/">http://192.168.56.102:30526/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504111028496.png" alt="image-20200504111028496"></p>
<p>缩容：kubectl scale –replicas=2 deployment tomcat6</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@k8s</span><span class="operator">-</span>node1 <span class="operator">~</span>]#  kubectl scale <span class="comment">--replicas=2 deployment tomcat6</span></span><br><span class="line">deployment.apps<span class="operator">/</span>tomcat6 scaled</span><br><span class="line">[root<span class="variable">@k8s</span><span class="operator">-</span>node1 <span class="operator">~</span>]# kubectl <span class="keyword">get</span> pods <span class="operator">-</span>o wide                       </span><br><span class="line">NAME                       READY   STATUS        RESTARTS   AGE     IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">tomcat6<span class="number">-7</span>b84fb5fdc<span class="operator">-</span>hdgmc   <span class="number">0</span><span class="operator">/</span><span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m47s   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>       k8s<span class="operator">-</span>node2   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>           <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span></span><br><span class="line">tomcat6<span class="number">-7</span>b84fb5fdc<span class="operator">-</span>qt5jm   <span class="number">1</span><span class="operator">/</span><span class="number">1</span>     <span class="keyword">Running</span>       <span class="number">0</span>          <span class="number">22</span>m     <span class="number">10.244</span><span class="number">.1</span><span class="number">.2</span>   k8s<span class="operator">-</span>node3   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>           <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span></span><br><span class="line">tomcat6<span class="number">-7</span>b84fb5fdc<span class="operator">-</span>vlrh6   <span class="number">1</span><span class="operator">/</span><span class="number">1</span>     <span class="keyword">Running</span>       <span class="number">0</span>          <span class="number">4</span>m47s   <span class="number">10.244</span><span class="number">.2</span><span class="number">.4</span>   k8s<span class="operator">-</span>node2   <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span>           <span class="operator">&lt;</span><span class="keyword">none</span><span class="operator">&gt;</span></span><br><span class="line">[root<span class="variable">@k8s</span><span class="operator">-</span>node1 <span class="operator">~</span>]# </span><br></pre></td></tr></table></figure>





<p>4、以上操作的yaml获取<br>参照k8s细节</p>
<p>5、删除<br>kubectl get all</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有资源</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-qt5jm   1/1     Running   0          26m</span><br><span class="line">pod/tomcat6-7b84fb5fdc-vlrh6   1/1     Running   0          8m16s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        13h</span><br><span class="line">service/tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   22m</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   2/2     2            2           11h</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   2         2         2       11h</span><br><span class="line">[root@k8s-node1 ~]#</span><br><span class="line"><span class="meta">#</span><span class="bash">删除deployment.apps/tomcat6</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl delete  deployment.apps/tomcat6 </span><br><span class="line">deployment.apps &quot;tomcat6&quot; deleted</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看剩余的资源</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl get all   </span><br><span class="line">NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP        13h</span><br><span class="line">service/tomcat6      NodePort    10.96.24.191   &lt;none&gt;        80:30526/TCP   30m</span><br><span class="line">[root@k8s-node1 ~]# </span><br><span class="line">[root@k8s-node1 ~]#</span><br><span class="line"><span class="meta">#</span><span class="bash">删除service/tomcat6</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl delete service/tomcat6  </span><br><span class="line">service &quot;tomcat6&quot; deleted</span><br><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   13h</span><br><span class="line">[root@k8s-node1 ~]#</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>kubectl delete deploye/nginx<br>kubectl delete service/nginx-service</p>
<h2 id="3、K8s细节"><a href="#3、K8s细节" class="headerlink" title="3、K8s细节"></a>3、K8s细节</h2><h3 id="1、kubectl文档"><a href="#1、kubectl文档" class="headerlink" title="1、kubectl文档"></a>1、kubectl文档</h3><p>​    <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a></p>
<h3 id="2、资源类型"><a href="#2、资源类型" class="headerlink" title="2、资源类型"></a>2、资源类型</h3><p>   <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/#%e8%b5%84%e6%ba%90%e7%b1%bb%e5%9e%8b">https://kubernetes.io/zh/docs/reference/kubectl/overview/#%e8%b5%84%e6%ba%90%e7%b1%bb%e5%9e%8b</a></p>
<h3 id="3、格式化输出"><a href="#3、格式化输出" class="headerlink" title="3、格式化输出"></a>3、格式化输出</h3><p> <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a> </p>
<blockquote>
<p>所有 <code>kubectl</code> 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 <code>-o</code> 或 <code>--output</code> 参数添加到受支持的 <code>kubectl</code> 命令中。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">kubectl [<span class="built_in">command</span>] [TYPE] [NAME] -o=&lt;output_format&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据 <code>kubectl</code> 操作，支持以下输出格式：</p>
<table>
<thead>
<tr>
<th align="left">Output format</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o custom-columns=</code></td>
<td align="left">使用逗号分隔的<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/#custom-columns">自定义列</a>列表打印表。</td>
</tr>
<tr>
<td align="left"><code>-o custom-columns-file=</code></td>
<td align="left">使用 `` 文件中的<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/#custom-columns">自定义列</a>模板打印表。</td>
</tr>
<tr>
<td align="left"><code>-o json</code></td>
<td align="left">输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td align="left">`-o jsonpath=</td>
<td align="left">打印 <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/">jsonpath</a> 表达式定义的字段</td>
</tr>
<tr>
<td align="left"><code>-o jsonpath-file=</code></td>
<td align="left">打印 `` 文件中 <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/">jsonpath</a> 表达式定义的字段。</td>
</tr>
<tr>
<td align="left"><code>-o name</code></td>
<td align="left">仅打印资源名称而不打印任何其他内容。</td>
</tr>
<tr>
<td align="left"><code>-o wide</code></td>
<td align="left">以纯文本格式输出，包含任何附加信息。对于 pod 包含节点名。</td>
</tr>
<tr>
<td align="left"><code>-o yaml</code></td>
<td align="left">输出 YAML 格式的 API 对象。</td>
</tr>
</tbody></table>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>在此示例中，以下命令将单个 pod 的详细信息输出为 YAML 格式的对象：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">kubectl get pod web-pod-13je7 -o yaml</span></span><br></pre></td></tr></table></figure>

<p>请记住：有关每个命令支持哪种输出格式的详细信息，请参阅 <a href="https://kubernetes.io/docs/user-guide/kubectl/">kubectl</a> 参考文档。</p>
</blockquote>
<p>–dry-run：</p>
<blockquote>
<p>–dry-run=’none’: Must be “none”, “server”, or “client”. If client strategy, only print the object that would be</p>
<p>sent, without sending it. If server strategy, submit server-side request without persisting the resource.</p>
<p>值必须为none，server或client。如果是客户端策略，则只打印该发送对象，但不发送它。如果服务器策略，提交服务器端请求而不持久化资源。</p>
<p>也就是说，通过–dry-run选项，并不会真正的执行这条命令。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@k8s-node1</span> <span class="string">~</span>]<span class="comment"># kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 --dry-run -o yaml</span></span><br><span class="line"><span class="string">W0504</span> <span class="number">03</span><span class="string">:39:08.389369</span>    <span class="number">8107 </span><span class="string">helpers.go:535]</span> <span class="string">--dry-run</span> <span class="string">is</span> <span class="string">deprecated</span> <span class="string">and</span> <span class="string">can</span> <span class="string">be</span> <span class="string">replaced</span> <span class="string">with</span> <span class="string">--dry-run=client.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br><span class="line">[<span class="string">root@k8s-node1</span> <span class="string">~</span>]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>实际上我们也可以将这个yaml输出到文件，然后使用kubectl apply -f来应用它</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输出到tomcat6.yaml</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 --dry-run -o yaml &gt;tomcat6.yaml</span><br><span class="line">W0504 03:46:18.180366   11151 helpers.go:535] --dry-run is deprecated and can be replaced with --dry-run=client.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改副本数为3</span></span><br><span class="line">[root@k8s-node1 ~]# cat tomcat6.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    app: tomcat6</span><br><span class="line">  name: tomcat6</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3     #修改副本数为3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: tomcat6</span><br><span class="line">  strategy: &#123;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: tomcat6</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: tomcat:6.0.53-jre8</span><br><span class="line">        name: tomcat</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">status: &#123;&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">应用tomcat6.yaml</span> </span><br><span class="line">[root@k8s-node1 ~]# kubectl apply -f tomcat6.yaml </span><br><span class="line">deployment.apps/tomcat6 created</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p>查看pods：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get pods  </span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">tomcat6-7b84fb5fdc-5jh6t   1/1     Running   0          8s</span><br><span class="line">tomcat6-7b84fb5fdc-8lhwv   1/1     Running   0          8s</span><br><span class="line">tomcat6-7b84fb5fdc-j4qmh   1/1     Running   0          8s</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>



<p>查看某个pod的具体信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get pods tomcat6-7b84fb5fdc-5jh6t  -o yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">tomcat6-7b84fb5fdc-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">pod-template-hash:</span> <span class="string">7b84fb5fdc</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:metadata:</span></span><br><span class="line">        <span class="attr">f:generateName:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:labels:</span></span><br><span class="line">          <span class="string">.:</span> &#123;&#125;</span><br><span class="line">          <span class="attr">f:app:</span> &#123;&#125;</span><br><span class="line">          <span class="attr">f:pod-template-hash:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:ownerReferences:</span></span><br><span class="line">          <span class="string">.:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;uid&quot;:&quot;292bfe3b-dd63-442e-95ce-c796ab5bdcc1&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:apiVersion:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:blockOwnerDeletion:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:controller:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:kind:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:name:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:uid:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">f:spec:</span></span><br><span class="line">        <span class="attr">f:containers:</span></span><br><span class="line">          <span class="string">k:&#123;&quot;name&quot;:&quot;tomcat&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:image:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:imagePullPolicy:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:name:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:resources:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:terminationMessagePath:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:terminationMessagePolicy:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:dnsPolicy:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:enableServiceLinks:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:restartPolicy:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:schedulerName:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:securityContext:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:terminationGracePeriodSeconds:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:status:</span></span><br><span class="line">        <span class="attr">f:conditions:</span></span><br><span class="line">          <span class="string">k:&#123;&quot;type&quot;:&quot;ContainersReady&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastProbeTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:status:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:type:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;type&quot;:&quot;Initialized&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastProbeTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:status:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:type:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;type&quot;:&quot;Ready&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastProbeTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:lastTransitionTime:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:status:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:type:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:containerStatuses:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:hostIP:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:phase:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:podIP:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:podIPs:</span></span><br><span class="line">          <span class="string">.:</span> &#123;&#125;</span><br><span class="line">          <span class="string">k:&#123;&quot;ip&quot;:&quot;10.244.2.7&quot;&#125;:</span></span><br><span class="line">            <span class="string">.:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">f:ip:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:startTime:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubelet</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6-7b84fb5fdc-5jh6t</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat6-7b84fb5fdc</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">292bfe3b-dd63-442e-95ce-c796ab5bdcc1</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;46229&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/pods/tomcat6-7b84fb5fdc-5jh6t</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">2f661212-3b03-47e4-bcb8-79782d5c7578</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">    <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">default-token-bxqtw</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">enableServiceLinks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">k8s-node2</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">  <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">serviceAccount:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">node.kubernetes.io/not-ready</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoExecute</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">node.kubernetes.io/unreachable</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">tolerationSeconds:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-token-bxqtw</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">default-token-bxqtw</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Initialized</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ContainersReady</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">PodScheduled</span></span><br><span class="line">  <span class="attr">containerStatuses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerID:</span> <span class="string">docker://18eb0798384ea44ff68712cda9be94b6fb96265206c554a15cee28c288879304</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">    <span class="attr">imageID:</span> <span class="string">docker-pullable://tomcat@sha256:8c643303012290f89c6f6852fa133b7c36ea6fbb8eb8b8c9588a432beb24dc5d</span></span><br><span class="line">    <span class="attr">lastState:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restartCount:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">started:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">state:</span></span><br><span class="line">      <span class="attr">running:</span></span><br><span class="line">        <span class="attr">startedAt:</span> <span class="string">&quot;2020-05-04T03:50:49Z&quot;</span></span><br><span class="line">  <span class="attr">hostIP:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.4</span></span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Running</span></span><br><span class="line">  <span class="attr">podIP:</span> <span class="number">10.244</span><span class="number">.2</span><span class="number">.7</span></span><br><span class="line">  <span class="attr">podIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.244</span><span class="number">.2</span><span class="number">.7</span></span><br><span class="line">  <span class="attr">qosClass:</span> <span class="string">BestEffort</span></span><br><span class="line">  <span class="attr">startTime:</span> <span class="string">&quot;2020-05-04T03:50:47Z&quot;</span></span><br></pre></td></tr></table></figure>







<h3 id="命令参考"><a href="#命令参考" class="headerlink" title="命令参考"></a>命令参考</h3><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504115823058.png" alt="image-20200504115823058"></p>
<h3 id="service的意义"><a href="#service的意义" class="headerlink" title="service的意义"></a>service的意义</h3><p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504120856830.png" alt="image-20200504120856830"></p>
<p>前面我们通过命令行的方式，部署和暴露了tomcat，实际上也可以通过yaml的方式来完成这些操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这些操作实际上是为了获取Deployment的yaml模板</span></span><br><span class="line">[root@k8s-node1 ~]#  kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 --dry-run -o yaml &gt;tomcat6-deployment.yaml</span><br><span class="line">W0504 04:13:28.265432   24263 helpers.go:535] --dry-run is deprecated and can be replaced with --dry-run=client.</span><br><span class="line">[root@k8s-node1 ~]# ls tomcat6-deployment.yaml</span><br><span class="line">tomcat6-deployment.yaml</span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>

<p>修改“tomcat6-deployment.yaml”内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">部署</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl apply -f tomcat6-deployment.yaml</span><br><span class="line">deployment.apps/tomcat6 configured</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看资源</span></span><br><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-5jh6t   1/1     Running   0          27m</span><br><span class="line">pod/tomcat6-7b84fb5fdc-8lhwv   1/1     Running   0          27m</span><br><span class="line">pod/tomcat6-7b84fb5fdc-j4qmh   1/1     Running   0          27m</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   14h</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   3/3     3            3           27m</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   3         3         3       27m</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>





<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment tomcat6 --port=80 --target-port=8080 --type=NodePort  --dry-run -o yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>将这段输出和“tomcat6-deployment.yaml”进行拼接，表示部署完毕并进行暴露服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">tomcat:6.0.53-jre8</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat6</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat6</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>



<p>部署并暴露服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl apply -f tomcat6-deployment.yaml</span><br><span class="line">deployment.apps/tomcat6 created</span><br><span class="line">service/tomcat6 created</span><br></pre></td></tr></table></figure>

<p>查看服务和部署信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/tomcat6-7b84fb5fdc-dsqmb   1/1     Running   0          4s</span><br><span class="line">pod/tomcat6-7b84fb5fdc-gbmxc   1/1     Running   0          5s</span><br><span class="line">pod/tomcat6-7b84fb5fdc-kjlc6   1/1     Running   0          4s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        14h</span><br><span class="line">service/tomcat6      NodePort    10.96.147.210   &lt;none&gt;        80:30172/TCP   4s</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/tomcat6   3/3     3            3           5s</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/tomcat6-7b84fb5fdc   3         3         3       5s</span><br><span class="line">[root@k8s-node1 ~]#</span><br></pre></td></tr></table></figure>

<p>访问node1，node1和node3的30172端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]# curl -I http://192.168.56.&#123;100,101,102&#125;:30172/</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: W/&quot;7454-1491118183000&quot;</span><br><span class="line">Last-Modified: Sun, 02 Apr 2017 07:29:43 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 7454</span><br><span class="line">Date: Mon, 04 May 2020 04:35:35 GMT</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: W/&quot;7454-1491118183000&quot;</span><br><span class="line">Last-Modified: Sun, 02 Apr 2017 07:29:43 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 7454</span><br><span class="line">Date: Mon, 04 May 2020 04:35:35 GMT</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: W/&quot;7454-1491118183000&quot;</span><br><span class="line">Last-Modified: Sun, 02 Apr 2017 07:29:43 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 7454</span><br><span class="line">Date: Mon, 04 May 2020 04:35:35 GMT</span><br><span class="line"></span><br><span class="line">[root@k8s-node1 ~]# </span><br></pre></td></tr></table></figure>



<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>通过Ingress发现pod进行关联。基于域名访问<br>通过Ingress controller实现POD负载均衡<br>支持TCP/UDP 4层负载均衡和HTTP 7层负载均衡</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504123948771.png" alt="image-20200504123948771"></p>
<p>步骤：<br>（1）部署Ingress controller</p>
<p>执行“k8s/ingress-controller.yaml”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl apply -f ingress-controller.yaml </span><br><span class="line">namespace/ingress-nginx created</span><br><span class="line">configmap/nginx-configuration created</span><br><span class="line">configmap/tcp-services created</span><br><span class="line">configmap/udp-services created</span><br><span class="line">serviceaccount/nginx-ingress-serviceaccount created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created</span><br><span class="line">role.rbac.authorization.k8s.io/nginx-ingress-role created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created</span><br><span class="line">daemonset.apps/nginx-ingress-controller created</span><br><span class="line">service/ingress-nginx created</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>



<p>查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE       NAME                                READY   STATUS              RESTARTS   AGE</span><br><span class="line">default         tomcat6-7b84fb5fdc-dsqmb            1/1     Running             0          16m</span><br><span class="line">default         tomcat6-7b84fb5fdc-gbmxc            1/1     Running             0          16m</span><br><span class="line">default         tomcat6-7b84fb5fdc-kjlc6            1/1     Running             0          16m</span><br><span class="line">ingress-nginx   nginx-ingress-controller-9q6cs      0/1     ContainerCreating   0          40s</span><br><span class="line">ingress-nginx   nginx-ingress-controller-qx572      0/1     ContainerCreating   0          40s</span><br><span class="line">kube-system     coredns-546565776c-9sbmk            1/1     Running             1          14h</span><br><span class="line">kube-system     coredns-546565776c-t68mr            1/1     Running             1          14h</span><br><span class="line">kube-system     etcd-k8s-node1                      1/1     Running             1          14h</span><br><span class="line">kube-system     kube-apiserver-k8s-node1            1/1     Running             1          14h</span><br><span class="line">kube-system     kube-controller-manager-k8s-node1   1/1     Running             1          14h</span><br><span class="line">kube-system     kube-flannel-ds-amd64-5xs5j         1/1     Running             2          13h</span><br><span class="line">kube-system     kube-flannel-ds-amd64-6xwth         1/1     Running             2          14h</span><br><span class="line">kube-system     kube-flannel-ds-amd64-fvnvx         1/1     Running             1          13h</span><br><span class="line">kube-system     kube-proxy-7tkvl                    1/1     Running             1          13h</span><br><span class="line">kube-system     kube-proxy-mvlnk                    1/1     Running             2          13h</span><br><span class="line">kube-system     kube-proxy-sz2vz                    1/1     Running             1          14h</span><br><span class="line">kube-system     kube-scheduler-k8s-node1            1/1     Running             1          14h</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>

<p>这里master节点负责调度，具体执行交给node2和node3来完成，能够看到它们正在下载镜像</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504124608258.png" alt="image-20200504124608258"></p>
<p>（2）创建Ingress规则</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat6.kubenetes.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">       <span class="attr">paths:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span> </span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">tomcat6</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# touch ingress-tomcat6.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash">将上面的规则，添加到ingress-tomcat6.yaml文件中</span></span><br><span class="line">[root@k8s-node1 k8s]# vi  ingress-tomcat6.yaml  </span><br><span class="line"> </span><br><span class="line">[root@k8s-node1 k8s]# kubectl apply -f ingress-tomcat6.yaml </span><br><span class="line">ingress.extensions/web created</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p>修改本机的hosts文件，添加如下的域名转换规则：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168.56.102</span> tomcat6.kubenetes.com</span><br></pre></td></tr></table></figure>



<p>测试: <a href="http://tomcat6.kubenetes.com/">http://tomcat6.kubenetes.com/</a> </p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504131325267.png" alt="image-20200504131325267"></p>
<p>并且集群中即便有一个节点不可用，也不影响整体的运行。</p>
<h2 id="安装kubernetes可视化界面——DashBoard"><a href="#安装kubernetes可视化界面——DashBoard" class="headerlink" title="安装kubernetes可视化界面——DashBoard"></a>安装kubernetes可视化界面——DashBoard</h2><p>1、部署DashBoard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl appy -f  kubernetes-dashboard.yaml</span></span><br></pre></td></tr></table></figure>

<p> 文件在“k8s”源码目录提供</p>
<p>2、暴露DashBoard为公共访问</p>
<p>默认DashBoard只能集群内部访问，修改Service为NodePort类型，暴露到外部</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">3001</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>

<p>访问地址：<a href="http://nodeip:30001/">http://NodeIP:30001</a></p>
<p>3、创建授权账号</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="keyword">create</span> serviceaccount dashboar-<span class="keyword">admin</span> -n kube-sysem</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ kubectl create clusterrolebinding dashboar-admin <span class="attribute">--clusterrole</span>=cluter-admin <span class="attribute">--serviceaccount</span>=kube-system:dashboard-admin</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ kubectl describe secrets -n kube-system <span class="constructor">$( <span class="params">kubectl</span> -<span class="params">n</span> <span class="params">kube</span>-<span class="params">system</span> <span class="params">get</span> <span class="params">secret</span> |<span class="params">awk</span> &#x27;<span class="operator">/</span><span class="params">dashboard</span>-<span class="params">admin</span><span class="operator">/</span>&#123;<span class="params">print</span> $1&#125;&#x27; )</span></span><br></pre></td></tr></table></figure>

<p>使用输出的token登录dashboard</p>
<p><img src="/2021/12/26/k8s%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20200504153630775.png" alt="image-20200504153630775"></p>
<h2 id="kubesphere"><a href="#kubesphere" class="headerlink" title="kubesphere"></a>kubesphere</h2><p>默认的dashboard没啥用，我们用kubesphere可以打通全部的devops链路，kubesphere集成了很多套件，集群要求比较高<br><a href="https://kubesphere.io/">https://kubesphere.io</a></p>
<p>kuboard也很不错，集群要求不高<br><a href="https://kuboard.cn/support/">https://kuboard.cn/support/</a></p>
<h3 id="1、简洁"><a href="#1、简洁" class="headerlink" title="1、简洁"></a>1、简洁</h3><p>kubesphere是一款面向云原声设计的开源项目，在目前主流容器调度平台kubernets智商构建的分布式多用户容器管理平台，提供简单易用的操作界面以及向导式操作方式，在降低用户使用容器调度平台学习成本的同时，极大降低开发、测试、运维的日常工作的复杂度。</p>
<h3 id="2、安装前提提交"><a href="#2、安装前提提交" class="headerlink" title="2、安装前提提交"></a>2、安装前提提交</h3><h4 id="1、安装helm（master节点执行）"><a href="#1、安装helm（master节点执行）" class="headerlink" title="1、安装helm（master节点执行）"></a>1、安装helm（master节点执行）</h4><p>helm是kubernetes的包管理器。包管理器类似于在Ubuntu中使用的apt，centos中的yum或者python中的pip一样，能够快速查找，下载和安装软件包。Helm有客户端组件helm和服务端组件Tiller组成，能够将一组K8S资源打包统一管理，是查找、共享和使用为Kubernetes构建的软件的最佳方式。</p>
<p>1）安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -L https:<span class="regexp">//gi</span>t.io/get_helm.sh|bash</span><br></pre></td></tr></table></figure>

<p>由于被墙的原因，使用我们给定的get_helm.sh。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# ll</span><br><span class="line">total 68</span><br><span class="line">-rw-r--r-- 1 root root  7149 Feb 27 01:58 get_helm.sh</span><br><span class="line">-rw-r--r-- 1 root root  6310 Feb 28 05:16 ingress-controller.yaml</span><br><span class="line">-rw-r--r-- 1 root root   209 Feb 28 13:18 ingress-demo.yml</span><br><span class="line">-rw-r--r-- 1 root root   236 May  4 05:09 ingress-tomcat6.yaml</span><br><span class="line">-rwxr--r-- 1 root root 15016 Feb 26 15:05 kube-flannel.yml</span><br><span class="line">-rw-r--r-- 1 root root  4737 Feb 26 15:38 kubernetes-dashboard.yaml</span><br><span class="line">-rw-r--r-- 1 root root  3841 Feb 27 01:09 kubesphere-complete-setup.yaml</span><br><span class="line">-rw-r--r-- 1 root root   392 Feb 28 11:33 master_images.sh</span><br><span class="line">-rw-r--r-- 1 root root   283 Feb 28 11:34 node_images.sh</span><br><span class="line">-rw-r--r-- 1 root root  1053 Feb 28 03:53 product.yaml</span><br><span class="line">-rw-r--r-- 1 root root   931 May  3 10:08 Vagrantfile</span><br><span class="line">[root@k8s-node1 k8s]# sh get_helm.sh </span><br><span class="line">Downloading https://get.helm.sh/helm-v2.16.6-linux-amd64.tar.gz</span><br><span class="line">Preparing to install helm and tiller into /usr/local/bin</span><br><span class="line">helm installed into /usr/local/bin/helm</span><br><span class="line">tiller installed into /usr/local/bin/tiller</span><br><span class="line">Run &#x27;helm init&#x27; to configure helm.</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p>2）验证版本</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">version</span></span><br></pre></td></tr></table></figure>

<p>3）创建权限（master执行）</p>
<p>创建helm-rbac.yaml，写入如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<p>应用配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]#  kubectl apply -f helm-rbac.yaml</span><br><span class="line">serviceaccount/tiller created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/tiller created</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>



<h4 id="2、安装Tilller（Master执行）"><a href="#2、安装Tilller（Master执行）" class="headerlink" title="2、安装Tilller（Master执行）"></a>2、安装Tilller（Master执行）</h4><p>1、初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]# helm init --service-account=tiller --tiller-image=sapcc/tiller:v2.16.3 --history-max 300 </span><br><span class="line">Creating /root/.helm </span><br><span class="line">Creating /root/.helm/repository </span><br><span class="line">Creating /root/.helm/repository/cache </span><br><span class="line">Creating /root/.helm/repository/local </span><br><span class="line">Creating /root/.helm/plugins </span><br><span class="line">Creating /root/.helm/starters </span><br><span class="line">Creating /root/.helm/cache/archive </span><br><span class="line">Creating /root/.helm/repository/repositories.yaml </span><br><span class="line">Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com </span><br><span class="line">Adding local repo with URL: http://127.0.0.1:8879/charts </span><br><span class="line"><span class="meta">$</span><span class="bash">HELM_HOME has been configured at /root/.helm.</span></span><br><span class="line"></span><br><span class="line">Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</span><br><span class="line"></span><br><span class="line">Please note: by default, Tiller is deployed with an insecure &#x27;allow unauthenticated users&#x27; policy.</span><br><span class="line">To prevent this, run `helm init` with the --tiller-tls-verify flag.</span><br><span class="line">For more information on securing your installation see: https://v2.helm.sh/docs/securing_installation/</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>

<p>–tiller-image 指定镜像，否则会被墙，等待节点上部署的tiller完成即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]#  kubectl get pods -n kube-system</span><br><span class="line">NAME                                   READY   STATUS             RESTARTS   AGE</span><br><span class="line">coredns-546565776c-9sbmk               1/1     Running            3          23h</span><br><span class="line">coredns-546565776c-t68mr               1/1     Running            3          23h</span><br><span class="line">etcd-k8s-node1                         1/1     Running            3          23h</span><br><span class="line">kube-apiserver-k8s-node1               1/1     Running            3          23h</span><br><span class="line">kube-controller-manager-k8s-node1      1/1     Running            3          23h</span><br><span class="line">kube-flannel-ds-amd64-5xs5j            1/1     Running            4          22h</span><br><span class="line">kube-flannel-ds-amd64-6xwth            1/1     Running            5          23h</span><br><span class="line">kube-flannel-ds-amd64-fvnvx            1/1     Running            4          22h</span><br><span class="line">kube-proxy-7tkvl                       1/1     Running            3          22h</span><br><span class="line">kube-proxy-mvlnk                       1/1     Running            4          22h</span><br><span class="line">kube-proxy-sz2vz                       1/1     Running            3          23h</span><br><span class="line">kube-scheduler-k8s-node1               1/1     Running            3          23h</span><br><span class="line">kubernetes-dashboard-975499656-jxczv   0/1     ImagePullBackOff   0          7h45m</span><br><span class="line">tiller-deploy-8cc566858-67bxb          1/1     Running            0          31s</span><br><span class="line">[root@k8s-node1 k8s]#</span><br></pre></td></tr></table></figure>



<p>查看集群的所有节点信息：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">kubectl get <span class="keyword">node</span> <span class="title">-o</span> wide</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 k8s]#  kubectl get node -o wide</span><br><span class="line">NAME        STATUS   ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION               CONTAINER-RUNTIME</span><br><span class="line">k8s-node1   Ready    master   23h   v1.17.3   10.0.2.15     &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://19.3.8</span><br><span class="line">k8s-node2   Ready    &lt;none&gt;   22h   v1.17.3   10.0.2.4      &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://19.3.8</span><br><span class="line">k8s-node3   Ready    &lt;none&gt;   22h   v1.17.3   10.0.2.5      &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-957.12.2.el7.x86_64   docker://19.3.8</span><br><span class="line">[root@k8s-node1 k8s]# </span><br></pre></td></tr></table></figure>





<p>2、测试</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">helm install <span class="keyword">stable</span>/nginx-ingress <span class="comment">--name nginx-ingress</span></span><br></pre></td></tr></table></figure>





<p>最小化安装 KubeSphere</p>
<p>若集群可用 CPU &gt; 1 Core 且可用内存 &gt; 2 G，可以使用以下命令最小化安装 KubeSphere：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">https://raw.githubusercontent.com/kubesphere/ks-installer/master/kubesphere-minimal.yaml</span></span><br></pre></td></tr></table></figure>

<p> <strong>提示：若您的服务器提示无法访问 GitHub，可将</strong> <a href="https://github.com/kubesphere/ks-installer/blob/master/kubesphere-minimal.yaml">kubesphere-minimal.yaml</a> <strong>或</strong> <a href="https://github.com/kubesphere/ks-installer/blob/master/kubesphere-complete-setup.yaml">kubesphere-complete-setup.yaml</a> <strong>文件保存到本地作为本地的静态文件，再参考上述命令进行安装。</strong> </p>
<ol>
<li>查看滚动刷新的安装日志，请耐心等待安装成功。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=<span class="string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：安装过程中若遇到问题，也可以通过以上日志命令来排查问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="人工智能、模式识别、机器学习、深度学习？"><a href="#人工智能、模式识别、机器学习、深度学习？" class="headerlink" title="人工智能、模式识别、机器学习、深度学习？"></a><strong>人工智能、模式识别、机器学习、深度学习？</strong></h1><p>​        后三者都是实现人工智能的途径，其中我们需要把深度学习与模式识别、机器学习这两个领域区分开来。</p>
<h2 id="1-模式识别："><a href="#1-模式识别：" class="headerlink" title="1. 模式识别："></a>1. 模式识别：</h2><p>​        模式识别是指对表征事物或现象的各种形式的(数值的、文字的和逻辑关系的)信息进行处理和分析，以对事物或现象进行<strong>描述、辨认、分类和解释</strong>的过程，是信息科学和人工智能的重要组成部分。我们把环境与客体统称为“模式”。随着计算机技术的发展，人类会研究复杂的信息处理过程，一个重要形式是生命体对环境及客体的识别。以光学字符识别之“汉字识别”为例：首先将汉字图像进行处理，抽取主要表达特征并将特征与汉字的代码存在计算机中。就像老师教我们“这个字叫什么、如何写”记在大脑中。这一过程叫做“训练”。识别过程就是将输入的汉字图像经处理后与计算机中的所有字进行比较，找出最相近的字就是识别结果，这一过程叫做“匹配”。</p>
<h2 id="2-机器学习："><a href="#2-机器学习：" class="headerlink" title="2. 机器学习："></a>2. 机器学习：</h2><p>​        计算机程序可以在给定某种类别的任务 T 和性能度量 P 下学习经验 E ，如果其在任务 T 中的性能恰好可以用 P 度量，则随着经验 E 而提高。机器从已知的经验数据（样本）中，通过某种特定的方法（算法），自己去寻找提炼（训练/学习）出一些规律（模型）；提炼出的规律就可以用来判断一些未知的事情（预测）。</p>
<p>​        机器学习(Machine Learning，ML)是人工智能的子领域，也是人工智能的核心。它囊括了几乎所有对世界影响最大的方法(包括深度学习)。机器学习理论主要是设计和分析一些让计算机可以自动学习的算法。</p>
<p>​        举个例子，假设要构建一个识别猫的程序。传统上如果我们想让计算机进行识别，需要输入一串指令，例如猫长着毛茸茸的毛、顶着一对三角形的的耳朵等，然后计算机根据这些指令执行下去。但是如果我们对程序展示一只老虎的照片，程序应该如何反应呢？更何况通过传统方式要制定全部所需的规则，而且在此过程中必然会涉及到一些困难的概念，比如对毛茸茸的定义。因此，更好的方式是让机器自学。</p>
<p>​        我们可以为计算机提供大量的猫的照片，系统将以自己特有的方式查看这些照片。随着实验的反复进行，系统会不断学习更新，最终能够准确地判断出哪些是猫，哪些不是猫。</p>
<p>模式识别与机器学习的区别是：前者喂给机器的是各种<strong>特征描述</strong>，从而让机器对未知的事物进行判断；后者喂给机器的是某一事物的<strong>海量样本</strong>，让机器通过样本来自己发现特征，最后去判断某些未知的事物。</p>
<h2 id="3-深度学习"><a href="#3-深度学习" class="headerlink" title="3. 深度学习"></a>3. 深度学习</h2><p>&emsp;&emsp;深度学习是一种特殊的机器学习。深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。 深度学习是一个复杂的机器学习算法，在语音和图像识别方面取得的效果，远远超过先前相关技术。<br>&emsp;&emsp;深度学习的灵感来源于人类大脑的工作方式，是利用深度神经网络来解决特征表达的一种学习过程。深度神经网络本身并非是一个全新的概念，可理解为包含多个隐含层的神经网络结构。为了提高深层神经网络的训练效果，人们对神经元的连接方法以及激活函数等方面做出了调整。其目的在于建立、模拟人脑进行分析学习的神经网络，模仿人脑的机制来解释数据，如文本、图像、声音。</p>
<h3 id="机器学习与深度学习的比较"><a href="#机器学习与深度学习的比较" class="headerlink" title="机器学习与深度学习的比较"></a><strong>机器学习与深度学习的比较</strong></h3><p><strong>1、应用场景</strong></p>
<p>​        机器学习在指纹识别、特征物体检测等领域的应用基本达到了商业化的要求。深度学习主要应用于文字识别、人脸技术、语义分析、智能监控等领域。目前在智能硬件、教育、医疗等行业也在快速布局。</p>
<p><strong>2、所需数据量</strong></p>
<p>​        机器学习能够适应各种数据量，特别是数据量较小的场景。如果数据量迅速增加，那么深度学习的效果将更加突出，这是因为深度学习算法需要大量数据才能完美理解。</p>
<p><strong>3、执行时间</strong></p>
<p>​        执行时间是指训练算法所需要的时间量。一般来说，深度学习算法需要大量时间进行训练。这是因为该算法包含有很多参数，因此训练它们需要比平时更长的时间。相对而言，机器学习算法的执行时间更少。</p>
<p><strong>4、解决问题的方法</strong></p>
<p>​        机器学习算法遵循标准程序以解决问题。它将问题拆分成数个部分，对其进行分别解决，而后再将结果结合起来以获得所需的答案。深度学习则以集中方式解决问题，而不必进行问题拆分。</p>
<p><img src="/2021/12/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20180830211736920.png" alt="三者关系图"></p>
<p>​        深度学习的优点在于学习能力强、覆盖范围广、数据驱动，其缺点在于计算量大、硬件需求高、模型设计复杂。这是事实，但是作为安全研究人员，我们更需要关注的不是怎么搭房子（怎么设计深度学习系统），而是怎么拆房子（如何对其进行攻击）以及如果搭更坚固的房子（如何进行针对性防御）。</p>
<p>​        这里非常关键的一点，就是模型的可解释性问题：深度学习存在所谓的黑箱问题，由此带来了不可解释性，而这一点如果不能解决（事实上目前为止还没有很好解决）将会导致在深度学习在对安全性很敏感的领域中应用的受限。比如将其应用在医疗领域时，深度学习系统根据医学影像判断病人为癌症，但是不能解释为什么给出这个判断，而人类医学专家认为不是癌症，那么这时存在两种情况，一种是深度学习系统错了；第二种则是专家错了，可是由于系统无法给出解释，所以专家未必采纳系统意见，则造成病人的损失。无论是哪种情况，都可以看到不解决深度学习的可解释性问题，其未来的应用发展是一定会受到限制的。</p>
<h2 id="深度学习典型模型"><a href="#深度学习典型模型" class="headerlink" title="深度学习典型模型"></a>深度学习典型模型</h2><p>典型的深度学习模型有卷积神经网络( convolutional neural network)、DBN和堆栈自编码网络(stacked auto-encoder network)模型等，</p>
<h3 id="卷积神经网络模型"><a href="#卷积神经网络模型" class="headerlink" title="卷积神经网络模型"></a>卷积神经网络模型</h3><p>​        在无监督预训练出现之前，训练深度神经网络通常非常困难，而其中一个特例是卷积神经网络。卷积神经网络受视觉系统的结构启发而产生。第一个卷积神经网络计算模型是在Fukushima(D的神经认知机中提出的，基于神经元之间的局部连接和分层组织图像转换，将有相同参数的神经元应用于前一层神经网络的不同位置，得到一种平移不变神经网络结构形式。后来，Le Cun等人在该思想的基础上，用误差梯度设计并训练卷积神经网络，在一些模式识别任务上得到优越的性能。至今，基于卷积神经网络的模式识别系统是最好的实现系统之一，尤其在手写体字符识别任务上表现出非凡的性能。</p>
<h3 id="深度信任网络模型"><a href="#深度信任网络模型" class="headerlink" title="深度信任网络模型"></a>深度信任网络模型</h3><p>​        DBN可以解释为贝叶斯概率生成模型，由多层随机隐变量组成，上面的两层具有无向对称连接，下面的层得到来自上一层的自顶向下的有向连接，最底层单元的状态为可见输入数据向量。DBN由若2F结构单元堆栈组成，结构单元通常为RBM（RestIlcted Boltzmann Machine，受限玻尔兹曼机）。堆栈中每个RBM单元的可视层神经元数量等于前一RBM单元的隐层神经元数量。根据深度学习机制，采用输入样例训练第一层RBM单元，并利用其输出训练第二层RBM模型，将RBM模型进行堆栈通过增加层来改善模型性能。在无监督预训练过程中，DBN编码输入到顶层RBM后，解码顶层的状态到最底层的单元，实现输入的重构。RBM作为DBN的结构单元，与每一层DBN共享参数。</p>
<h3 id="堆栈自编码网络模型"><a href="#堆栈自编码网络模型" class="headerlink" title="堆栈自编码网络模型"></a>堆栈自编码网络模型</h3><p>​        堆栈自编码网络的结构与DBN类似，由若干结构单元堆栈组成，不同之处在于其结构单元为自编码模型( auto-en-coder)而不是RBM。自编码模型是一个两层的神经网络，第一层称为编码层，第二层称为解码层。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>​        香港中文大学的多媒体实验室是最早应用深度学习进行计算机视觉研究的华人团队。在世界级人工智能竞赛LFW（大规模人脸识别竞赛）上，该实验室曾力压FaceBook夺得冠军，使得人工智能在该领域的识别能力首次超越真人。 </p>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>​        微软研究人员通过与hinton合作，首先将RBM和DBN引入到语音识别声学模型训练中，并且在大词汇量语音识别系统中获得巨大成功，使得语音识别的错误率相对减低30%。但是，DNN还没有有效的并行快速算法，很多研究机构都是在利用大规模数据语料通过GPU平台提高DNN声学模型的训练效率。 在国际上，IBM、google等公司都快速进行了DNN语音识别的研究，并且速度飞快。国内方面，阿里巴巴、科大讯飞、百度、中科院自动化所等公司或研究单位，也在进行深度学习在语音识别上的研究。</p>
<h3 id="自然语言处理等其他领域"><a href="#自然语言处理等其他领域" class="headerlink" title="自然语言处理等其他领域"></a>自然语言处理等其他领域</h3><p>​        很多机构在开展研究，2013年，Tomas Mikolov，Kai Chen，Greg Corrado，Jeffrey Dean发表论文Efficient Estimation of Word Representations in Vector Space建立word2vector模型，与传统的词袋模型（bag of words）相比，word2vector能够更好地表达语法信息。深度学习在自然语言处理等领域主要应用于机器翻译以及语义挖掘等方面。</p>
<p>参考链接: <a href="https://blog.csdn.net/yalecaltech/article/details/117249408">如何攻击深度学习系统？–可解释性及鲁棒性研究</a></p>
<p>​                <a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/3729729?fr=aladdin">深度学习（人工神经网络的研究的概念）_百度百科 (baidu.com)</a></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客</title>
    <url>/2021/12/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div><div class="fold_hider"><div class="close hider_title">显/隐</div></div><div class="fold">
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">something</span> you want to fold, <span class="meta">include</span> <span class="meta">code</span> block.</span><br></pre></td></tr></table></figure>

</div></div>

<div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold">
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span>something you want <span class="keyword">to</span> fold, include code block.</span><br></pre></td></tr></table></figure>

</div></div>

<p>hello</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
