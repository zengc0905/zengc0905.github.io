<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/dataphin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/dataphin.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zengc0905.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="程序员面试金典刷题笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员面试金典">
<meta property="og:url" content="http://zengc0905.github.io/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/index.html">
<meta property="og:site_name" content="曾超の博客">
<meta property="og:description" content="程序员面试金典刷题笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-30T06:25:19.000Z">
<meta property="article:modified_time" content="2022-06-29T02:23:34.258Z">
<meta property="article:author" content="曾超">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zengc0905.github.io/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>程序员面试金典 | 曾超の博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-PLK3B9Z0FG"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-PLK3B9Z0FG');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="曾超の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <!--
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>
   -->

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">曾超の博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录日常的学习与生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zengc0905.github.io/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zc1.jpg">
      <meta itemprop="name" content="曾超">
      <meta itemprop="description" content="天天经过小巷，乱花漫了高墙，贪看蜂狂蝶舞，忘了世态炎凉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曾超の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序员面试金典
        </h1>

        <div class="post-meta">

          
            <i class="fa fa-thumb-tack"></i>
            <font color= 0A0A0A>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-30 14:25:19" itemprop="dateCreated datePublished" datetime="2022-04-30T14:25:19+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-29 10:23:34" itemprop="dateModified" datetime="2022-06-29T10:23:34+08:00">2022-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>108k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:39</span>
            </span>
            <div class="post-description">程序员面试金典刷题笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="程序员面试金典"><a href="#程序员面试金典" class="headerlink" title="程序员面试金典"></a>程序员面试金典</h1><h2 id="001-050"><a href="#001-050" class="headerlink" title="001 - 050"></a>001 - 050</h2><h3 id="01-01-判定字符是否唯一"><a href="#01-01-判定字符是否唯一" class="headerlink" title="01.01. 判定字符是否唯一"></a>01.01. 判定字符是否唯一</h3><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= len(s) &lt;= 100</code></li>
<li>如果你不使用额外的数据结构，会很加分。</li>
</ul>
<p>hashset可以一次遍历解决，但用到了额外的数据结构，可用位运算。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = astr.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> ((mark &amp; (<span class="number">1</span> &lt;&lt; index)) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            mark |= (<span class="number">1</span> &lt;&lt; index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="01-02-判定是否互为字符重排"><a href="#01-02-判定是否互为字符重排" class="headerlink" title="01.02. 判定是否互为字符重排"></a>01.02. 判定是否互为字符重排</h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<p><strong>说明：</strong></p>
<ul>
<li><code>0 &lt;= len(s1) &lt;= 100</code></li>
<li><code>0 &lt;= len(s2) &lt;= 100</code></li>
</ul>
<p>方法：用一个数组记录频次，也可以排序解决，但时间复杂度更高</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s1.length() != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            arr[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            arr[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(S),S为字符集大小，此题中为26；</p>
<hr>
<h3 id="01-03-URL化"><a href="#01-03-URL化" class="headerlink" title="01.03. URL化"></a>01.03. URL化</h3><p>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>
<p><strong>提示：</strong></p>
<ul>
<li>字符串长度在 [0, 500000] 范围内。</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先把字符串转化为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> index = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//如果遇到空格就把他转化为&quot;%20&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                chars[index--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                chars[index--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                chars[index--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chars[index--] = chars[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars, index + <span class="number">1</span>, chars.length - index - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<hr>
<h3 id="01-04-回文排列"><a href="#01-04-回文排列" class="headerlink" title="01.04.回文排列"></a>01.04.回文排列</h3><p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>
<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>
<p>回文串不一定是字典当中的单词。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">                map.put(c,map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) % <span class="number">2</span> != <span class="number">0</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<hr>
<h3 id="01-05-一次编辑"><a href="#01-05-一次编辑" class="headerlink" title="01.05. 一次编辑"></a>01.05. 一次编辑</h3><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = first.length(), m = second.length();</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(n - m) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> oneEditAway(second, first);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m &amp;&amp; cnt &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = first.charAt(i), c2 = second.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">                    i++; j++; cnt++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++; cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(max(n,m))</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="01-06-字符串压缩"><a href="#01-06-字符串压缩" class="headerlink" title="01.06. 字符串压缩"></a>01.06. 字符串压缩</h3><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<p><strong>提示：</strong></p>
<ol>
<li>字符串长度在[0, 50000]范围内。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n &amp;&amp; S.charAt(i + <span class="number">1</span>) == c)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() &lt; n ? sb.toString() : S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="01-07-旋转矩阵"><a href="#01-07-旋转矩阵" class="headerlink" title="01.07. 旋转矩阵"></a>01.07. 旋转矩阵</h3><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<p>方法一：原地旋转</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2)</p>
<p>空间复杂度:O(1)</p>
<p>方法二：翻转代替旋转</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - i - <span class="number">1</span>][j];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="01-08-零矩阵"><a href="#01-08-零矩阵" class="headerlink" title="01.08. 零矩阵"></a>01.08. 零矩阵</h3><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
 <div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[] row = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        <span class="keyword">boolean</span>[] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[i] = col[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(mn)</p>
<p>空间复杂度:O(m + n)</p>
<hr>
<h3 id="01-09-字符串轮转"><a href="#01-09-字符串轮转" class="headerlink" title="01.09. 字符串轮转"></a>01.09. 字符串轮转</h3><p>字符串轮转。给定两个字符串<code>s1</code>和<code>s2</code>，请编写代码检查<code>s2</code>是否为<code>s1</code>旋转而成（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串）。</p>
<p><strong>提示：</strong></p>
<ol>
<li>字符串长度在[0, 100000]范围内。</li>
</ol>
<p><strong>说明:</strong></p>
<ol>
<li>你能只调用一次检查子串的方法吗？</li>
</ol>
<p> 方法一：暴力枚举</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(),len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span> &amp;&amp; len2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (len1 != len2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.substring(<span class="number">0</span>,i + <span class="number">1</span>).equals(s2.substring(len2 - i - <span class="number">1</span>,len2)) &amp;&amp; </span><br><span class="line">                    s1.substring(i + <span class="number">1</span>,len1).equals(s2.substring(<span class="number">0</span>,len2 - i - <span class="number">1</span>)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n^2)</p>
<p>空间复杂度:O(1)</p>
<p>方法二：搜索子字符串</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.length() == s2.length() &amp;&amp; (s1 + s1).contains(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<hr>
<h3 id="02-01-移除重复节点"><a href="#02-01-移除重复节点" class="headerlink" title="02.01. 移除重复节点"></a>02.01. 移除重复节点</h3><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p><strong>提示：</strong></p>
<ol>
<li>链表长度在[0, 20000]范围内。</li>
<li>链表元素在[0, 20000]范围内。</li>
</ol>
<p><strong>进阶：</strong></p>
<p>如果不得使用临时缓冲区，该怎么解决？</p>
<p>方法：哈希表</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(head.val);</span><br><span class="line">        ListNode pre = head,cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur.val))&#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                cur.next = <span class="keyword">null</span>;</span><br><span class="line">                cur = pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(cur.val);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(n)</p>
<hr>
<h3 id="02-02-返回倒数第k个节点"><a href="#02-02-返回倒数第k个节点" class="headerlink" title="02.02. 返回倒数第k个节点"></a>02.02. 返回倒数第k个节点</h3><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<p><strong>说明：</strong></p>
<p>给定的 <em>k</em> 保证是有效的。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">//快指针先走K步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="02-03-删除中间节点"><a href="#02-03-删除中间节点" class="headerlink" title="02.03. 删除中间节点"></a>02.03. 删除中间节点</h3><p>若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。</p>
<p>假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。</p>
<p>例如，传入节点 c（位于单向链表 a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f 中），将其删除后，剩余链表为 a-&gt;b-&gt;d-&gt;e-&gt;f</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">//快指针先走K步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="02-04-分割链表"><a href="#02-04-分割链表" class="headerlink" title="02.04. 分割链表"></a>02.04. 分割链表</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你不需要 保留 每个分区中各节点的初始相对位置</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>-200 &lt;= x &lt;= 200</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode vrRoot1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>),vrRoot2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p1 = vrRoot1,cur = head,p2 = vrRoot2;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (cur.val &lt; x)&#123;</span><br><span class="line">                p1.next = cur;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p2.next = cur;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = vrRoot2.next;</span><br><span class="line">        <span class="keyword">return</span> vrRoot1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="02-05-链表求和"><a href="#02-05-链表求和" class="headerlink" title="02.05. 链表求和"></a>02.05. 链表求和</h3><p>给定两个用链表表示的整数，每个节点包含一个数位。</p>
<p>这些数位是反向存放的，也就是个位排在链表首部。</p>
<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>
<p><strong>进阶：</strong>思考一下，假设这些数位是正向存放的，又该如何解决呢?(栈)</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode p1 = l1,p2 = l2;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        ListNode vrHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>),cur = vrHead;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> || p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = p1 == <span class="keyword">null</span> ? <span class="number">0</span> : p1.val;</span><br><span class="line">            <span class="keyword">int</span> num2 = p2 == <span class="keyword">null</span> ? <span class="number">0</span> : p2.val;</span><br><span class="line">            <span class="keyword">int</span> value = (num1 + num2 + c) % <span class="number">10</span>;</span><br><span class="line">            c = (num1 + num2 + c) / <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (p1 != <span class="keyword">null</span>) p1 = p1.next;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) cur.next = <span class="keyword">new</span> ListNode(c);</span><br><span class="line">        <span class="keyword">return</span> vrHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n + m)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="02-06-回文链表"><a href="#02-06-回文链表" class="headerlink" title="02.06. 回文链表"></a>02.06. 回文链表</h3><p>编写一个函数，检查输入的链表是否是回文的。</p>
<p> <strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode slow = head,fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，slow为链表前半部分尾节点</span></span><br><span class="line">        ListNode node = reverseList(slow.next);</span><br><span class="line">        ListNode p1 = head,p2 = node;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverseList(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode nextNode = head.next;</span><br><span class="line">        ListNode newHead = reverseList(nextNode);</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        nextNode.next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="02-07-链表相交"><a href="#02-07-链表相交" class="headerlink" title="02.07. 链表相交"></a>02.07. 链表相交</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>提示：</p>
<p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>0 &lt;= m, n &lt;= 3 * 10^4<br>1 &lt;= Node.val &lt;= 10^5<br>0 &lt;= skipA &lt;= m<br>0 &lt;= skipB &lt;= n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]</p>
<p>进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p1 = headA, p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2)&#123;</span><br><span class="line">            p1 = p1 == <span class="keyword">null</span> ? headB : p1.next;</span><br><span class="line">            p2 = p2 == <span class="keyword">null</span> ? headA : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="02-08-环路检测"><a href="#02-08-环路检测" class="headerlink" title="02.08. 环路检测"></a>02.08. 环路检测</h3><p>给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。若环不存在，请返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你是否可以不用额外空间解决此题？</li>
</ul>
<p>哈希表或者快慢指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode vrHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        vrHead.next = head;</span><br><span class="line">        ListNode slow = vrHead.next,fast = vrHead.next.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = vrHead;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<hr>
<h3 id="02-03-三合一"><a href="#02-03-三合一" class="headerlink" title="02.03. 三合一"></a>02.03. 三合一</h3><p>三合一。描述如何只用一个数组来实现三个栈。</p>
<p>你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。</p>
<p>构造函数会传入一个stackSize参数，代表每个栈的大小。</p>
<p>当栈为空时<code>pop, peek</code>返回-1，当栈满时<code>push</code>不压入元素。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= stackNum &lt;= 2</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">int</span> stackSize;</span><br><span class="line">    <span class="keyword">int</span> x;<span class="comment">//数组下标x之后的空间用来记录插入位置</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//需要实现栈的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TripleInOne</span><span class="params">(<span class="keyword">int</span> stackSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">int</span>[stackSize * n + n];<span class="comment">//数组最后3个位置用来记录插入位置</span></span><br><span class="line">        <span class="comment">//初始化插入位置</span></span><br><span class="line">        <span class="keyword">this</span>.x = n * stackSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            data[x + i] = i * stackSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">if</span> (data[x + stackNum] &gt;= (stackNum + <span class="number">1</span>) * stackSize) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//数据插入位置</span></span><br><span class="line">        <span class="keyword">int</span> index = data[x + stackNum];</span><br><span class="line">        data[index] = value;</span><br><span class="line">        data[x + stackNum]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">if</span> (data[x + stackNum] &lt;= stackNum * stackSize) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//数据弹出位置</span></span><br><span class="line">        <span class="keyword">int</span> index = data[x + stackNum] - <span class="number">1</span>;</span><br><span class="line">        data[x + stackNum]--;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">if</span> (data[x + stackNum] &lt;= stackNum * stackSize) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//数据弹出位置</span></span><br><span class="line">        <span class="keyword">int</span> index = data[x + stackNum] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[x + stackNum] &lt;= stackNum * stackSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<p>时间复杂度:O(1)</p>
<p>空间复杂度:O(k*n),k 为我们需要实现的栈的个数</p>
<hr>
<h3 id="03-02-栈的最小值"><a href="#03-02-栈的最小值" class="headerlink" title="03.02. 栈的最小值"></a>03.02. 栈的最小值</h3><p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="03-03-堆盘子"><a href="#03-03-堆盘子" class="headerlink" title="03.03. 堆盘子"></a>03.03. 堆盘子</h3><p>堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。</p>
<p>当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1.</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfPlates</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Deque&lt;Integer&gt;&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackOfPlates</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.size = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty() || list.get(list.size() - <span class="number">1</span>).size() &gt;= size) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; newStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            newStack.push(val);</span><br><span class="line">            list.add(newStack);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.get(list.size() - <span class="number">1</span>).push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> popAt(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下表越界</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//指定位置的栈为空，返回-1；</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = list.get(index);</span><br><span class="line">        <span class="comment">/*if (stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">            return -1;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//指定位置栈不为空，弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> res = stack.pop();</span><br><span class="line">		<span class="comment">//弹出栈顶元素后，若栈为空，移除该位置的栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="03-04-化栈为队"><a href="#03-04-化栈为队" class="headerlink" title="03.04. 化栈为队"></a>03.04. 化栈为队</h3><p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p>
<p>说明：</p>
<p>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> outStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> outStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.isEmpty())&#123;</span><br><span class="line">            outStack.push(inStack.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="03-05-栈排序"><a href="#03-05-栈排序" class="headerlink" title="03.05. 栈排序"></a>03.05. 栈排序</h3><p>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。</p>
<p><strong>说明:</strong></p>
<ol>
<li>栈中的元素数目在[0, 5000]范围内。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stk1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SortedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk1.isEmpty() || val &lt; stk1.peek())&#123;</span><br><span class="line">            stk1.push(val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stk1.pop();</span><br><span class="line">            push(val);</span><br><span class="line">            stk1.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk1.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        stk1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> stk1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="03-06-动物收容所"><a href="#03-06-动物收容所" class="headerlink" title="03.06. 动物收容所"></a>03.06. 动物收容所</h3><p>动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。</p>
<p>enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。</p>
<p>dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。</p>
<p><strong>说明:</strong></p>
<ol>
<li>收纳所的最大容量为20000</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalShelf</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    LinkedList&lt;<span class="keyword">int</span>[]&gt; queueCat;</span><br><span class="line">    LinkedList&lt;<span class="keyword">int</span>[]&gt; queueDog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnimalShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queueCat = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queueDog = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span>[] animal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断种类后入队</span></span><br><span class="line">        <span class="keyword">if</span> (animal[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            queueCat.addLast(animal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal[<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            queueDog.addLast(animal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueAny() &#123;</span><br><span class="line">        <span class="comment">// 取出cat的队首，判空则直接返回</span></span><br><span class="line">        <span class="keyword">int</span>[] headCat;</span><br><span class="line">        <span class="keyword">if</span> (!queueCat.isEmpty()) &#123;</span><br><span class="line">            headCat = queueCat.getFirst();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!queueDog.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queueDog.removeFirst();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出dog的队首，判空则直接返回</span></span><br><span class="line">        <span class="keyword">int</span>[] headDog;</span><br><span class="line">        <span class="keyword">if</span> (!queueDog.isEmpty()) &#123;</span><br><span class="line">            headDog = queueDog.getFirst();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queueCat.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较后返回</span></span><br><span class="line">        <span class="keyword">if</span> (headCat[<span class="number">0</span>]&lt;=headDog[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> queueCat.removeFirst();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queueDog.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueDog() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!queueDog.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queueDog.removeFirst();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueCat() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!queueCat.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queueCat.removeFirst();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-01-节点间通路"><a href="#04-01-节点间通路" class="headerlink" title="04.01. 节点间通路"></a>04.01. 节点间通路</h3><p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>
<p><strong>提示：</strong></p>
<ol>
<li>节点数量n在[0, 1e5]范围内。</li>
<li>节点编号大于等于 0 小于 n。</li>
<li>图中可能存在自环和平行边。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Set&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            edges.put(i,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : graph) &#123;</span><br><span class="line">            edges.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        visited[start] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> poll = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            Set&lt;Integer&gt; edgeSet = edges.get(poll);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> point : edgeSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[point])&#123;</span><br><span class="line">                    queue.add(point);</span><br><span class="line">                    visited[point] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Set&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            edges.put(i,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : graph) &#123;</span><br><span class="line">            edges.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">return</span> dfs(start,target,edges,visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, Map&lt;Integer, Set&lt;Integer&gt;&gt; edges, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        visited[start] = <span class="keyword">true</span>;</span><br><span class="line">        Set&lt;Integer&gt; edgeSet = edges.get(start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> point : edgeSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[point]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[point] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = dfs(point, target, edges, visited);</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            visited[point] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-02-最小高度树"><a href="#04-02-最小高度树" class="headerlink" title="04.02. 最小高度树"></a>04.02. 最小高度树</h3><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = buildTree(nums,i,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(nums,mid + <span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-03-特定深度节点链表"><a href="#04-03-特定深度节点链表" class="headerlink" title="04.03. 特定深度节点链表"></a>04.03. 特定深度节点链表</h3><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] listOfDepth(TreeNode tree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ListNode[<span class="number">0</span>];</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(tree);</span><br><span class="line">        <span class="comment">//二叉树层序遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//每一层节点个数</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="comment">//二叉树每一层虚拟头节点</span></span><br><span class="line">            ListNode vrHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode cur = vrHead;</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode poll = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) queue.add(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) queue.add(poll.right);</span><br><span class="line">                cur.next = <span class="keyword">new</span> ListNode(poll.val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前层遍历完毕，将head加入list</span></span><br><span class="line">            list.add(vrHead.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> ListNode[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-04-检查平衡性"><a href="#04-04-检查平衡性" class="headerlink" title="04.04. 检查平衡性"></a>04.04. 检查平衡性</h3><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        highOfTree(root);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">highOfTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHigh = highOfTree(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHigh = highOfTree(root.right);</span><br><span class="line">        <span class="keyword">if</span> ( Math.abs(leftHigh - rightHigh) &gt; <span class="number">1</span>)</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHigh,rightHigh) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-05-合法搜索二叉树"><a href="#04-05-合法搜索二叉树" class="headerlink" title="04.05. 合法搜索二叉树"></a>04.05. 合法搜索二叉树</h3><p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>
<p>方法一：递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//右子树最左节点</span></span><br><span class="line">        TreeNode node1 = leftValueOfTree(root.right);</span><br><span class="line">        <span class="comment">//左子树最右节点</span></span><br><span class="line">        TreeNode node2 = rightValueOfTree(root.left);</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) <span class="keyword">return</span> isValidBST(root.right) &amp;&amp; node1.val &gt; root.val;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) <span class="keyword">return</span>  isValidBST(root.left) &amp;&amp; node2.val &lt; root.val;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right) &amp;&amp; node1.val &gt; root.val &amp;&amp;</span><br><span class="line">                isValidBST(root.left) &amp;&amp; node2.val &lt; root.val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求二叉树最左节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">leftValueOfTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求二叉树最右节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">rightValueOfTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：中序遍历（非递归写法）</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Integer x = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode pop = stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="keyword">null</span> || pop.val &gt; x)&#123;</span><br><span class="line">                    x = pop.val;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = pop.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-06-后继者"><a href="#04-06-后继者" class="headerlink" title="04.06. 后继者"></a>04.06. 后继者</h3><p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<p>如果指定节点没有对应的“下一个”节点，则返回<code>null</code>。</p>
<p>方法一：中序遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Integer x = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode pop = stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="keyword">null</span> || pop.val &gt; x)&#123;</span><br><span class="line">                    x = pop.val;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = pop.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：利用二叉搜索树有序的性质，类似二分查找法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">        TreeNode successor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果p有右子树，直接返回右子树的最左节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor = p.right;</span><br><span class="line">            <span class="keyword">while</span> (successor.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                successor = successor.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">     	</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前节点node的值大于p，则p的后继节点可能为node或者node的左子树中</span></span><br><span class="line">            <span class="keyword">if</span> (node.val &gt; p.val) &#123;</span><br><span class="line">                successor = node;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前节点node的值小于p，则p一定位于node的右子树中</span></span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-08-首个共同祖先"><a href="#04-08-首个共同祖先" class="headerlink" title="04.08. 首个共同祖先"></a>04.08. 首个共同祖先</h3><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>
<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><strong>说明:</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有节点的值都是唯一的。</span><br><span class="line"><span class="selector-tag">p</span>、<span class="selector-tag">q</span> 为不同节点且均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure>

<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//左右子树返回都不为空，说明p与q一个在左子树中，一个在右子树中，则共同祖先为root</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-09-二叉搜索树序列"><a href="#04-09-二叉搜索树序列" class="headerlink" title="04.09. 二叉搜索树序列"></a>04.09. 二叉搜索树序列</h3><p>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。</p>
<p>给定一个由<strong>不同节点</strong>组成的二叉搜索树 <code>root</code>，输出所有可能生成此树的数组。</p>
<p><strong>提示：</strong></p>
<ul>
<li>二叉搜索树中的节点数在 <code>[0, 1000]</code> 的范围内</li>
<li><code>1 &lt;= 节点值 &lt;= 10^6</code></li>
<li>用例保证符合要求的数组数量不超过 <code>5000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; BSTSequences(TreeNode root) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        bfs(queue);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(List&lt;TreeNode&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 queue 拷贝一份，用于稍后回溯</span></span><br><span class="line">        List&lt;TreeNode&gt; copy = <span class="keyword">new</span> ArrayList&lt;&gt;(queue);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queue.size(); i++) &#123;</span><br><span class="line">            TreeNode node = queue.get(i);</span><br><span class="line">            path.add(node.val);</span><br><span class="line">            queue.remove(i);</span><br><span class="line">            <span class="comment">// 将左右子节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            bfs(queue);</span><br><span class="line">            <span class="comment">//回溯，恢复 path 和 queue</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            queue = <span class="keyword">new</span> ArrayList&lt;&gt;(copy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-10-检查子树"><a href="#04-10-检查子树" class="headerlink" title="04.10. 检查子树"></a>04.10. 检查子树</h3><p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>
<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<p>注意：此题相对书上原题略有改动。</p>
<p><strong>提示：</strong></p>
<ol>
<li>树的节点数目范围为[0, 20000]。</li>
</ol>
<p>方法一：递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isSame(t1,t2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> checkSubTree(t1.left,t2) || checkSubTree(t1.right,t2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span> || root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(root1.left,root2.left) &amp;&amp; isSame(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：先序遍历转化成字符串匹配问题，再利用kMP算法判断s2是否是s1的子串</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        String s1 = preTravel(t1);</span><br><span class="line">        String s2 = preTravel(t2);</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(s2);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.length() &amp;&amp; j &lt; s2.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (next[j] == -<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == s2.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">preTravel</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        String leftStr = preTravel(root.left);</span><br><span class="line">        String rightStr = preTravel(root.right);</span><br><span class="line">        sb.append(leftStr);</span><br><span class="line">        sb.append(rightStr);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String str)&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">//next[i]表示0 ~ i-1之间的子串相等的前缀和后缀的最大长度</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[chars.length];</span><br><span class="line">        <span class="keyword">if</span> (chars.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>; <span class="comment">//下标0之前没有字符了，返回-1；</span></span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//下标1之前只有一个字符，且最长相等的前缀和后缀不包括本身，返回0；</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>, cn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; chars.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i - <span class="number">1</span>] == chars[cn])&#123;</span><br><span class="line">                next[i++] = ++cn;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cn = next[cn];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                next[i++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="04-12-求和路径"><a href="#04-12-求和路径" class="headerlink" title="04.12. 求和路径"></a>04.12. 求和路径</h3><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<p>提示：</p>
<ul>
<li><code>节点总数 &lt;= 10000</code></li>
</ul>
<p>方法一：递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isSame(t1,t2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> checkSubTree(t1.left,t2) || checkSubTree(t1.right,t2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span> || root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(root1.left,root2.left) &amp;&amp; isSame(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法一：前缀和</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashmap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        inTravel(root,hashmap,sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inTravel</span><span class="params">(TreeNode root, Map&lt;Integer, Integer&gt; hashmap, <span class="keyword">int</span> sum, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        cur += root.val;</span><br><span class="line">        cnt += hashmap.getOrDefault(cur - sum,<span class="number">0</span>);</span><br><span class="line">        hashmap.put(cur,hashmap.getOrDefault(cur,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        inTravel(root.left,hashmap,sum,cur);</span><br><span class="line">        inTravel(root.right,hashmap,sum,cur);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        hashmap.put(cur,hashmap.get(cur) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="05-01-插入"><a href="#05-01-插入" class="headerlink" title="05.01. 插入"></a>05.01. 插入</h3><p>给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i &lt;= j，且从 0 位开始计算）。</p>
<p>编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。</p>
<p>题目保证从 <code>i</code> 位到 <code>j</code> 位足以容纳 <code>M</code>， 例如： <code>M = 10011</code>，则 <code>i～j</code> 区域至少可容纳 5 位。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//left in (,j+1];middle in [i,j];right in [i-1,0];</span></span><br><span class="line">        <span class="keyword">int</span> left = N&gt;&gt;j&gt;&gt;<span class="number">1</span>; <span class="comment">//把最左边的部分调整好了，即抛弃了替换部分和低位部分</span></span><br><span class="line">        left = left&lt;&lt;j&lt;&lt;<span class="number">1</span>;  <span class="comment">//因此最后要进行或运算，所以把他再移到原来的高位上。</span></span><br><span class="line">        <span class="keyword">int</span> middle = M&lt;&lt;i;  <span class="comment">//替换N的j&lt;-----i位，那么只需要将M左移i位即可</span></span><br><span class="line">        <span class="keyword">int</span> right = N&amp;((<span class="number">1</span>&lt;&lt;i)-<span class="number">1</span>);<span class="comment">//只需要N的低位，将高位置零,(1&lt;&lt;2)-1 = (11)2</span></span><br><span class="line">        <span class="keyword">return</span> left | middle | right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="05-02-二进制数转字符串"><a href="#05-02-二进制数转字符串" class="headerlink" title="05.02. 二进制数转字符串"></a>05.02. 二进制数转字符串</h3><div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            num *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                num -= <span class="number">1</span>;</span><br><span class="line">                sb.append(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">32</span>) <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="05-03-翻转数位"><a href="#05-03-翻转数位" class="headerlink" title="05.03. 翻转数位"></a>05.03. 翻转数位</h3><p>给定一个32位整数 <code>num</code>，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>,cur = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            res = Math.max(res,pre + cur + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt; <span class="number">32</span> ? <span class="number">32</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="05-04-下一个数"><a href="#05-04-下一个数" class="headerlink" title="05.04. 下一个数"></a>05.04. 下一个数</h3><p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>
<p><strong>提示:</strong></p>
<ol>
<li><code>num</code>的范围在[1, 2147483647]之间；</li>
<li>如果找不到前一个或者后一个满足条件的正数，那么输出 -1。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findClosedNumbers(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res =  <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;=<span class="number">0</span> || num&gt;=Integer.MAX_VALUE) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[<span class="number">0</span>] = getNext(num);</span><br><span class="line">            res[<span class="number">1</span>] = getPrev(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取得后一个较大的数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算c0和c1，用于找到最右边非拖尾0的下标p</span></span><br><span class="line">        <span class="keyword">int</span> c = n;</span><br><span class="line">        <span class="keyword">int</span> c0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (((c&amp;<span class="number">1</span>)==<span class="number">0</span>)&amp;&amp;(c!=<span class="number">0</span>)) &#123;</span><br><span class="line">            c0++;</span><br><span class="line">            c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((c&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">            c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 错误：若n=111111...000, 那么就没有更大的数字</span></span><br><span class="line">        <span class="comment">// 如果是n的二进制不存在可翻转的0，或者n就是0</span></span><br><span class="line">        <span class="keyword">if</span> (c0 + c1 == <span class="number">31</span> || c0 +c1 ==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p = c0+c1; <span class="comment">// 前提：最右边，非拖尾0的位置</span></span><br><span class="line">        n |= (<span class="number">1</span>&lt;&lt;p); <span class="comment">// 步骤1：翻转最右边，非拖尾0</span></span><br><span class="line">        n &amp;= ~((<span class="number">1</span>&lt;&lt;p)-<span class="number">1</span>); <span class="comment">// 步骤2：将p右方的所有位清零</span></span><br><span class="line">        n |= (<span class="number">1</span>&lt;&lt;(c1-<span class="number">1</span>))-<span class="number">1</span>; <span class="comment">// 步骤3：在右方插入(c1-1)个1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取得前一个较小的数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPrev</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = n;</span><br><span class="line">        <span class="keyword">int</span> c0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">            c1++;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (((temp &amp;<span class="number">1</span>)==<span class="number">0</span>) &amp;&amp;(temp!=<span class="number">0</span>)) &#123;</span><br><span class="line">            c0++;</span><br><span class="line">            temp &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p = c0+c1; <span class="comment">// 最右边，非拖尾1的位置</span></span><br><span class="line">        n &amp;= ((~<span class="number">0</span>)&lt;&lt;(p+<span class="number">1</span>)); <span class="comment">// 将位0到位p清零</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span>&lt;&lt;(c1+<span class="number">1</span>)) -<span class="number">1</span>; <span class="comment">// (c1+1)个1</span></span><br><span class="line">        n |= mask &lt;&lt; (c0-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="05-06-整数转换"><a href="#05-06-整数转换" class="headerlink" title="05.06. 整数转换"></a>05.06. 整数转换</h3><p>整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。</p>
<p><strong>提示:</strong></p>
<ol>
<li>A，B范围在[-2147483648, 2147483647]之间</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">convertInteger</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((A &amp; <span class="number">1</span>) != (B &amp; <span class="number">1</span>)) res++;</span><br><span class="line">            A &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="05-07-配对交换"><a href="#05-07-配对交换" class="headerlink" title="05.07. 配对交换"></a>05.07. 配对交换</h3><p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>
<p><strong>提示:</strong></p>
<ol>
<li><code>num</code>的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//奇数</span></span><br><span class="line">        <span class="keyword">int</span> odd = num &amp; <span class="number">0x55555555</span>;</span><br><span class="line">        <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">int</span> even = num &amp; <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">        odd = odd &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        even = even &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> odd | even;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="05-08-绘制直线"><a href="#05-08-绘制直线" class="headerlink" title="05.08. 绘制直线"></a>05.08. 绘制直线</h3><p>已知一个由像素点组成的单色屏幕，每行均有 w 个像素点，所有像素点初始为 0，左上角位置为 (0,0)。</p>
<p>现将每行的像素点按照「每 32 个像素点」为一组存放在一个 int 中，再依次存入长度为 length 的一维数组中。</p>
<p>我们将在屏幕上绘制一条从点 (x1,y) 到点 (x2,y) 的直线（即像素点修改为 1），请返回绘制过后的数组。</p>
<p><strong>注意：</strong></p>
<ul>
<li>用例保证屏幕宽度 <code>w</code> 可被 32 整除（即一个 <code>int</code> 不会分布在两行上）</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] drawLine(<span class="keyword">int</span> length, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y) &#123;  </span><br><span class="line">        <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> low=(y*w+x1)/<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> high=(y*w+x2)/<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=high;i++)&#123;</span><br><span class="line">            ans[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[low]=ans[low]&gt;&gt;&gt;x1%<span class="number">32</span>;</span><br><span class="line">        ans[high]=ans[high]&amp;Integer.MIN_VALUE&gt;&gt; x2 % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-01-三步问题"><a href="#08-01-三步问题" class="headerlink" title="08.01. 三步问题"></a>08.01. 三步问题</h3><p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>
<p><strong>提示:</strong></p>
<ol>
<li>n范围在[1, 1000000]之间</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + (dp[i - <span class="number">2</span>] + dp[i - <span class="number">3</span>]) % <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-02-迷路的机器人"><a href="#08-02-迷路的机器人" class="headerlink" title="08.02. 迷路的机器人"></a>08.02. 迷路的机器人</h3><p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。</p>
<p>说明：r 和 <em>c</em> 的值均不超过 100。</p>
<p>方法一：dfs + 回溯</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(<span class="keyword">int</span>[][] obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res,<span class="number">0</span>, <span class="number">0</span>, visited,obstacleGrid);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span> <span class="params">(List&lt;List&lt;Integer&gt;&gt; res,<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = visited.length, n = visited[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= m || y &gt;= n || visited[x][y] || obstacleGrid[x][y] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        res.add(Arrays.asList(x,y));</span><br><span class="line">        <span class="keyword">if</span> (x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dfs(res,x + <span class="number">1</span>,y,visited,obstacleGrid) || dfs(res,x,y + <span class="number">1</span>,visited,obstacleGrid))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：动态规划</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(<span class="keyword">int</span>[][] obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//初始化dp矩阵</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = obstacleGrid[i][j] == <span class="number">0</span> &amp;&amp; (dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不可达</span></span><br><span class="line">        <span class="keyword">if</span> (!dp[m - <span class="number">1</span>][n - <span class="number">1</span>]) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//可达，倒序搜寻路径</span></span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(Arrays.asList(i,j));</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入起点</span></span><br><span class="line">        res.add(Arrays.asList(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-03-魔术索引"><a href="#08-03-魔术索引" class="headerlink" title="08.03. 魔术索引"></a>08.03. 魔术索引</h3><p>魔术索引。 在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>
<p><strong>说明:</strong></p>
<ol>
<li>nums长度在[1, 1000000]之间</li>
<li>此题为原书中的 Follow-up，即数组中可能包含重复元素的版本</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-04-幂集"><a href="#08-04-幂集" class="headerlink" title="08.04. 幂集"></a>08.04. 幂集</h3><p>幂集。编写一种方法，返回某集合的所有子集。集合中<strong>不包含重复的元素</strong>。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>方法一：dfs</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums,res,path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index]);</span><br><span class="line">        dfs(nums,res,path,index + <span class="number">1</span>);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        dfs(nums,res,path,index + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//另一种写法</span></span><br><span class="line">        <span class="comment">/*for (int i = index; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            path.add(nums[i]);</span></span><br><span class="line"><span class="comment">            dfs(nums,res,path,index + 1);</span></span><br><span class="line"><span class="comment">            path.remove(path.size() - 1);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：位运算</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//子集的长度是2的nums.length次方，这里通过移位计算</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">        <span class="comment">//遍历从0到length中间的所有数字，根据数字中1的位置来找子集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果数字i的某一个位置是1，就把数组中对</span></span><br><span class="line">                <span class="comment">//应的数字添加到集合</span></span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                    list.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-05-递归乘法"><a href="#08-05-递归乘法" class="headerlink" title="08.05. 递归乘法"></a>08.05. 递归乘法</h3><p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<p><strong>提示:</strong></p>
<ol>
<li>保证乘法范围不会溢出</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(A, B);</span><br><span class="line">        <span class="keyword">int</span> max = Math.max(A, B);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; min != <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((min &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += max &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">            min &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-06-汉诺塔问题"><a href="#08-06-汉诺塔问题" class="headerlink" title="08.06. 汉诺塔问题"></a>08.06. 汉诺塔问题</h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p>你需要原地修改栈。</p>
<p><strong>提示:</strong></p>
<ol>
<li>A中盘子的数目不大于14个。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        move(n,A,B,C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(<span class="number">0</span>,A.remove(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move(n - <span class="number">1</span>,A,C,B);</span><br><span class="line">        C.add(<span class="number">0</span>,A.remove(<span class="number">0</span>));</span><br><span class="line">        move(n - <span class="number">1</span>,B,A,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-07-无重复字符串的排列组合"><a href="#08-07-无重复字符串的排列组合" class="headerlink" title="08.07. 无重复字符串的排列组合"></a>08.07. 无重复字符串的排列组合</h3><p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p>
<p><strong>提示:</strong></p>
<ol>
<li>字符都是英文字母。</li>
<li>字符串长度在[1, 9]之间。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[S.length()];</span><br><span class="line">        dfs(chars,lists,path,visited);</span><br><span class="line">        <span class="keyword">return</span> lists.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] chars, List&lt;String&gt; lists, StringBuilder path, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.length() == chars.length)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> String(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="comment">//chars[i]已经添加，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.append(chars[i]);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(chars,lists,path,visited);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-08-有重复字符串的排列组合"><a href="#08-08-有重复字符串的排列组合" class="headerlink" title="08.08. 有重复字符串的排列组合"></a>08.08. 有重复字符串的排列组合</h3><p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>
<p><strong>提示:</strong></p>
<ol>
<li>字符都是英文字母。</li>
<li>字符串长度在[1, 9]之间。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String S) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[S.length()];</span><br><span class="line">        dfs(chars,lists,path,visited);</span><br><span class="line">        <span class="keyword">return</span> lists.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] chars, List&lt;String&gt; lists, StringBuilder path, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.length() == chars.length)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> String(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//剪枝去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; chars[i] == chars[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.append(chars[i]);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(chars,lists,path,visited);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-09-括号"><a href="#08-09-括号" class="headerlink" title="08.09.  括号"></a>08.09.  括号</h3><p>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。</p>
<p>说明：解集不能包含重复的子集。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(res,path,n,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, StringBuilder path, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b || a &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        dfs(res,path,a - <span class="number">1</span>,b);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        path.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        dfs(res,path,a,b - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-10-颜色填充"><a href="#08-10-颜色填充" class="headerlink" title="08.10. 颜色填充"></a>08.10. 颜色填充</h3><p>编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>
<p>待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的行坐标为 sr 列坐标为 sc。需要填充的新颜色为 newColor 。</p>
<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>
<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>
<p>提示：</p>
<p>image 和 image[0] 的长度均在范围 [1, 50] 内。<br>初始坐标点 (sr,sc) 满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length 。<br>image[i] [j] 和 newColor 表示的颜色值在范围 [0, 65535] 内。</p>
<p>方法一：bfs</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newColor == image[sr][sc]) <span class="keyword">return</span> image;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = image.length, n = image[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr,sc&#125;);</span><br><span class="line">        <span class="keyword">int</span> oldColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] poll = queue.poll();</span><br><span class="line">            image[poll[<span class="number">0</span>]][poll[<span class="number">1</span>]] = newColor;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = poll[<span class="number">0</span>] + dir[<span class="number">0</span>],y = poll[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; image[x][y] == oldColor)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：dfs</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="comment">//新值和旧值相等就没必要涂了</span></span><br><span class="line">        <span class="keyword">if</span>(newColor == image[sr][sc])&#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(image, sr, sc, newColor, image[sr][sc]);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> oldColor)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界或者这个点不能涂就返回</span></span><br><span class="line">        <span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt;= image.length || sc &lt; <span class="number">0</span> || sc &gt;= image[sr].length || image[sr][sc] != oldColor)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//涂色+四个方向扩散</span></span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        dfs(image, sr - <span class="number">1</span>, sc, newColor, oldColor);</span><br><span class="line">        dfs(image, sr + <span class="number">1</span>, sc, newColor, oldColor);</span><br><span class="line">        dfs(image, sr , sc - <span class="number">1</span>, newColor, oldColor);</span><br><span class="line">        dfs(image, sr , sc + <span class="number">1</span>, newColor, oldColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-11-硬币"><a href="#08-11-硬币" class="headerlink" title="08.11. 硬币"></a>08.11. 硬币</h3><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<p><strong>说明：</strong></p>
<p>注意:</p>
<p>你可以假设：</p>
<ul>
<li>0 &lt;= n (总金额) &lt;= 1000000</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-12-八皇后"><a href="#08-12-八皇后" class="headerlink" title="08.12. 八皇后"></a>08.12. 八皇后</h3><p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>
<p>注意：本题相对原题做了扩展</p>
<p>方法一：基于集合的回溯</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三个set记录当前那些列不能选，set1记录当前列，set2记录右下角，set3记录左下角</span></span><br><span class="line">    Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; set3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//queens[i]表示在第i行的第queens[i]列放置皇后</span></span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(queens,-<span class="number">1</span>);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res,queens,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == queens.length)&#123;</span><br><span class="line">            List&lt;String&gt; ways = generateResults(queens);</span><br><span class="line">            res.add(ways);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queens.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = row - i, b = row + i;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i) || set2.contains(a) || set3.contains(b)) <span class="keyword">continue</span>;</span><br><span class="line">            queens[row] = i;</span><br><span class="line">            set1.add(i);</span><br><span class="line">            set2.add(row - i);</span><br><span class="line">            set3.add(row + i);</span><br><span class="line">            dfs(res,queens,row + <span class="number">1</span>);</span><br><span class="line">            queens[row] = -<span class="number">1</span>;</span><br><span class="line">            set1.remove(i);</span><br><span class="line">            set2.remove(row - i);</span><br><span class="line">            set3.remove(row + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据queens生成相应的皇后放置方案</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">generateResults</span><span class="params">(<span class="keyword">int</span>[] queens)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = queens.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(chars,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            chars[queens[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            answer.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：基于位运算的回溯</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//queens[i]表示在第i行的第queens[i]列放置皇后</span></span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(queens,-<span class="number">1</span>);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res,queens,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> row,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == queens.length)&#123;</span><br><span class="line">            List&lt;String&gt; ways = generateResults(queens);</span><br><span class="line">            res.add(ways);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> available = ((<span class="number">1</span> &lt;&lt; queens.length) - <span class="number">1</span>) &amp; (~(a | b | c));</span><br><span class="line">        <span class="keyword">while</span> (available != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> position = available &amp; (-available);<span class="comment">//计算最低位的1</span></span><br><span class="line">            available = available &amp; (available - <span class="number">1</span>);<span class="comment">//将最低位的1变为0</span></span><br><span class="line">            <span class="keyword">int</span> column = Integer.bitCount(position - <span class="number">1</span>);<span class="comment">//计算二进制下1的个数</span></span><br><span class="line">            queens[row] = column;</span><br><span class="line">            dfs(res,queens,row + <span class="number">1</span>,a | position,(b | position) &lt;&lt; <span class="number">1</span>,(c | position) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            queens[row] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据queens生成相应的皇后放置方案</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">generateResults</span><span class="params">(<span class="keyword">int</span>[] queens)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = queens.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(chars,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            chars[queens[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            answer.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-13-堆箱子"><a href="#08-13-堆箱子" class="headerlink" title="08.13. 堆箱子"></a>08.13. 堆箱子</h3><p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。</p>
<p>输入使用数组[wi, di, hi]表示每个箱子。</p>
<p><strong>提示:</strong></p>
<ol>
<li>箱子的数目不大于3000个。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (box.length == <span class="number">0</span> || box[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(box, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[box.length];</span><br><span class="line">        dp[<span class="number">0</span>] = box[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; box.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// i 的三维都要比 j 大，在 0 &lt;= j &lt; i 范围内找到最大的 dp[j]</span></span><br><span class="line">                <span class="keyword">if</span>(box[i][<span class="number">0</span>] &gt; box[j][<span class="number">0</span>] &amp;&amp; box[i][<span class="number">1</span>] &gt; box[j][<span class="number">1</span>] &amp;&amp; box[i][<span class="number">2</span>] &gt; box[j][<span class="number">2</span>])&#123;</span><br><span class="line">                    max = Math.max(max,dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后加上最底端箱子的高度</span></span><br><span class="line">            dp[i] = max + box[i][<span class="number">2</span>];</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="08-14-布尔运算"><a href="#08-14-布尔运算" class="headerlink" title="08.14. 布尔运算"></a>08.14. 布尔运算</h3><p>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。</p>
<p><strong>提示：</strong></p>
<ul>
<li>运算符的数量不超过 19 个</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Integer[][][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countEval</span><span class="params">(String s, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        memo = <span class="keyword">new</span> Integer[n][n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n - <span class="number">1</span>, s, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, String s, <span class="keyword">int</span> result)</span> </span>&#123; <span class="comment">//区间[l, r]求result的括号方案数</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> (s.charAt(l) - <span class="string">&#x27;0&#x27;</span>) == result ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[l][r][result] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[l][r][result];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;&amp;&#x27;</span>) ans += dfs(l, i - <span class="number">1</span>, s, <span class="number">0</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">0</span>) + dfs(l, i - <span class="number">1</span>, s, <span class="number">0</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">1</span>) + dfs(l, i - <span class="number">1</span>, s, <span class="number">1</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">0</span>); <span class="comment">//00、01、10</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;|&#x27;</span>) ans += dfs(l, i - <span class="number">1</span>, s, <span class="number">0</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">0</span>); <span class="comment">//00</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>) ans += dfs(l, i - <span class="number">1</span>, s, <span class="number">0</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">0</span>) + dfs(l, i - <span class="number">1</span>, s, <span class="number">1</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">1</span>); <span class="comment">//00、11</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;&amp;&#x27;</span>) ans += dfs(l, i - <span class="number">1</span>, s, <span class="number">1</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">1</span>); <span class="comment">//11</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;|&#x27;</span>) ans += dfs(l, i - <span class="number">1</span>, s, <span class="number">0</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">1</span>) + dfs(l, i - <span class="number">1</span>, s, <span class="number">1</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">0</span>) + dfs(l, i - <span class="number">1</span>, s, <span class="number">1</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">1</span>); <span class="comment">//01、10、11</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>) ans += dfs(l, i - <span class="number">1</span>, s, <span class="number">0</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">1</span>) + dfs(l, i - <span class="number">1</span>, s, <span class="number">1</span>) * dfs(i + <span class="number">1</span>, r, s, <span class="number">0</span>); <span class="comment">//10、01</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[l][r][result] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="10-01-合并排序的数组"><a href="#10-01-合并排序的数组" class="headerlink" title="10.01. 合并排序的数组"></a>10.01. 合并排序的数组</h3><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>A.length == n + m</code></li>
</ul>
<p>方法：逆向双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pa = m - <span class="number">1</span>, pb = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (pa &gt;= <span class="number">0</span> || pb &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa == -<span class="number">1</span>) &#123;</span><br><span class="line">                cur = B[pb--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pb == -<span class="number">1</span>) &#123;</span><br><span class="line">                cur = A[pa--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[pa] &gt; B[pb]) &#123;</span><br><span class="line">                cur = A[pa--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = B[pb--];</span><br><span class="line">            &#125;</span><br><span class="line">            A[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="10-02-变位词组"><a href="#10-02-变位词组" class="headerlink" title="10.02. 变位词组"></a>10.02. 变位词组</h3><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>
<p><strong>注意：</strong>本题相对原题稍作修改</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">                count[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append((<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                    sb.append(count[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String key = sb.toString();</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="10-03-搜索旋转数组"><a href="#10-03-搜索旋转数组" class="headerlink" title="10.03. 搜索旋转数组"></a>10.03. 搜索旋转数组</h3><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>
<p><strong>提示:</strong></p>
<ol>
<li>arr 长度范围在[1, 1000000]之间</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length -<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">//当left符合时直接返回, 因为找的是最小的索引</span></span><br><span class="line">            <span class="keyword">if</span>(arr[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[right])&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; target &amp;&amp; arr[left] &lt;= target)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    left= mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; arr[right])&#123;<span class="comment">//右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &lt; target &amp;&amp; arr[right] &gt;= target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="10-05-稀疏数组搜索"><a href="#10-05-稀疏数组搜索" class="headerlink" title="10.05. 稀疏数组搜索"></a>10.05. 稀疏数组搜索</h3><p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = words.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; words[left].equals(<span class="string">&quot;&quot;</span>)) left++;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; words[right].equals(<span class="string">&quot;&quot;</span>)) right--;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//mid为空时，左移或者右移</span></span><br><span class="line">            <span class="keyword">while</span> (mid &lt;= right &amp;&amp; words[mid].equals(<span class="string">&quot;&quot;</span>)) mid++;</span><br><span class="line">            <span class="comment">//while (mid &gt;= left &amp;&amp; words[mid].equals(&quot;&quot;)) mid--;</span></span><br><span class="line">            <span class="keyword">if</span> (words[mid].equals(s)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (words[mid].compareTo(s) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="10-09-排序矩阵查找"><a href="#10-09-排序矩阵查找" class="headerlink" title="10.09. 排序矩阵查找"></a>10.09. 排序矩阵查找</h3><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = words.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; words[left].equals(<span class="string">&quot;&quot;</span>)) left++;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; words[right].equals(<span class="string">&quot;&quot;</span>)) right--;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//mid为空时，左移或者右移</span></span><br><span class="line">            <span class="keyword">while</span> (mid &lt;= right &amp;&amp; words[mid].equals(<span class="string">&quot;&quot;</span>)) mid++;</span><br><span class="line">            <span class="comment">//while (mid &gt;= left &amp;&amp; words[mid].equals(&quot;&quot;)) mid--;</span></span><br><span class="line">            <span class="keyword">if</span> (words[mid].equals(s)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (words[mid].compareTo(s) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="10-10-数字流的秩"><a href="#10-10-数字流的秩" class="headerlink" title="10.10 数字流的秩"></a>10.10 数字流的秩</h3><p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p>
<p>实现 track(int x) 方法，每读入一个数字都会调用该方法；</p>
<p>实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。</p>
<p>注意：本题相对原题稍作改动</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= x &lt;= 50000</code></li>
<li><code>track</code> 和 <code>getRankOfNumber</code> 方法的调用次数均不超过 2000 次</li>
</ul>
<p>方法一：插入排序+二分查找</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamRank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StreamRank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index = getRankOfNumber(x);</span><br><span class="line">            list.add(index,x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找第一个大于x的下标</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRankOfNumber</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>,right = list.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (list.get(mid) &lt;= x) &#123;</span><br><span class="line">                    left  = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：树状数组</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamRank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ints;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamRank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50002</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求x最低位的1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; ints.length; i += lowbit(i)) &#123;</span><br><span class="line">            ints[i] += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//区间查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">            ans += ints[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        add(x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRankOfNumber</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="10-11-峰与谷"><a href="#10-11-峰与谷" class="headerlink" title="10.11. 峰与谷"></a>10.11. 峰与谷</h3><p>在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums.length &lt;= 10000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, i, i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, i, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-01-交换数字"><a href="#16-01-交换数字" class="headerlink" title="16.01. 交换数字"></a>16.01. 交换数字</h3><p>编写一个函数，不用临时变量，直接交换<code>numbers = [a, b]</code>中<code>a</code>与<code>b</code>的值。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>numbers.length == 2</code></li>
<li><code>-2147483647 &lt;= numbers[i] &lt;= 2147483647</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, i, i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, i, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-02-单词频率"><a href="#16-02-单词频率" class="headerlink" title="16.02. 单词频率"></a>16.02. 单词频率</h3><p>设计一个方法，找出任意指定单词在一本书中的出现频率。</p>
<p>你的实现应该支持如下操作：</p>
<p>WordsFrequency(book)构造函数，参数为字符串数组构成的一本书<br>get(word)查询指定单词在书中出现的频率</p>
<p>提示：</p>
<p>book[i]中只包含小写字母<br>1 &lt;= book.length &lt;= 100000<br>1 &lt;= book[i].length &lt;= 10<br>get函数的调用次数不会超过100000</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordsFrequency</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordsFrequency</span><span class="params">(String[] book)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : book) &#123;</span><br><span class="line">            map.put(str,map.getOrDefault(str,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(word,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-03-交点"><a href="#16-03-交点" class="headerlink" title="16.03. 交点"></a>16.03. 交点</h3><p>给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。</p>
<p>要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>
<p><strong>提示：</strong></p>
<ul>
<li>坐标绝对值不会超过 2^7</li>
<li>输入的坐标均是有效的二维坐标</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] intersection(<span class="keyword">int</span>[] start1, <span class="keyword">int</span>[] end1, <span class="keyword">int</span>[] start2, <span class="keyword">int</span>[] end2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = start1[<span class="number">0</span>], y1 = start1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x2 = end1[<span class="number">0</span>], y2 = end1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x3 = start2[<span class="number">0</span>], y3 = start2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x4 = end2[<span class="number">0</span>], y4 = end2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y4) 是否平行</span></span><br><span class="line">        <span class="keyword">if</span> ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) &#123;</span><br><span class="line">            <span class="comment">// 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">            <span class="keyword">if</span> ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) &#123;</span><br><span class="line">                <span class="comment">// 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x3, y3)) &#123;</span><br><span class="line">                    update(x3, y3);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x1, y1, x2, y2, x4, y4)) &#123;</span><br><span class="line">                    update(x4, y4);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x1, y1)) &#123;</span><br><span class="line">                    update(x1, y1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">                <span class="keyword">if</span> (inside(x3, y3, x4, y4, x2, y2)) &#123;</span><br><span class="line">                    update(x2, y2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在平行时，其余的所有情况都不会有交点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 联立方程得到 t1 和 t2 的值</span></span><br><span class="line">            <span class="keyword">double</span> t1 = (<span class="keyword">double</span>) (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));</span><br><span class="line">            <span class="keyword">double</span> t2 = (<span class="keyword">double</span>) (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));</span><br><span class="line">            <span class="comment">// 判断 t1 和 t2 是否均在 [0, 1] 之间</span></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt;= <span class="number">0.0</span> &amp;&amp; t1 &lt;= <span class="number">1.0</span> &amp;&amp; t2 &gt;= <span class="number">0.0</span> &amp;&amp; t2 &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="comment">// 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inside</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> xk, <span class="keyword">int</span> yk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若与 x 轴平行，只需要判断 x 的部分</span></span><br><span class="line">        <span class="comment">// 若与 y 轴平行，只需要判断 y 的部分</span></span><br><span class="line">        <span class="comment">// 若为普通线段，则都要判断</span></span><br><span class="line">        <span class="keyword">return</span> (x1 == x2 || (Math.min(x1, x2) &lt;= xk &amp;&amp; xk &lt;= Math.max(x1, x2))) &amp;&amp; (y1 == y2 || (Math.min(y1, y2) &lt;= yk &amp;&amp; yk &lt;= Math.max(y1, y2)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> xk, <span class="keyword">double</span> yk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将一个交点与当前 ans 中的结果进行比较</span></span><br><span class="line">        <span class="comment">// 若更优则替换</span></span><br><span class="line">        <span class="keyword">if</span> (ans.length == <span class="number">0</span> || xk &lt; ans[<span class="number">0</span>] || (xk == ans[<span class="number">0</span>] &amp;&amp; yk &lt; ans[<span class="number">1</span>])) &#123;</span><br><span class="line">            ans = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xk, yk&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-04-井字游戏"><a href="#16-04-井字游戏" class="headerlink" title="16.04. 井字游戏"></a>16.04. 井字游戏</h3><p>设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符” “，”X”和”O”组成，其中字符” “代表一个空位。</p>
<p>以下是井字游戏的规则：</p>
<p>玩家轮流将字符放入空位（” “）中。<br>第一个玩家总是放字符”O”，且第二个玩家总是放字符”X”。<br>“X”和”O”只允许放置在空位中，不允许对已放有字符的位置进行填充。<br>当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。<br>当所有位置非空时，也算为游戏结束。<br>如果游戏结束，玩家不允许再放置字符。<br>如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（”X”或”O”）；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= board.length == board[i].length &lt;= 100</code></li>
<li>输入一定遵循井字棋规则</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tictactoe</span><span class="params">(String[] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左斜线</span></span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//右斜线</span></span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//横向</span></span><br><span class="line">            <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//纵向</span></span><br><span class="line">            <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i].charAt(j) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (board[i].charAt(j) == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                    row[<span class="number">0</span>]++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (board[i].charAt(j) == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    row[<span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[j].charAt(i) == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                    col[<span class="number">0</span>]++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (board[j].charAt(i) == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    col[<span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (row[<span class="number">0</span>] == n || col[<span class="number">0</span>] == n) <span class="keyword">return</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (row[<span class="number">1</span>] == n || col[<span class="number">1</span>] == n) <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[i].charAt(i) == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                left[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (board[i].charAt(i) == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                left[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i].charAt(n - <span class="number">1</span> - i) == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                right[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (board[i].charAt(n - <span class="number">1</span> - i) == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                right[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == n || right[<span class="number">0</span>] == n) <span class="keyword">return</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">1</span>] == n || right[<span class="number">1</span>] == n) <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="string">&quot;Draw&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-05-阶乘尾数"><a href="#16-05-阶乘尾数" class="headerlink" title="16.05. 阶乘尾数"></a>16.05. 阶乘尾数</h3><p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<p><strong>说明:</strong> 你算法的时间复杂度应为 <em>O</em>(log <em>n</em>) 。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-06-最小差"><a href="#16-06-最小差" class="headerlink" title="16.06. 最小差"></a>16.06. 最小差</h3><p>给定两个整数数组<code>a</code>和<code>b</code>，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差</p>
<p>提示：</p>
<p>1 &lt;= a.length, b.length &lt;= 100000<br>-2147483648 &lt;= a[i], b[i] &lt;= 2147483647<br>正确结果在区间 [0, 2147483647] 内</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        Arrays.sort(b);</span><br><span class="line">        <span class="keyword">int</span> len1 = a.length, len2 = b.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = Math.abs((<span class="keyword">long</span>)a[<span class="number">0</span>] - (<span class="keyword">long</span>)b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = Math.min(res,Math.abs((<span class="keyword">long</span>)a[i] - (<span class="keyword">long</span>)b[j]));</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-07-最大数值"><a href="#16-07-最大数值" class="headerlink" title="16.07. 最大数值"></a>16.07. 最大数值</h3><p>编写一个方法，找出两个数字<code>a</code>和<code>b</code>中最大的那一个。不得使用if-else或其他比较运算符。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a &gt;&gt; <span class="number">31</span>, y = b &gt;&gt; <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="comment">//同号，不会溢出</span></span><br><span class="line">        <span class="keyword">if</span> (x == y)&#123;</span><br><span class="line">            k = <span class="number">1</span> + ((a - b) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//异号，k取值与a的符号位相反</span></span><br><span class="line">            k = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-08-整数的英语表示"><a href="#16-08-整数的英语表示" class="headerlink" title="16.08. 整数的英语表示"></a>16.08. 整数的英语表示</h3><p>给定一个整数，打印该整数的英文描述。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String[] singles = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>&#125;;</span><br><span class="line">    String[] teens = &#123;<span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    String[] tens = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    String[] thousands = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;Thousand&quot;</span>, <span class="string">&quot;Million&quot;</span>, <span class="string">&quot;Billion&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>, unit = <span class="number">1000000000</span>; i &gt;= <span class="number">0</span>; i--, unit /= <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> curNum = num / unit;</span><br><span class="line">            <span class="keyword">if</span> (curNum != <span class="number">0</span>) &#123;</span><br><span class="line">                num -= curNum * unit;</span><br><span class="line">                StringBuffer curr = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                recursion(curr, curNum);</span><br><span class="line">                curr.append(thousands[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                sb.append(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(StringBuffer curr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            curr.append(singles[num]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            curr.append(teens[num - <span class="number">10</span>]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            curr.append(tens[num / <span class="number">10</span>]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            recursion(curr, num % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.append(singles[num / <span class="number">100</span>]).append(<span class="string">&quot; Hundred &quot;</span>);</span><br><span class="line">            recursion(curr, num % <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-09-运算"><a href="#16-09-运算" class="headerlink" title="16.09. 运算"></a>16.09. 运算</h3><p>请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。</p>
<p>你的实现应该支持如下操作：</p>
<p>Operations() 构造函数<br>minus(a, b) 减法，返回a - b<br>multiply(a, b) 乘法，返回a * b<br>divide(a, b) 除法，返回a / b</p>
<p><strong>提示：</strong></p>
<ul>
<li>你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况</li>
<li>单个用例的函数调用次数不会超过1000次</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来获取-1</span></span><br><span class="line">    <span class="keyword">int</span> ne = Integer.MAX_VALUE + Integer.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span>[] neCache = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">32</span>];<span class="comment">// 放置 -1,-2,-4,-8...</span></span><br><span class="line">    <span class="keyword">long</span>[] poCache = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">32</span>];<span class="comment">// 放置 1,2,4,8...</span></span><br><span class="line">    <span class="keyword">long</span>[] cache = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">32</span>];<span class="comment">// 存放乘数或除数的倍数，1*a,2*a,4*a,8*a...主要用于快速计算，不然容易超时</span></span><br><span class="line">    <span class="keyword">long</span>[] cache1 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">32</span>];<span class="comment">// 存放乘数或除数的倍数 负数-1*a,-2*a,-4*a,-8*a</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Operations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        neCache[<span class="number">0</span>] = ne;</span><br><span class="line">        poCache[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            neCache[i] = neCache[i + ne] + neCache[i + ne];</span><br><span class="line">            poCache[i] = poCache[i + ne] + poCache[i + ne];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">31</span>;<span class="comment">// 从最大值开始比较</span></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b &gt;= poCache[index]) &#123; <span class="comment">// 如果b大于2的index次方，</span></span><br><span class="line">                    b += neCache[index];<span class="comment">// a与b同时减</span></span><br><span class="line">                    a += neCache[index];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index += ne;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// b小于0时同理</span></span><br><span class="line">                <span class="keyword">if</span> (b &lt;= neCache[index]) &#123;</span><br><span class="line">                    b += poCache[index];</span><br><span class="line">                    a += poCache[index];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index += ne;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span> (a == ne) <span class="keyword">return</span> minus(<span class="number">0</span>, b);</span><br><span class="line">        <span class="keyword">if</span> (b == ne) <span class="keyword">return</span> minus(<span class="number">0</span>, a);</span><br><span class="line">        <span class="keyword">int</span> sign = (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) || (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>) ? <span class="number">1</span> : ne;</span><br><span class="line">        <span class="comment">// 把b变成正数</span></span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = minus(<span class="number">0</span>, b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[<span class="number">0</span>] = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            cache[i] = cache[i + ne] + cache[i + ne];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">30</span>; <span class="comment">// 从31开始应该也是可以的</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> retSign = a &gt; <span class="number">0</span> ? <span class="number">1</span> : ne; <span class="comment">// 记录返回值的符号</span></span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= poCache[index]) &#123;</span><br><span class="line">                b += neCache[index];</span><br><span class="line">                ret += cache[index];</span><br><span class="line">                retSign = ret &gt; <span class="number">0</span> ? <span class="number">1</span> : ne;<span class="comment">// 记录返回值的符号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index += ne;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据初始值改变返回值的符号</span></span><br><span class="line">        <span class="keyword">if</span> ((sign &lt; <span class="number">0</span> &amp;&amp; ret &gt; <span class="number">0</span>) || (sign &gt; <span class="number">0</span> &amp;&amp; ret &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            ret = minus(<span class="number">0</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果溢出，返回值的符号会变成相反的</span></span><br><span class="line">        <span class="keyword">if</span> (retSign != (a &gt; <span class="number">0</span> ? <span class="number">1</span> : ne)) &#123;</span><br><span class="line">            ret = minus(<span class="number">0</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span> (b == ne) <span class="keyword">return</span> minus(<span class="number">0</span>, a);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) || (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>) ? <span class="number">1</span> : ne;</span><br><span class="line">        <span class="keyword">long</span> nb = b;</span><br><span class="line">        <span class="keyword">long</span> pb = b;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = minus(<span class="number">0</span>, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nb = minus(<span class="number">0</span>, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = minus(<span class="number">0</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[<span class="number">0</span>] = b;</span><br><span class="line">        cache1[<span class="number">0</span>] = nb;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index &lt; <span class="number">32</span>; ++index) &#123;</span><br><span class="line">            cache[index] = cache[index + ne] + cache[index + ne];</span><br><span class="line">            cache1[index] = cache1[index + ne] + cache1[index + ne];</span><br><span class="line">            <span class="keyword">if</span> (cache1[index] &gt;= a) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到最大值就可以返回了，不用计算完</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">32</span>) index = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &gt;= b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= cache[index]) &#123;</span><br><span class="line">                ret += poCache[index];<span class="comment">// 注意这里是2的index次方的值</span></span><br><span class="line">                a += cache1[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index += ne;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = minus(<span class="number">0</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-10-生存人数"><a href="#16-10-生存人数" class="headerlink" title="16.10. 生存人数"></a>16.10. 生存人数</h3><p>给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。</p>
<p>你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。</p>
<p>如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt; birth.length == death.length &lt;= 10000</code></li>
<li><code>birth[i] &lt;= death[i]</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAliveYear</span><span class="params">(<span class="keyword">int</span>[] birth, <span class="keyword">int</span>[] death)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">102</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; birth.length; i++) &#123;</span><br><span class="line">            <span class="comment">// eg:1900年出生的人导致1900年变化人数加1，存储在change[0]</span></span><br><span class="line">            count[birth[i] - <span class="number">1900</span>]++;</span><br><span class="line">            <span class="comment">// eg:1900年死亡的人导致1901年变化人数减1，存储在change[1]</span></span><br><span class="line">            count[death[i] - <span class="number">1899</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minYear = <span class="number">1900</span>;</span><br><span class="line">        <span class="keyword">int</span> curCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 再根据每年变化人数求一个最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">102</span>; i++) &#123;</span><br><span class="line">            curCount += count[i];</span><br><span class="line">            <span class="keyword">if</span> (curCount &gt; max)&#123;</span><br><span class="line">                max = curCount;</span><br><span class="line">                minYear = <span class="number">1900</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minYear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-11-跳水板"><a href="#16-11-跳水板" class="headerlink" title="16.11. 跳水板"></a>16.11. 跳水板</h3><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
<p><strong>提示：</strong></p>
<ul>
<li>0 &lt; shorter &lt;= longer</li>
<li>0 &lt;= k &lt;= 100000</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (shorter == longer) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;k * shorter&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            res[i] = (k - i) * shorter + i * longer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-13-平分正方形"><a href="#16-13-平分正方形" class="headerlink" title="16.13. 平分正方形"></a>16.13. 平分正方形</h3><p>给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。</p>
<p>每个正方形的数据square包含3个数值，正方形的左下顶点坐标[X,Y] = [square[0],square[1]]，以及正方形的边长square[2]。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标[X1,Y1]和[X2,Y2]的返回格式为{X1,Y1,X2,Y2}，要求若X1 != X2，需保证X1 &lt; X2，否则需保证Y1 &lt;= Y2。</p>
<p>若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>square.length == 3</code></li>
<li><code>square[2] &gt; 0</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] cutSquares(<span class="keyword">int</span>[] square1, <span class="keyword">int</span>[] square2) &#123;</span><br><span class="line">        <span class="comment">//第一个正方形的中心点，x,y坐标及正方形边长</span></span><br><span class="line">        <span class="keyword">double</span> x1 = square1[<span class="number">0</span>] + square1[<span class="number">2</span>]/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">double</span> y1 = square1[<span class="number">1</span>] + square1[<span class="number">2</span>]/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">int</span> d1 = square1[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//第二个正方形的中心点，x,y坐标及正方形边长</span></span><br><span class="line">        <span class="keyword">double</span> x2 = square2[<span class="number">0</span>] + square2[<span class="number">2</span>]/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">double</span> y2 = square2[<span class="number">1</span>] + square2[<span class="number">2</span>]/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">int</span> d2 = square2[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//结果集</span></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//两个中心坐标在同一条x轴上，此时两条直线的斜率都是无穷大</span></span><br><span class="line">        <span class="keyword">if</span>(x1 == x2)&#123;</span><br><span class="line">            res[<span class="number">0</span>] = x1;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(square1[<span class="number">1</span>], square2[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = x1;</span><br><span class="line">            res[<span class="number">3</span>] = Math.max(square1[<span class="number">1</span>] + d1, square2[<span class="number">1</span>] + d2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//斜率存在，则计算斜率和系数，y = kx + b;</span></span><br><span class="line">            <span class="keyword">double</span> k = (y1 - y2)/(x1 - x2);<span class="comment">//斜率计算公式</span></span><br><span class="line">            <span class="keyword">double</span> b = y1 - k*x1;</span><br><span class="line">            <span class="comment">//斜率绝对值大于1，说明与正方形的上边和下边相交</span></span><br><span class="line">            <span class="keyword">if</span>(Math.abs(k) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先计算底边，也就是两个正方形左下坐标y的最小值</span></span><br><span class="line">                res[<span class="number">1</span>] = Math.min(square1[<span class="number">1</span>],square2[<span class="number">1</span>]);</span><br><span class="line">                res[<span class="number">0</span>] = (res[<span class="number">1</span>] - b)/k;</span><br><span class="line">            <span class="comment">//再计算顶边，也就是两个正方形左下坐标y+边长的最大值</span></span><br><span class="line">                res[<span class="number">3</span>] = Math.max(square1[<span class="number">1</span>] + d1,square2[<span class="number">1</span>] + d2);</span><br><span class="line">                res[<span class="number">2</span>] = (res[<span class="number">3</span>] - b)/k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//斜率绝对值小于等于1，说明与正方形的左边和右边相交，同理</span></span><br><span class="line">                res[<span class="number">0</span>] = Math.min(square1[<span class="number">0</span>],square2[<span class="number">0</span>]);</span><br><span class="line">                res[<span class="number">1</span>] = res[<span class="number">0</span>]*k + b;</span><br><span class="line">                res[<span class="number">2</span>] = Math.max(square1[<span class="number">0</span>] + d1,square2[<span class="number">0</span>] + d2);</span><br><span class="line">                res[<span class="number">3</span>] = res[<span class="number">2</span>]*k + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//题目要求x1 &lt; x2,如果结果不满足，我们交换两个点的坐标即可</span></span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &gt; res[<span class="number">2</span>])&#123;</span><br><span class="line">            swap(res, <span class="number">0</span> ,<span class="number">2</span>);</span><br><span class="line">            swap(res, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">double</span>[] res, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = res[x];</span><br><span class="line">        res[x] = res[y];</span><br><span class="line">        res[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-14-最佳直线"><a href="#16-14-最佳直线" class="headerlink" title="16.14. 最佳直线"></a>16.14. 最佳直线</h3><p>给定一个二维平面及平面上的 N 个点列表Points，其中第i个点的坐标为Points[i]=[Xi,Yi]。请找出一条直线，其通过的点的数目最多。</p>
<p>设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为S，你仅需返回[S[0],S[1]]作为答案，若有多条直线穿过了相同数量的点，则选择S[0]值较小的直线返回，S[0]相同则选择S[1]值较小的直线返回。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= len(Points) &lt;= 300</code></li>
<li><code>len(Points[i]) = 2</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] bestLine(<span class="keyword">int</span>[][] points) &#123;</span><br><span class="line">        Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; maxList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] point1 = points[i];</span><br><span class="line">                <span class="keyword">int</span>[] point2 = points[j];</span><br><span class="line">                <span class="keyword">int</span> a = point2[<span class="number">1</span>] - point1[<span class="number">1</span>], b = point1[<span class="number">0</span>] - point2[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c = -(a * point1[<span class="number">0</span>] + b * point1[<span class="number">1</span>]);</span><br><span class="line">                String key = a + <span class="string">&quot;_&quot;</span> + b + <span class="string">&quot;_&quot;</span> + c;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; points.length; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = points[k][<span class="number">0</span>], y = points[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (a * x + b * y + c == <span class="number">0</span>) &#123;</span><br><span class="line">                            list.add(k);</span><br><span class="line">                            map.put(key, list);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (list.size() &gt; maxList.size()) &#123;</span><br><span class="line">                        maxList = list;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() == maxList.size()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (list.get(<span class="number">0</span>) &lt; maxList.get(<span class="number">0</span>) ||</span><br><span class="line">                                (list.get(<span class="number">0</span>).equals(maxList.get(<span class="number">0</span>)) &amp;&amp; list.get(<span class="number">1</span>) &lt; maxList.get(<span class="number">1</span>))) &#123;</span><br><span class="line">                            maxList = list;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = maxList.get(<span class="number">0</span>);</span><br><span class="line">        res[<span class="number">1</span>] = maxList.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-15-珠玑妙算"><a href="#16-15-珠玑妙算" class="headerlink" title="16.15. 珠玑妙算"></a>16.15. 珠玑妙算</h3><p>珠玑妙算游戏（the game of master mind）的玩法如下。</p>
<p>计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。</p>
<p>给定一种颜色组合solution和一个猜测guess，编写一个方法，返回猜中和伪猜中的次数answer，其中answer[0]为猜中的次数，answer[1]为伪猜中的次数。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>len(solution) = len(guess) = 4</code></li>
<li><code>solution</code>和<code>guess</code>仅包含<code>&quot;R&quot;</code>,<code>&quot;G&quot;</code>,<code>&quot;B&quot;</code>,<code>&quot;Y&quot;</code>这4种字符</li>
</ul>
<p>对比相同位置中solution和guess的字符是否相同，若相同则猜对数加1<br>使用哈希表分别记录solution和guess各自四种颜色的数量，伪猜中数 = 四种颜色min(数量1, 数量2)的总和 - 猜对数</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] masterMind(String solution, String guess) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Character,Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; guess.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = solution.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> c2 = guess.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) res[<span class="number">0</span>]++;</span><br><span class="line">            map1.put(c1, map1.getOrDefault(c1, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            map2.put(c2, map2.getOrDefault(c2, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Character c : map1.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map2.containsKey(c)) res[<span class="number">1</span>] += (map1.get(c) &lt;= map2.get(c) ? map1.get(c) : map2.get(c));</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] -= res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-16-部分排序"><a href="#16-16-部分排序" class="headerlink" title="16.16. 部分排序"></a>16.16. 部分排序</h3><p>给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= len(array) &lt;= 1000000</code></li>
</ul>
<p>方法一：单调栈</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = len, right = -<span class="number">1</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stk1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stk2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk1.isEmpty() &amp;&amp; array[i] &lt; array[stk1.peek()])&#123;</span><br><span class="line">                left = Math.min(left,stk1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            stk1.push(i);</span><br><span class="line">            <span class="keyword">while</span> (!stk2.isEmpty() &amp;&amp; array[len - i - <span class="number">1</span>] &gt; array[stk2.peek()])&#123;</span><br><span class="line">                right = Math.max(right,stk2.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            stk2.push(len - i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = left == len ? -<span class="number">1</span> : left;</span><br><span class="line">        ans[<span class="number">1</span>] = right;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] subSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>, first = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; max)&#123;</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = Math.max(max, array[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[len - <span class="number">1</span> - i] &gt; min)&#123;</span><br><span class="line">                first = len - <span class="number">1</span> - i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                min = Math.min(min, array[len - <span class="number">1</span> - i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;first, last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-17-连续序列"><a href="#16-17-连续序列" class="headerlink" title="16.17. 连续序列"></a>16.17. 连续序列</h3><p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p>
<p><strong>进阶：</strong></p>
<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>动态规划</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] + nums[i] : nums[i];</span><br><span class="line">            ans = Math.max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-18-模式匹配"><a href="#16-18-模式匹配" class="headerlink" title="16.18. 模式匹配"></a>16.18. 模式匹配</h3><p>你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。</p>
<p>提示：</p>
<p>1 &lt;= len(pattern) &lt;= 1000<br>0 &lt;= len(value) &lt;= 1000<br>你可以假设pattern只包含字母”a”和”b”，value仅包含小写字母。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">patternMatching</span><span class="params">(String pattern, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算模式串中 a,b 的数量</span></span><br><span class="line">        <span class="keyword">int</span> countA = <span class="number">0</span>, countB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : pattern.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                ++countA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++countB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 b 的数量大于 a 的数量，交换 a 和 b</span></span><br><span class="line">        <span class="keyword">if</span> (countA &lt; countB) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = countA;</span><br><span class="line">            countA = countB;</span><br><span class="line">            countB = temp;</span><br><span class="line">            <span class="keyword">char</span>[] array = pattern.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                array[i] = array[i] == <span class="string">&#x27;a&#x27;</span> ? <span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pattern = <span class="keyword">new</span> String(array);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果主串是空字符串，并且模式串只有一种子模式或模式串也是空字符串，则匹配成功，返回 true 。</span></span><br><span class="line">        <span class="comment">//否则失败，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> countB == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果模式串是空字符串，并且主串非空，则匹配失败</span></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lenA = <span class="number">0</span>; countA * lenA &lt;= value.length(); ++lenA) &#123;</span><br><span class="line">            <span class="comment">//主串减去 countA 个长度为 lenA 的 a 子模式匹配值后剩余字符数量。</span></span><br><span class="line">            <span class="comment">//剩余部分是需要和 b 模式进行匹配，由于从模式串已知 b 子模式的数量，</span></span><br><span class="line">            <span class="comment">//从而可以计算出b的匹配值长度（必须是非负整数）</span></span><br><span class="line">            <span class="keyword">int</span> rest = value.length() - countA * lenA;</span><br><span class="line">            <span class="comment">// b 子模式匹配值长度为是非负整数时继续计算，否则匹配失败</span></span><br><span class="line">            <span class="keyword">if</span> ((countB == <span class="number">0</span> &amp;&amp; rest == <span class="number">0</span>) || (countB != <span class="number">0</span> &amp;&amp; rest % countB == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">//获取 b 子模式匹配值长度</span></span><br><span class="line">                <span class="keyword">int</span> lenB = (countB == <span class="number">0</span> ? <span class="number">0</span> : rest / countB);</span><br><span class="line">                <span class="comment">//每次分割起始位置</span></span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//记录当前子串是否匹配成功</span></span><br><span class="line">                <span class="keyword">boolean</span> correct = <span class="keyword">true</span>;</span><br><span class="line">                String valueA = <span class="string">&quot;&quot;</span>, valueB = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">//根据a 子模式和b 子模式匹配值长度和 a,b 在模式串里出现的先后顺序去分割主串。</span></span><br><span class="line">                <span class="comment">// 同时获得 a 子模式的匹配值和 b 子模式的匹配值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> ch : pattern.toCharArray()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ch == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                        String sub = value.substring(pos, pos + lenA);</span><br><span class="line">                        <span class="keyword">if</span> (valueA.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//a 子模式的匹配值</span></span><br><span class="line">                            valueA = sub;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!valueA.equals(sub)) &#123;</span><br><span class="line">                            correct = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        pos += lenA;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        String sub = value.substring(pos, pos + lenB);</span><br><span class="line">                        <span class="keyword">if</span> (valueB.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//b 子模式的匹配值</span></span><br><span class="line">                            valueB = sub;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!valueB.equals(sub)) &#123;</span><br><span class="line">                            correct = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        pos += lenB;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果主串和模式串完全匹配，同时 a 子模式的匹配值和 b 子模式的匹配值不相同，则匹配成功</span></span><br><span class="line">                <span class="keyword">if</span> (correct &amp;&amp; !valueA.equals(valueB)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-19-水域大小"><a href="#16-19-水域大小" class="headerlink" title="16.19. 水域大小"></a>16.19. 水域大小</h3><p>你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt; len(land) &lt;= 1000</code></li>
<li><code>0 &lt; len(land[i]) &lt;= 1000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] pondSizes(<span class="keyword">int</span>[][] land) &#123;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq  = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = land.length, n = land[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (land[i][j] == <span class="number">0</span> &amp;&amp; !visited[i][j])&#123;</span><br><span class="line">                    list.add(dfs(land,i,j,visited));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] land, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = land.length,n = land[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || land[x][y] != <span class="number">0</span> || visited[x][y]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> n_x = x + dir[<span class="number">0</span>], n_y = y + dir[<span class="number">1</span>];</span><br><span class="line">            res += dfs(land,n_x,n_y,visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-20-T9键盘"><a href="#16-20-T9键盘" class="headerlink" title="16.20. T9键盘"></a>16.20. T9键盘</h3><p>在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：</p>
<p>提示：</p>
<p>num.length &lt;= 1000<br>words.length &lt;= 500<br>words[i].length == num.length<br>num中不会出现 0, 1 这两个数字</p>
<p>方法一：遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getValidT9Words</span><span class="params">(String num, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = num.length();</span><br><span class="line">        <span class="keyword">int</span>[] key = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>,</span><br><span class="line">            <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num.charAt(i) != key[word.charAt(i) - <span class="string">&#x27;a&#x27;</span>] + <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= length)</span><br><span class="line">                res.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：字典树</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getValidT9Words</span><span class="params">(String num, String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = num.length();</span><br><span class="line">        Trie t = <span class="keyword">new</span> Trie(map);</span><br><span class="line">        t.insert(num);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() == len &amp;&amp; t.starts(s)) list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    Map&lt;Integer, String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">(Map&lt;Integer, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            String s = map.get(index);</span><br><span class="line">            Trie t = <span class="keyword">new</span> Trie();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.children[c - <span class="string">&#x27;a&#x27;</span>] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">starts</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Trie <span class="title">searchPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-21-交换和"><a href="#16-21-交换和" class="headerlink" title="16.21. 交换和"></a>16.21. 交换和</h3><p>给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。</p>
<p>返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= array1.length, array2.length &lt;= 100000</code></li>
</ul>
<p>思路：结合数学方法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findSwapValues(<span class="keyword">int</span>[] array1, <span class="keyword">int</span>[] array2) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array1) &#123;</span><br><span class="line">            sum1 += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array2) &#123;</span><br><span class="line">            sum2 += num;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = sum2 - sum1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (diff % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : array1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num + diff / <span class="number">2</span>)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num,num + diff / <span class="number">2</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-22-兰顿蚂蚁"><a href="#16-22-兰顿蚂蚁" class="headerlink" title="16.22. 兰顿蚂蚁"></a>16.22. 兰顿蚂蚁</h3><p>一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。</p>
<p>(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。<br>(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。</p>
<p>编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。</p>
<p>网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由 ‘X’ 表示，白色方格由 ‘_’ 表示，蚂蚁所在的位置由 ‘L’, ‘U’, ‘R’, ‘D’ 表示，分别表示蚂蚁 左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。</p>
<p><strong>说明：</strong></p>
<ul>
<li><code>K &lt;= 100000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Position</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 横坐标 x 纵坐标 y</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Position</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Position)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Position o = (Position) obj;</span><br><span class="line">            <span class="keyword">return</span> x == o.x &amp;&amp; y == o.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改写哈希算法，使两个 Position 对象可以比较坐标而不是内存地址</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = x;</span><br><span class="line">            result = <span class="number">31</span> * result + y;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">printKMoves</span><span class="params">(<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] direction = &#123;<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">// 用“向量”记录方向，顺序与上一行方向的字符顺序保持一致，每个元素的后一个元素都是可以90°向右变换得到的</span></span><br><span class="line">        <span class="keyword">int</span>[][] offset = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 蚂蚁的位置</span></span><br><span class="line">        Position antPos = <span class="keyword">new</span> Position(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 蚂蚁方向的向量序号</span></span><br><span class="line">        <span class="keyword">int</span> antDir = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 用集合存储所有黑块的坐标，一开始想再定义一个路径的坐标集合，发现可以直接用黑块+蚂蚁位置也能过</span></span><br><span class="line">        Set&lt;Position&gt; blackSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 新的坐标对象用于放入集合</span></span><br><span class="line">            Position t = <span class="keyword">new</span> Position(antPos.x, antPos.y);</span><br><span class="line">            <span class="comment">// 如果黑块集合能存入，说明脚下的块不在集合中，也就意味着是白色，方向序号循环自增1</span></span><br><span class="line">            <span class="keyword">if</span> (blackSet.add(t)) antDir = (antDir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则说明脚下的块已经在集合中，也就意味着是黑色，方向序号循环自增3，相当于自减1，但是Math.floorMod取模可能消耗大？用+3替代</span></span><br><span class="line">                antDir = (antDir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">                <span class="comment">// 别忘了删除，即将黑块变白</span></span><br><span class="line">                blackSet.remove(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 蚂蚁移动位置</span></span><br><span class="line">            antPos.x += offset[antDir][<span class="number">0</span>];</span><br><span class="line">            antPos.y += offset[antDir][<span class="number">1</span>];</span><br><span class="line">            K--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算边界，即输出网格的行数和列数</span></span><br><span class="line">        <span class="keyword">int</span> left = antPos.x, top = antPos.y, right = antPos.x, bottom = antPos.y;</span><br><span class="line">        <span class="keyword">for</span> (Position pos : blackSet) &#123;</span><br><span class="line">            left = pos.x &lt; left ? pos.x : left;</span><br><span class="line">            top = pos.y &lt; top ? pos.y : top;</span><br><span class="line">            right = pos.x &gt; right ? pos.x : right;</span><br><span class="line">            bottom = pos.y &gt; bottom ? pos.y : bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[][] grid = <span class="keyword">new</span> <span class="keyword">char</span>[bottom - top + <span class="number">1</span>][right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 填充白块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : grid)</span><br><span class="line">            Arrays.fill(row, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        <span class="comment">// 替换黑块</span></span><br><span class="line">        <span class="keyword">for</span> (Position pos : blackSet)</span><br><span class="line">            grid[pos.y - top][pos.x - left] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        <span class="comment">// 替换蚂蚁</span></span><br><span class="line">        grid[antPos.y - top][antPos.x - left] = direction[antDir];</span><br><span class="line">        <span class="comment">// 利用网格生成字符串列表</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : grid)</span><br><span class="line">            result.add(String.valueOf(row));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-24-数对和"><a href="#16-24-数对和" class="headerlink" title="16.24. 数对和"></a>16.24. 数对和</h3><p>设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums.length &lt;= 100000</code></li>
</ul>
<p>方法一:哈希表</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pairSums(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num,map.get(num) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(num) &gt;= <span class="number">0</span> &amp;&amp; map.getOrDefault(target - num,<span class="number">0</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(target - num,map.get(target - num) - <span class="number">1</span>);</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(num);</span><br><span class="line">                list.add(target - num);</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二:排序+双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pairSums(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//对数组进行排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[left++],nums[right++])));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)&#123;<span class="comment">//如果两个的和大于目标值，那么right指针向左走一步继续寻找</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果两个的和小于目标值，那么left指针向右走一步继续寻找</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="16-25-LRU缓存"><a href="#16-25-LRU缓存" class="headerlink" title="16.25. LRU缓存"></a>16.25. LRU缓存</h3><div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用双向链表记录cache中最近使用的元素</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DlistNode</span></span>&#123;</span><br><span class="line">        DlistNode pre;</span><br><span class="line">        DlistNode next;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        DlistNode(<span class="keyword">int</span> key,<span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DlistNode vrHead;</span><br><span class="line">    DlistNode vrTail;</span><br><span class="line">    Map&lt;Integer,DlistNode&gt; cache;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//虚拟头节点与尾节点</span></span><br><span class="line">        vrHead = <span class="keyword">new</span> DlistNode(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        vrTail = <span class="keyword">new</span> DlistNode(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        vrHead.next = vrTail;</span><br><span class="line">        vrTail.pre = vrHead;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        DlistNode node = cache.get(key);</span><br><span class="line">        <span class="comment">//删除node节点</span></span><br><span class="line">        delete(node);</span><br><span class="line">        <span class="comment">//将node节点加到链表头部</span></span><br><span class="line">        addToHead(vrHead,node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓存中不包含key，将新的key加入缓存，加入之前要考虑容量超出的问题</span></span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key))&#123;</span><br><span class="line">            DlistNode node = <span class="keyword">new</span> DlistNode(key,value);</span><br><span class="line">            <span class="comment">//容量已满</span></span><br><span class="line">            <span class="keyword">if</span> (cache.size() == capacity)&#123;</span><br><span class="line">                <span class="comment">//链表和缓存中都删除链表最后一个元素</span></span><br><span class="line">                cache.remove(vrTail.pre.key);</span><br><span class="line">                delete(vrTail.pre);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将新节点加入链表和缓存</span></span><br><span class="line">            addToHead(vrHead,node);</span><br><span class="line">            cache.put(key,node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//缓存中包含key，更新key的值，并将key所代表的节点移到链表头部</span></span><br><span class="line">            DlistNode node = cache.get(key);</span><br><span class="line">            node.val = value;</span><br><span class="line">            delete(node);</span><br><span class="line">            addToHead(vrHead,node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DlistNode vrHead, DlistNode node)</span> </span>&#123;</span><br><span class="line">        node.next = vrHead.next;</span><br><span class="line">        node.pre = vrHead;</span><br><span class="line">        vrHead.next = node;</span><br><span class="line">        node.next.pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(DlistNode node)</span> </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<hr>
<h3 id="16-26-计算器"><a href="#16-26-计算器" class="headerlink" title="16.26. 计算器"></a>16.26. 计算器</h3><p>给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</p>
<p>表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</p>
<p><strong>说明：</strong></p>
<ul>
<li>你可以假设所给定的表达式都是有效的。</li>
<li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();<span class="comment">//去掉两端多余空格</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> operator = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(s.charAt(i)) || i == s.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span> (operator)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.push(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.push(-num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.push(stk.pop()*num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stk.push(stk.pop()/num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                operator = s.charAt(i);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty())&#123;</span><br><span class="line">            num += stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-01-不用加号的加法"><a href="#17-01-不用加号的加法" class="headerlink" title="17.01 不用加号的加法"></a>17.01 不用加号的加法</h3><p>设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((a &amp; b) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = (temp &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a ^ b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-04-消失的数字"><a href="#17-04-消失的数字" class="headerlink" title="17.04. 消失的数字"></a>17.04. 消失的数字</h3><p>数组<code>nums</code>包含从<code>0</code>到<code>n</code>的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？</p>
<p><strong>注意：</strong>本题相对书上原题稍作改动</p>
<p>方法一：位运算</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：数学方法</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res -= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-05-字母与数字"><a href="#17-05-字母与数字" class="headerlink" title="17.05. 字母与数字"></a>17.05. 字母与数字</h3><p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>
<p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>array.length &lt;= 100000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = -<span class="number">1</span>,end = -<span class="number">1</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(array[i].charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(cnt))&#123;</span><br><span class="line">                map.put(cnt,i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i - map.get(cnt) - <span class="number">1</span> &gt; end - start)&#123;</span><br><span class="line">                start = map.get(cnt)+ <span class="number">1</span>;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        String[] res = <span class="keyword">new</span> String[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = array[start++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-06-2-出现的次数"><a href="#17-06-2-出现的次数" class="headerlink" title="17.06.2. 出现的次数"></a>17.06.2. 出现的次数</h3><p>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。</p>
<p>提示：</p>
<ul>
<li><code>n &lt;= 10^9</code></li>
</ul>
<p>方法一：找规律</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOf2sInRange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String num = n + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len = num.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//依次统计第i位为2的个数，累加</span></span><br><span class="line">            <span class="keyword">int</span> cur = num.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> left = i == <span class="number">0</span> ? <span class="number">0</span> : Integer.parseInt(num.substring(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">int</span> right = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,num.length() - <span class="number">1</span> - i);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == len - <span class="number">1</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans += Integer.parseInt(num.substring(i + <span class="number">1</span>, len)) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; <span class="number">2</span>) left += <span class="number">1</span>;</span><br><span class="line">            ans += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：数位dp</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOf2sInRange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digit = (<span class="keyword">int</span>)Math.log10(n) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[digit+<span class="number">1</span>][<span class="number">2</span>];  </span><br><span class="line">        <span class="comment">// dp[i][0] = numberOf2sInRange(n % pow(10, i)) 保存0~n的1-i位组成的数包含2的个数</span></span><br><span class="line">        <span class="comment">// dp[i][1] = numberOf2sInRange(99..9) 保存i位均为9包含2的个数</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = n % <span class="number">10</span> &gt;= <span class="number">2</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= digit; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = n/ ((<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = k * dp[i-<span class="number">1</span>][<span class="number">1</span>] + dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] += n % (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>) +<span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] +=  (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">10</span> * dp[i-<span class="number">1</span>][<span class="number">1</span>] + (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>); <span class="comment">//计算1-i位均为9的值包含2的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[digit][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-07-婴儿名字"><a href="#17-07-婴儿名字" class="headerlink" title="17.07. 婴儿名字"></a>17.07. 婴儿名字</h3><p>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。</p>
<p>在结果列表中，选择 字典序最小 的名字作为真实名字。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>names.length &lt;= 100000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> String[] trulyMostPopular(String[] names, String[] synonyms) &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (name.charAt(i) != <span class="string">&#x27;(&#x27;</span>) i++;</span><br><span class="line">            <span class="keyword">int</span> value = Integer.parseInt(name.substring(i + <span class="number">1</span>,name.length() - <span class="number">1</span>));</span><br><span class="line">            cnt.put(name.substring(<span class="number">0</span>,i),value);</span><br><span class="line">            map.put(name.substring(<span class="number">0</span>,i),name.substring(<span class="number">0</span>,i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String synonym : synonyms) &#123;</span><br><span class="line">            String[] split = synonym.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            String name1 = split[<span class="number">0</span>].substring(<span class="number">1</span>,split[<span class="number">0</span>].length());</span><br><span class="line">            String name2 = split[<span class="number">1</span>].substring(<span class="number">0</span>,split[<span class="number">1</span>].length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!cnt.containsKey(name1))&#123;</span><br><span class="line">                cnt.put(name1,<span class="number">0</span>);</span><br><span class="line">                map.put(name1,name1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!cnt.containsKey(name2))&#123;</span><br><span class="line">                cnt.put(name2,<span class="number">0</span>);</span><br><span class="line">                map.put(name2,name2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(map,cnt);</span><br><span class="line">        <span class="keyword">for</span> (String synonym : synonyms) &#123;</span><br><span class="line">            String[] split = synonym.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            String name1 = split[<span class="number">0</span>].substring(<span class="number">1</span>,split[<span class="number">0</span>].length());</span><br><span class="line">            String name2 = split[<span class="number">1</span>].substring(<span class="number">0</span>,split[<span class="number">1</span>].length() - <span class="number">1</span>);</span><br><span class="line">            unionFind.union(name1,name2);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : map.keySet()) &#123;</span><br><span class="line">            String rootName = unionFind.find(name);</span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(rootName)) <span class="keyword">continue</span>;</span><br><span class="line">            hashSet.add(rootName);</span><br><span class="line">            String str = rootName + <span class="string">&quot;(&quot;</span> + cnt.get(rootName) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; map;</span><br><span class="line">    Map&lt;String,Integer&gt; cnt;</span><br><span class="line"></span><br><span class="line">    UnionFind(Map&lt;String,String&gt; map,Map&lt;String,Integer&gt; cnt)&#123;</span><br><span class="line">        <span class="keyword">this</span>.cnt = cnt;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        String str1 = map.get(str);</span><br><span class="line">        <span class="keyword">if</span> (str1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (str1.equals(str)) <span class="keyword">return</span> str;</span><br><span class="line">        map.put(str,find(str1));</span><br><span class="line">        <span class="keyword">return</span> map.get(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        String father1 = find(s1);</span><br><span class="line">        String father2 = find(s2);</span><br><span class="line">        <span class="keyword">if</span> (father1 == <span class="keyword">null</span> || father2 == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!father1.equals(father2))&#123;</span><br><span class="line">            <span class="keyword">int</span> x = father1.compareTo(father2);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(father1,father2);</span><br><span class="line">                cnt.put(father2,cnt.get(father2) + cnt.get(father1));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(father2,father1);</span><br><span class="line">                cnt.put(father1,cnt.get(father2) + cnt.get(father1));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-08-马戏团人塔"><a href="#17-08-马戏团人塔" class="headerlink" title="17.08. 马戏团人塔"></a>17.08. 马戏团人塔</h3><p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>height.length == weight.length &lt;= 10000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bestSeqAtIndex</span><span class="params">(<span class="keyword">int</span>[] height, <span class="keyword">int</span>[] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span>[][] person = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            person[i][<span class="number">0</span>] = height[i];</span><br><span class="line">            person[i][<span class="number">1</span>] = weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//身高升序排列，体重降序排列，保证升高相同的人只有一个被选中，转化为求体重的最长递增序列（LIS）</span></span><br><span class="line">        Arrays.sort(person,(a,b) -&gt; a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//arr存储长度为i + 1的LIS的最小末尾</span></span><br><span class="line">        <span class="comment">//初始化，长度为1的最长递增序列的最小末尾为person[0][1](实际上是体重的最小值，后续通过遍历person[i][1]更新)</span></span><br><span class="line">        arr[<span class="number">0</span>] = person[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;<span class="comment">//cur记录当前递增序列的最大长度</span></span><br><span class="line">        <span class="comment">//遍历记录体重的数组person[i][1]，更新arr;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = person[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//下一个体重值比arr中记录的所有值大，即出现长度更长(为cur+1)的LIS，在arr中记录此长度序列的最后一个值</span></span><br><span class="line">            <span class="keyword">if</span> (next &gt; arr[cur - <span class="number">1</span>])&#123;</span><br><span class="line">                arr[cur++] = next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//出现末尾更小的LIS，通过二分查找在arr中查找对应序列长度的下标，更新arr中记录的最小末尾</span></span><br><span class="line">                <span class="keyword">int</span> index = binarySearch(arr,cur,next);</span><br><span class="line">                arr[index] = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找变体 找到第一个大于等于target的位置index</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> cur, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = cur - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-09-第k个数"><a href="#17-09-第k个数" class="headerlink" title="17.09. 第k个数"></a>17.09. 第k个数</h3><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>,p3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[p1] * <span class="number">3</span>, Math.min(dp[p2] * <span class="number">5</span>,dp[p3] * <span class="number">7</span>));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[p1] * <span class="number">3</span>) p1++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[p2] * <span class="number">5</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[p3] * <span class="number">7</span>) p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-10-主要元素"><a href="#17-10-主要元素" class="headerlink" title="17.10. 主要元素"></a>17.10. 主要元素</h3><p>数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>,p3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[p1] * <span class="number">3</span>, Math.min(dp[p2] * <span class="number">5</span>,dp[p3] * <span class="number">7</span>));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[p1] * <span class="number">3</span>) p1++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[p2] * <span class="number">5</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[p3] * <span class="number">7</span>) p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-11-单词距离"><a href="#17-11-单词距离" class="headerlink" title="17.11. 单词距离"></a>17.11. 单词距离</h3><p>有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p>
<p>提示：</p>
<ul>
<li><code>words.length &lt;= 100000</code></li>
</ul>
<p>方法一：双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClosest</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.equals(word2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].equals(word1)) list1.add(i);</span><br><span class="line">            <span class="keyword">if</span> (words[i].equals(word2)) list2.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Math.abs(list1.get(p1) - list2.get(p2));</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; list1.size() &amp;&amp; p2 &lt; list2.size())&#123;</span><br><span class="line">            res = Math.min(res,Math.abs(list1.get(p1) - list2.get(p2)));</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span> (list1.get(p1) &gt; list2.get(p2))&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：一次遍历</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClosest</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = words.length;</span><br><span class="line">        <span class="keyword">int</span> ans = length;</span><br><span class="line">        <span class="keyword">int</span> index1 = -<span class="number">1</span>, index2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            String word = words[i];</span><br><span class="line">            <span class="keyword">if</span> (word.equals(word1)) &#123;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (word.equals(word2)) &#123;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index1 &gt;= <span class="number">0</span> &amp;&amp; index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans = Math.min(ans, Math.abs(index1 - index2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-12-BiNode"><a href="#17-12-BiNode" class="headerlink" title="17.12. BiNode"></a>17.12. BiNode</h3><p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<p>注意：本题相对原题稍作改动</p>
<p><strong>提示：</strong></p>
<ul>
<li>节点数量不会超过 100000。</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);   <span class="comment">// 虚拟头节点</span></span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;               <span class="comment">// 指向当前节点的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        process(root);</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        process(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.right = root;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        process(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-13-恢复空格"><a href="#17-13-恢复空格" class="headerlink" title="17.13. 恢复空格"></a>17.13. 恢复空格</h3><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>
<p>注意：本题相对原题稍作改动，只需返回未识别的字符数</p>
<p>提示：</p>
<p>0 &lt;= len(sentence) &lt;= 1000<br>dictionary中总字符数不超过 150000。<br>你可以认为dictionary和sentence中只包含小写字母。</p>
<p>方法一：哈希表+动态规划</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sentence.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(dictionary));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                String substring = sentence.substring(j, i);</span><br><span class="line">                <span class="keyword">if</span> (set.contains(substring))&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i],dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：字典树 + 动态规划</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sentence.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (String s : dictionary) &#123;</span><br><span class="line">            root.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            Trie cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = sentence.charAt(j - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur.child[index] == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                cur = cur.child[index];</span><br><span class="line">                <span class="keyword">if</span> (cur.isEnd)&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i],dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已经全部匹配，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">    Trie[] child;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        child = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Trie curNode = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            Trie[] child = curNode.child;</span><br><span class="line">            <span class="keyword">if</span> (child[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                child[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        curNode.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-14-最小k个数"><a href="#17-14-最小k个数" class="headerlink" title="17.14 最小k个数"></a>17.14 最小k个数</h3><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>
<p>注意：本题相对原题稍作改动，只需返回未识别的字符数</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= len(arr) &lt;= 100000</code></li>
<li><code>0 &lt;= k &lt;= min(100000, len(arr))</code></li>
</ul>
<p>方法一：堆</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestK(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(arr[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pq.peek())&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.add(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            res[i++] = pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：快排</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestK(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>,k);</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, res, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right ,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index == k - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>)&#123;</span><br><span class="line">            quickSort(arr,left,index - <span class="number">1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            quickSort(arr,index + <span class="number">1</span>,right,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = left + (<span class="keyword">int</span>)(Math.random() * (right - left + <span class="number">1</span>));</span><br><span class="line">        swap(nums,x,right);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(nums,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-15-最长单词"><a href="#17-15-最长单词" class="headerlink" title="17.15. 最长单词"></a>17.15. 最长单词</h3><p>给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= len(words) &lt;= 200</code></li>
<li><code>1 &lt;= len(words[i]) &lt;= 100</code></li>
</ul>
<p>方法一：哈希表 + 递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestWord</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//字符串数组排序，字符串长的在前面，相同长度的字典序小的在前面</span></span><br><span class="line">        Arrays.sort(words,(a,b) -&gt; a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(words));</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            set.remove(word);</span><br><span class="line">            <span class="keyword">if</span>(find(set,word))</span><br><span class="line">                <span class="keyword">return</span> word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(Set&lt;String&gt; set, String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(word.substring(<span class="number">0</span>,i+<span class="number">1</span>)) &amp;&amp; find(set,word.substring(i+<span class="number">1</span>)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：字典树 + 递归</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Trie root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestWord</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            root.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字符串数组排序，字符串长的在前面，相同长度的字典序小的在前面</span></span><br><span class="line">        Arrays.sort(words,(a,b) -&gt; a.length() == b.length() ? a.compareTo(b) : b.length() - a.length());</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            Trie curNode = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                curNode = curNode.child[index];</span><br><span class="line">                <span class="keyword">if</span> (curNode.isEnd &amp;&amp; canSplitToWord(word.substring(i + <span class="number">1</span>)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> word;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前单词是否可以被切分，并在word中找到</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canSplitToWord</span><span class="params">(String remain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当没有可以切分的了 返回True</span></span><br><span class="line">        <span class="keyword">if</span> (remain.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Trie cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; remain.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = remain.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            cur = cur.child[index];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//这个节点找不到</span></span><br><span class="line">            <span class="comment">//当前的节点是个单词，且剩余部分可以再次被切分</span></span><br><span class="line">            <span class="keyword">if</span> (cur.isEnd &amp;&amp; canSplitToWord(remain.substring(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">    Trie[] child;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    Trie()&#123;</span><br><span class="line">        child = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Trie curNode = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = str.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (curNode.child[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                curNode.child[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        curNode.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-16-按摩师"><a href="#17-16-按摩师" class="headerlink" title="17.16. 按摩师"></a>17.16. 按摩师</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>],dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="17-17-多次搜索"><a href="#17-17-多次搜索" class="headerlink" title="17.17. 多次搜索"></a>17.17. 多次搜索</h3><p>给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。</p>
<p>提示：</p>
<p>0 &lt;= len(big) &lt;= 1000<br>0 &lt;= len(smalls[i]) &lt;= 1000<br>smalls的总字符数不会超过 100000。<br>你可以认为smalls中没有重复字符串。<br>所有出现的字符均为英文小写字母。</p>
<p>思路：创建字典树Trie，将smalls中的word加入到Trie中，遍历big,从big的第i个位置开始搜索，如果搜到了smalls中单词，将结果加入到list中</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiSearch(String big, String[] smalls) &#123;</span><br><span class="line">        Map&lt;String,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (String str : smalls) &#123;</span><br><span class="line">            root.insert(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; big.length(); i++) &#123;</span><br><span class="line">            Trie cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; big.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = big.charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur.child[index] == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                cur = cur.child[index];</span><br><span class="line">                <span class="keyword">if</span> (cur.end != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    String key = cur.end;</span><br><span class="line">                    <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">                        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        map.put(key,list);</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;Integer&gt; list = map.get(key);</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[smalls.length][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smalls.length; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = map.get(smalls[i]);</span><br><span class="line">            <span class="keyword">if</span>(list == <span class="keyword">null</span>)&#123;</span><br><span class="line">                res[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            res[i] = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                res[i][j] = list.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">    Trie[] child;</span><br><span class="line">    String end;</span><br><span class="line">    Trie()&#123;</span><br><span class="line">        child = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        Trie cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.child[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.child[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-18-最短超串"><a href="#17-18-最短超串" class="headerlink" title="17.18. 最短超串"></a>17.18. 最短超串</h3><p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>
<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>big.length &lt;= 100000</code></li>
<li><code>1 &lt;= small.length &lt;= 100000</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestSeq(<span class="keyword">int</span>[] big, <span class="keyword">int</span>[] small) &#123;</span><br><span class="line">        <span class="comment">//滑动窗口需要覆盖的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = small.length;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : small) &#123;</span><br><span class="line">            hashMap.put(num,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = -<span class="number">1</span>,end = big.length;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; big.length)&#123;<span class="comment">//边界条件</span></span><br><span class="line">            <span class="comment">//扩展右边界</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; big.length &amp;&amp; cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (hashMap.containsKey(big[right]))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (hashMap.get(big[right]) &gt; <span class="number">0</span>) cnt--;</span><br><span class="line">                    hashMap.put(big[right],hashMap.get(big[right]) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//收缩左边界</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (hashMap.containsKey(big[left]))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (hashMap.get(big[left]) == <span class="number">0</span>) cnt++;</span><br><span class="line">                    hashMap.put(big[left],hashMap.get(big[left]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; end - start)&#123;</span><br><span class="line">                end = right - <span class="number">1</span>;</span><br><span class="line">                start = left - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-19-消失的两个数字"><a href="#17-19-消失的两个数字" class="headerlink" title="17.19. 消失的两个数字"></a>17.19. 消失的两个数字</h3><p>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</p>
<p>以任意顺序返回这两个数字均可。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums.length &lt;= 30000</code></li>
</ul>
<p>方法一：求和</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] missingTwo(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = len + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消失的两数之和</span></span><br><span class="line">        <span class="keyword">int</span> sumTwo = n * (n + <span class="number">1</span>) / <span class="number">2</span> - sum;</span><br><span class="line">        <span class="keyword">int</span> mid = sumTwo / <span class="number">2</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= mid)&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num1 = mid * (mid + <span class="number">1</span>) / <span class="number">2</span> - sum;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num1,sumTwo - num1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：异或</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] missingTwo(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = len + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//消失的两数异或值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            a ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            a ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastOne = a &amp; (-a);<span class="comment">//a二进制值的最后一位1，设此位为，说明消失的两数一个第i位为0，另一个第i位为为1；</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;<span class="comment">//消失的两数中第i位为1的数；</span></span><br><span class="line">        <span class="comment">//将所有第i位为1的数异或两次，可求出缺失的第i位为1的数，此数只异或一次。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lastOne &amp; i) != <span class="number">0</span>) num1 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lastOne &amp; num) != <span class="number">0</span>) num1 ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num1,a ^ num1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-20-连续中值"><a href="#17-20-连续中值" class="headerlink" title="17.20. 连续中值"></a>17.20. 连续中值</h3><p>随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。</p>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; big;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        small = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        big = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次新增元素时，我们先按照大小将其放入对应的堆，再对两个堆的大小进行调整，保证左边的元素不少于右边，同时不超过右边+1。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (small.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            big.add(num);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= small.peek()) &#123;</span><br><span class="line">                big.add(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                small.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (big.size() &lt; small.size()) big.add(small.poll());</span><br><span class="line">        <span class="keyword">if</span> (big.size() &gt; small.size() + <span class="number">1</span>) small.add(big.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (big.size() == <span class="number">0</span> &amp;&amp; small.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (big.size() == small.size()) <span class="keyword">return</span> (big.peek() + small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> big.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-21-直方图的水量"><a href="#17-21-直方图的水量" class="headerlink" title="17.21. 直方图的水量"></a>17.21. 直方图的水量</h3><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>
<p>方法一：单调栈</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; height[i] &gt; height[stk.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> index = stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (stk.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> y =  Math.min(height[i],height[stk.peek()]) - height[index];</span><br><span class="line">                <span class="keyword">int</span> x = i - stk.peek() - <span class="number">1</span>;</span><br><span class="line">                res += x * y;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<p>方法二：双指针</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; height[i] &gt; height[stk.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> index = stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (stk.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> y =  Math.min(height[i],height[stk.peek()]) - height[index];</span><br><span class="line">                <span class="keyword">int</span> x = i - stk.peek() - <span class="number">1</span>;</span><br><span class="line">                res += x * y;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-22-单词转换"><a href="#17-22-单词转换" class="headerlink" title="17.22. 单词转换"></a>17.22. 单词转换</h3><p>给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。</p>
<p>编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。</p>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; wordList;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;        <span class="comment">//找到重点时置为true, 之后的递归可以快速返回</span></span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;String&gt; visit = <span class="keyword">new</span> HashSet&lt;&gt;();  <span class="comment">//储存访问过的节点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;String&gt; unable = <span class="keyword">new</span> HashSet&lt;&gt;();  <span class="comment">//储存回溯的节点，回溯了说明该节点下的通路不符合题意</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord)) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">this</span>.wordList = wordList;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(beginWord, path,endWord);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; path, String end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag || visit.contains(s) || unable.contains(s)) <span class="keyword">return</span>;     <span class="comment">//如果已找到 || 已访问 || 已回溯  则直接返回</span></span><br><span class="line">        path.add(s);    </span><br><span class="line">        visit.add(s);</span><br><span class="line">        <span class="keyword">if</span>(s.equals(end))&#123;      <span class="comment">//找到终点</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            ans = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++)&#123;   <span class="comment">//遍历所有存在的节点</span></span><br><span class="line">            <span class="keyword">if</span>(isConnect(s, wordList.get(i)))&#123;      <span class="comment">//如果与当前节点连通，则递归下去</span></span><br><span class="line">                dfs(wordList.get(i),path,end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);         <span class="comment">//回溯，临时路径中删除访问的节点</span></span><br><span class="line">        visit.remove(s);                    <span class="comment">//回溯，访问节点置为未访问</span></span><br><span class="line">        unable.add(s);                      <span class="comment">//回溯时保存当前节点，该节点之后的通路均不满足题意</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnect</span><span class="params">(String start, String end)</span></span>&#123;  <span class="comment">//用于判断两个节点之间是否连通，即start和end字符串之间只有一个字符不同</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start.charAt(i)!=end.charAt(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="17-23-最大黑方阵"><a href="#17-23-最大黑方阵" class="headerlink" title="17.23. 最大黑方阵"></a>17.23. 最大黑方阵</h3><p>给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。</p>
<p>返回一个数组 [r, c, size] ，其中 r, c 分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>matrix.length == matrix[0].length &lt;= 200</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] down;</span><br><span class="line">    <span class="keyword">int</span>[][] right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findSquare(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        down = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        right = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            down[n - <span class="number">1</span>][i] = matrix[n - <span class="number">1</span>][i] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            right[i][n - <span class="number">1</span>] = matrix[i][n - <span class="number">1</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = matrix[i][j] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                    down[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                down[i][j] = down[i + <span class="number">1</span>][j] + x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = matrix[i][j] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                    right[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>] + x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> cur = maxSize(matrix, i, j);</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; res[<span class="number">2</span>]) &#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                    res[<span class="number">2</span>] = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">2</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到最大边长</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSize</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = Math.min(down[x][y], right[x][y]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right[x + i - <span class="number">1</span>][y] &gt;= i &amp;&amp; down[x][y + i - <span class="number">1</span>] &gt;= i) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<h3 id="17-24-最大子矩阵"><a href="#17-24-最大子矩阵" class="headerlink" title="17.24. 最大子矩阵"></a>17.24. 最大子矩阵</h3><p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
<p>注意：本题相对书上原题稍作改动</p>
<p><strong>说明：</strong></p>
<ul>
<li><code>1 &lt;= matrix.length, matrix[0].length &lt;= 200</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMaxMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//二维前缀和</span></span><br><span class="line">        <span class="keyword">int</span>[][] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j ++) &#123;</span><br><span class="line">                preSum[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + preSum[i - <span class="number">1</span>][j] + preSum[i][j - <span class="number">1</span>] - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始最大子序和</span></span><br><span class="line">        <span class="keyword">int</span> gobalMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//先固定上下两条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> top = <span class="number">0</span>; top &lt; n; top ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> bottom = top; bottom &lt; n; bottom ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> localMax = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//然后从左往右一遍扫描找最大子序和</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; m; right ++) &#123;</span><br><span class="line">                    <span class="comment">//利用presum快速求出localMax</span></span><br><span class="line">                    localMax = preSum[bottom + <span class="number">1</span>][right + <span class="number">1</span>] + preSum[top][left] - preSum[bottom + <span class="number">1</span>][left] - preSum[top][right + <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//如果比gobal大，更新</span></span><br><span class="line">                    <span class="keyword">if</span>(gobalMax &lt; localMax) &#123;</span><br><span class="line">                        gobalMax = localMax;</span><br><span class="line">                        ret[<span class="number">0</span>] = top;</span><br><span class="line">                        ret[<span class="number">1</span>] = left;</span><br><span class="line">                        ret[<span class="number">2</span>] = bottom;</span><br><span class="line">                        ret[<span class="number">3</span>] = right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果不满0，前面都舍弃，从新开始计算，left更新到right+1，right下一轮递增之后left==right</span></span><br><span class="line">                    <span class="keyword">if</span>(localMax &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        localMax = <span class="number">0</span>;</span><br><span class="line">                        left = right + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-25-单词矩阵"><a href="#17-25-单词矩阵" class="headerlink" title="17.25. 单词矩阵"></a>17.25. 单词矩阵</h3><p>给定一份单词的清单，设计一个算法，创建由字母组成的面积最大的矩形，其中每一行组成一个单词(自左向右)，每一列也组成一个单词(自上而下)。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。</p>
<p>如果有多个面积最大的矩形，输出任意一个均可。一个单词可以重复使用。</p>
<p><strong>说明：</strong></p>
<ul>
<li><code>words.length &lt;= 1000</code></li>
<li><code>words[i].length &lt;= 100</code></li>
<li>数据保证单词足够随机</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">        Trie[] childs;</span><br><span class="line">        <span class="keyword">boolean</span> isLeaf;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">            childs = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trie root;</span><br><span class="line">    Map&lt;Integer, Set&lt;String&gt;&gt; map;  <span class="comment">//把清单根据单词长度集合起来</span></span><br><span class="line">    <span class="keyword">int</span> maxArea;</span><br><span class="line">    <span class="keyword">int</span> maxLength;</span><br><span class="line">    List&lt;String&gt; ans;   <span class="comment">//别忘最后转换成数组输出</span></span><br><span class="line">    <span class="keyword">public</span> String[] maxRectangle(String[] words) &#123;       </span><br><span class="line">        root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="comment">//构造字典树</span></span><br><span class="line">        <span class="keyword">for</span>(String str: words)&#123;</span><br><span class="line">            Trie node = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.childs[c-<span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.childs[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.childs[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            node.isLeaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        maxArea = <span class="number">0</span>;</span><br><span class="line">        maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String w: words)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = w.length();</span><br><span class="line">            maxLength = Math.max(maxLength, len);</span><br><span class="line">            Set&lt;String&gt; set = map.getOrDefault(len, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            set.add(w);</span><br><span class="line">            map.put(len, set);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key: map.keySet())&#123;</span><br><span class="line">            path.clear();</span><br><span class="line">            <span class="comment">//回溯需要的参数是：相同长度单词的集合，存放路径的列表，当前单词的长度</span></span><br><span class="line">            dfs(map.get(key), path, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] ultimate = <span class="keyword">new</span> String[ans.size()];</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(ultimate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回溯的“套路”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Set&lt;String&gt; dic, List&lt;String&gt; path, <span class="keyword">int</span> wordLen)</span></span>&#123;</span><br><span class="line">        <span class="comment">//剪枝，dic里的情况不可能得到最优解，提前过滤掉不考虑</span></span><br><span class="line">        <span class="keyword">if</span>(wordLen*maxLength &lt;= maxArea)   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止条件：如果path矩阵的高度已经超过清单中最长单词长度，结束</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; maxLength) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String str: dic)&#123;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            path.add(str);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span>[] res = isValid(path);</span><br><span class="line">            <span class="keyword">if</span>(res[<span class="number">0</span>])&#123; <span class="comment">//下面还可以再加</span></span><br><span class="line">                <span class="keyword">int</span> area = path.size()*path.get(<span class="number">0</span>).length();</span><br><span class="line">                <span class="keyword">if</span>(res[<span class="number">1</span>] &amp;&amp; (area&gt;maxArea))&#123;   <span class="comment">//每列都是单词的矩阵</span></span><br><span class="line">                    maxArea = area;</span><br><span class="line">                    <span class="comment">//ans = path;   一定注意这里不能直接把path引用交给答案</span></span><br><span class="line">                    ans = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                dfs(dic, path, wordLen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断一个矩阵是否每一列形成的单词都在清单里</span></span><br><span class="line"><span class="comment">    *   存在两种情况：1.有的列中的字母不在字典树中，即这一列不可能构成单词，整个矩阵不合要求</span></span><br><span class="line"><span class="comment">    *   2.每列的所有字母都在字典树中但有的结尾不是leaf，也就是有的列目前还不是个单词</span></span><br><span class="line"><span class="comment">    *   所以需要一个boolean数组res[]来存放结果：</span></span><br><span class="line"><span class="comment">    *   res[0]表示是否有字母不在字典树中，true:都在，false:有不在的</span></span><br><span class="line"><span class="comment">    *   res[1]表示是否所有的列都构成了清单里的单词</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] isValid(List&lt;String&gt; input)&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">boolean</span> allLeaf = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = input.size();</span><br><span class="line">        <span class="keyword">int</span> n = input.get(<span class="number">0</span>).length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="comment">//按列来看单词是否在字典树</span></span><br><span class="line">            Trie node = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> c = input.get(i).charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.childs[c] == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[]&#123;<span class="keyword">false</span>, <span class="keyword">false</span>&#125;;</span><br><span class="line">                node = node.childs[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!node.isLeaf)    allLeaf = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[]&#123;<span class="keyword">true</span>, allLeaf&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>

<hr>
<h3 id="17-26-稀疏相似度"><a href="#17-26-稀疏相似度" class="headerlink" title="17.26. 稀疏相似度"></a>17.26. 稀疏相似度</h3><p>两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常“稀疏”，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。</p>
<p>输入为一个二维数组 docs，docs[i] 表示 id 为 i 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 {id1},{id2}: {similarity}，其中 id1 为两个文档中较小的 id，similarity 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>docs.length &lt;= 500</code></li>
<li><code>docs[i].length &lt;= 500</code></li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开/折叠</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">computeSimilarities</span><span class="params">(<span class="keyword">int</span>[][] docs)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] help = <span class="keyword">new</span> <span class="keyword">int</span>[docs.length][docs.length];</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; docs.length; i++) &#123;</span><br><span class="line">            <span class="comment">//i:文档id</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; docs[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> key = docs[i][j];</span><br><span class="line">                List&lt;Integer&gt; list = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    map.put(key,list);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Integer k : list) &#123;</span><br><span class="line">                        help[i][k]++;<span class="comment">//记录文档id为i与k的交集个数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//文档id为i的文档已经处理完，统计id为i的文档与id小于i的文档之间的稀疏度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; help.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (help[i][k] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    String cur = k + <span class="string">&quot;,&quot;</span> + i + <span class="string">&quot;: &quot;</span> + String.format(<span class="string">&quot;%.4f&quot;</span>,(<span class="keyword">double</span>)help[i][k] / (docs[i].length + docs[k].length - help[i][k]));</span><br><span class="line">                    ans.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
    </div>

    
    
    
      
  <div class="popular-posts-header">你可能感兴趣的相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2021\12\30\leetCode刷题笔记\" rel="bookmark">leetCode刷题笔记</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>感谢您的支持，这将鼓励我继续努力创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="曾超 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="曾超 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>曾超
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zengc0905.github.io/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典">http://zengc0905.github.io/2022/04/30/程序员面试金典/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>

      

      <div>
        
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

        
      </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/15/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Netty学习笔记">
      <i class="fa fa-chevron-left"></i> Netty学习笔记
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8"><span class="nav-text">程序员面试金典</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#001-050"><span class="nav-text">001 - 050</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01-01-%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80"><span class="nav-text">01.01. 判定字符是否唯一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-02-%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92"><span class="nav-text">01.02. 判定是否互为字符重排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-03-URL%E5%8C%96"><span class="nav-text">01.03. URL化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-04-%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97"><span class="nav-text">01.04.回文排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-05-%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91"><span class="nav-text">01.05. 一次编辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9"><span class="nav-text">01.06. 字符串压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-07-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="nav-text">01.07. 旋转矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-08-%E9%9B%B6%E7%9F%A9%E9%98%B5"><span class="nav-text">01.08. 零矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01-09-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC"><span class="nav-text">01.09. 字符串轮转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="nav-text">02.01. 移除重复节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-text">02.02. 返回倒数第k个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-03-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="nav-text">02.03. 删除中间节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-04-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8"><span class="nav-text">02.04. 分割链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-05-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C"><span class="nav-text">02.05. 链表求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-06-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-text">02.06. 回文链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="nav-text">02.07. 链表相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-08-%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B"><span class="nav-text">02.08. 环路检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#02-03-%E4%B8%89%E5%90%88%E4%B8%80"><span class="nav-text">02.03. 三合一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#03-02-%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">03.02. 栈的最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#03-03-%E5%A0%86%E7%9B%98%E5%AD%90"><span class="nav-text">03.03. 堆盘子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#03-04-%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F"><span class="nav-text">03.04. 化栈为队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#03-05-%E6%A0%88%E6%8E%92%E5%BA%8F"><span class="nav-text">03.05. 栈排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#03-06-%E5%8A%A8%E7%89%A9%E6%94%B6%E5%AE%B9%E6%89%80"><span class="nav-text">03.06. 动物收容所</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-01-%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF"><span class="nav-text">04.01. 节点间通路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-02-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91"><span class="nav-text">04.02. 最小高度树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-03-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8"><span class="nav-text">04.03. 特定深度节点链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-04-%E6%A3%80%E6%9F%A5%E5%B9%B3%E8%A1%A1%E6%80%A7"><span class="nav-text">04.04. 检查平衡性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-05-%E5%90%88%E6%B3%95%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">04.05. 合法搜索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-06-%E5%90%8E%E7%BB%A7%E8%80%85"><span class="nav-text">04.06. 后继者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-08-%E9%A6%96%E4%B8%AA%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88"><span class="nav-text">04.08. 首个共同祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-09-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BA%8F%E5%88%97"><span class="nav-text">04.09. 二叉搜索树序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-10-%E6%A3%80%E6%9F%A5%E5%AD%90%E6%A0%91"><span class="nav-text">04.10. 检查子树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#04-12-%E6%B1%82%E5%92%8C%E8%B7%AF%E5%BE%84"><span class="nav-text">04.12. 求和路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-01-%E6%8F%92%E5%85%A5"><span class="nav-text">05.01. 插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-02-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">05.02. 二进制数转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-03-%E7%BF%BB%E8%BD%AC%E6%95%B0%E4%BD%8D"><span class="nav-text">05.03. 翻转数位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-04-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%95%B0"><span class="nav-text">05.04. 下一个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-06-%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="nav-text">05.06. 整数转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-07-%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%8D%A2"><span class="nav-text">05.07. 配对交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#05-08-%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF"><span class="nav-text">05.08. 绘制直线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-01-%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">08.01. 三步问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-02-%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="nav-text">08.02. 迷路的机器人</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-03-%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95"><span class="nav-text">08.03. 魔术索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-04-%E5%B9%82%E9%9B%86"><span class="nav-text">08.04. 幂集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-05-%E9%80%92%E5%BD%92%E4%B9%98%E6%B3%95"><span class="nav-text">08.05. 递归乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-06-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="nav-text">08.06. 汉诺塔问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-07-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-text">08.07. 无重复字符串的排列组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-08-%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-text">08.08. 有重复字符串的排列组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-09-%E6%8B%AC%E5%8F%B7"><span class="nav-text">08.09.  括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-10-%E9%A2%9C%E8%89%B2%E5%A1%AB%E5%85%85"><span class="nav-text">08.10. 颜色填充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-11-%E7%A1%AC%E5%B8%81"><span class="nav-text">08.11. 硬币</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-12-%E5%85%AB%E7%9A%87%E5%90%8E"><span class="nav-text">08.12. 八皇后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-13-%E5%A0%86%E7%AE%B1%E5%AD%90"><span class="nav-text">08.13. 堆箱子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#08-14-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97"><span class="nav-text">08.14. 布尔运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-01-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-text">10.01. 合并排序的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-02-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84"><span class="nav-text">10.02. 变位词组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-03-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-text">10.03. 搜索旋转数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-05-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E6%90%9C%E7%B4%A2"><span class="nav-text">10.05. 稀疏数组搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-09-%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E6%89%BE"><span class="nav-text">10.09. 排序矩阵查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-10-%E6%95%B0%E5%AD%97%E6%B5%81%E7%9A%84%E7%A7%A9"><span class="nav-text">10.10 数字流的秩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-11-%E5%B3%B0%E4%B8%8E%E8%B0%B7"><span class="nav-text">10.11. 峰与谷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-01-%E4%BA%A4%E6%8D%A2%E6%95%B0%E5%AD%97"><span class="nav-text">16.01. 交换数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-02-%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87"><span class="nav-text">16.02. 单词频率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-03-%E4%BA%A4%E7%82%B9"><span class="nav-text">16.03. 交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-04-%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="nav-text">16.04. 井字游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-05-%E9%98%B6%E4%B9%98%E5%B0%BE%E6%95%B0"><span class="nav-text">16.05. 阶乘尾数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-06-%E6%9C%80%E5%B0%8F%E5%B7%AE"><span class="nav-text">16.06. 最小差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-07-%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC"><span class="nav-text">16.07. 最大数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-08-%E6%95%B4%E6%95%B0%E7%9A%84%E8%8B%B1%E8%AF%AD%E8%A1%A8%E7%A4%BA"><span class="nav-text">16.08. 整数的英语表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-09-%E8%BF%90%E7%AE%97"><span class="nav-text">16.09. 运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-10-%E7%94%9F%E5%AD%98%E4%BA%BA%E6%95%B0"><span class="nav-text">16.10. 生存人数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-11-%E8%B7%B3%E6%B0%B4%E6%9D%BF"><span class="nav-text">16.11. 跳水板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-13-%E5%B9%B3%E5%88%86%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-text">16.13. 平分正方形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-14-%E6%9C%80%E4%BD%B3%E7%9B%B4%E7%BA%BF"><span class="nav-text">16.14. 最佳直线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-15-%E7%8F%A0%E7%8E%91%E5%A6%99%E7%AE%97"><span class="nav-text">16.15. 珠玑妙算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-16-%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F"><span class="nav-text">16.16. 部分排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-17-%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-text">16.17. 连续序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-18-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text">16.18. 模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-19-%E6%B0%B4%E5%9F%9F%E5%A4%A7%E5%B0%8F"><span class="nav-text">16.19. 水域大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-20-T9%E9%94%AE%E7%9B%98"><span class="nav-text">16.20. T9键盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-21-%E4%BA%A4%E6%8D%A2%E5%92%8C"><span class="nav-text">16.21. 交换和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-22-%E5%85%B0%E9%A1%BF%E8%9A%82%E8%9A%81"><span class="nav-text">16.22. 兰顿蚂蚁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-24-%E6%95%B0%E5%AF%B9%E5%92%8C"><span class="nav-text">16.24. 数对和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-25-LRU%E7%BC%93%E5%AD%98"><span class="nav-text">16.25. LRU缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-26-%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-text">16.26. 计算器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-01-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%8F%B7%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="nav-text">17.01 不用加号的加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-04-%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">17.04. 消失的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-05-%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97"><span class="nav-text">17.05. 字母与数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-06-2-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text">17.06.2. 出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-07-%E5%A9%B4%E5%84%BF%E5%90%8D%E5%AD%97"><span class="nav-text">17.07. 婴儿名字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-08-%E9%A9%AC%E6%88%8F%E5%9B%A2%E4%BA%BA%E5%A1%94"><span class="nav-text">17.08. 马戏团人塔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-09-%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="nav-text">17.09. 第k个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-10-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0"><span class="nav-text">17.10. 主要元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-11-%E5%8D%95%E8%AF%8D%E8%B7%9D%E7%A6%BB"><span class="nav-text">17.11. 单词距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-12-BiNode"><span class="nav-text">17.12. BiNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-13-%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC"><span class="nav-text">17.13. 恢复空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-14-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0"><span class="nav-text">17.14 最小k个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-15-%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D"><span class="nav-text">17.15. 最长单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-16-%E6%8C%89%E6%91%A9%E5%B8%88"><span class="nav-text">17.16. 按摩师</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-17-%E5%A4%9A%E6%AC%A1%E6%90%9C%E7%B4%A2"><span class="nav-text">17.17. 多次搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-18-%E6%9C%80%E7%9F%AD%E8%B6%85%E4%B8%B2"><span class="nav-text">17.18. 最短超串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-text">17.19. 消失的两个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-20-%E8%BF%9E%E7%BB%AD%E4%B8%AD%E5%80%BC"><span class="nav-text">17.20. 连续中值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-21-%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F"><span class="nav-text">17.21. 直方图的水量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-22-%E5%8D%95%E8%AF%8D%E8%BD%AC%E6%8D%A2"><span class="nav-text">17.22. 单词转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-23-%E6%9C%80%E5%A4%A7%E9%BB%91%E6%96%B9%E9%98%B5"><span class="nav-text">17.23. 最大黑方阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-24-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="nav-text">17.24. 最大子矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-25-%E5%8D%95%E8%AF%8D%E7%9F%A9%E9%98%B5"><span class="nav-text">17.25. 单词矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-26-%E7%A8%80%E7%96%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6"><span class="nav-text">17.26. 稀疏相似度</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="曾超"
      src="/images/zc1.jpg">
  <p class="site-author-name" itemprop="name">曾超</p>
  <div class="site-description" itemprop="description">天天经过小巷，乱花漫了高墙，贪看蜂狂蝶舞，忘了世态炎凉</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zengc0905" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zengc0905" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_42403109" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42403109" rel="noopener external nofollow noreferrer" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




      
        <div class="links-of-blogroll motion-element links-of-blogroll-block">
          <div class="links-of-blogroll-title">
            <!-- modify icon to fire by szw -->
            <i class="fa fa-history fa-" aria-hidden="true"></i>
            近期文章
          </div>
          <ul class="links-of-blogroll-list">
            
            
              <li>
                <a href="/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典" target="_blank">程序员面试金典</a>
              </li>
            
              <li>
                <a href="/2022/04/15/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Netty学习笔记" target="_blank">Netty学习笔记</a>
              </li>
            
              <li>
                <a href="/2022/03/15/ssm%E6%A1%86%E6%9E%B6/" title="ssm框架" target="_blank">ssm框架</a>
              </li>
            
              <li>
                <a href="/2022/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="操作系统学习笔记" target="_blank">操作系统学习笔记</a>
              </li>
            
              <li>
                <a href="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JUC知识点整理" target="_blank">JUC知识点整理</a>
              </li>
            
          </ul>
        </div>
     


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      <!--网易云音乐播放器-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1397105439&auto=1&height=66"></iframe>
    </div> 
  </aside>
 
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">曾超</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">786k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:55</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='250,190,19' opacity='1' zIndex='-1' count='200' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/czqtxhzy1fbjx1x9grskpzvbfeb7kas3.js"></script>







  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DaPWqMMMhvWr1vm4g7PhVmOg-gzGzoHsz',
      appKey     : 'n6bU0IPWvniadHKWAeJcNV43',
      placeholder: "欢迎大家各抒己见!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<span style="color:#333333">

  
	<script src="/js/cursor/fairyDustCursor.js"></script>
  
  
    <script src="/js/cursor/fireworks.js"></script> 
  
</span>



  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = true;
    document.body.addEventListener('input', POWERMODE);
  </script>



<script type="text/javascript" src="/js/fold_action.js"></script>

<!--   -->

  
    <script src="/js/cursor/fireworks.js"></script>
  



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>

</html>
<!-- 页面点击小红心 -->
<!--<script type="text/javascript" src="/js/src/clicklove.js"></script>-->
