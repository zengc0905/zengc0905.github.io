<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/dataphin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/dataphin.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zengc0905.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="java并发编程相关知识点总结">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC知识点整理">
<meta property="og:url" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="曾超の博客">
<meta property="og:description" content="java并发编程相关知识点总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/xLCHgvdv8ixWWeAKSv6TlKnpdqfISaKu7A7qSkgyIXM.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/ujDTPKLOT7i4CG6RgaucGr5WzDRpdRn0PhIFEx8vjO4.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/pUeGYMe3BTDrY9B9yBDqyytH7bhSqjg4DVL8Xj23ahk.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/MJUU31ldtjiMX6OOCZYbQK4ldE00GKu7becOQ0LMOEM.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/VvOQua5oFcA0U0dfm-PyY1Fl5_wtvAYpbMfmFN8RQIo.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/s42xOelrXf7Q0YXTu7CDI-16w03-kldh2kguRy_c92A.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/mIFx8w6MjuJDCk5AfVYM025ug8W9mIiPsHerU4yGL9g.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/bPs3CKEBXqtDXKPsvQdOg3NjY16CDqxBcVldrsgfUJg.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/Zkxj7KXyIcO-hfxIzuMEvwT8LNJIz1N4lF2lmtloQ_A.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/klFuDatAZhT0Se7g5rwpoI1C9vp_CGSqaIVpSY2H4g0.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/B6zPlj6Bu64XyVBInrdsq6d7eTEu_zsvDBImgfqx72Y.png">
<meta property="og:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/b735fhN9fQkJf5d-lfL6tswXwwTXOcDJZtwUMRZ0uH0.png">
<meta property="article:published_time" content="2022-01-29T05:14:56.000Z">
<meta property="article:modified_time" content="2022-04-20T12:21:43.862Z">
<meta property="article:author" content="曾超">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/xLCHgvdv8ixWWeAKSv6TlKnpdqfISaKu7A7qSkgyIXM.png">

<link rel="canonical" href="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JUC知识点整理 | 曾超の博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-PLK3B9Z0FG"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-PLK3B9Z0FG');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="曾超の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <!--
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>
   -->

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">曾超の博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录日常的学习与生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zc1.jpg">
      <meta itemprop="name" content="曾超">
      <meta itemprop="description" content="天天经过小巷，乱花漫了高墙，贪看蜂狂蝶舞，忘了世态炎凉">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曾超の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC知识点整理
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-29 13:14:56" itemprop="dateCreated datePublished" datetime="2022-01-29T13:14:56+08:00">2022-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-20 20:21:43" itemprop="dateModified" datetime="2022-04-20T20:21:43+08:00">2022-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>
            <div class="post-description">java并发编程相关知识点总结</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a><strong>线程基础</strong></h1><h2 id="Java线程有哪几种状态"><a href="#Java线程有哪几种状态" class="headerlink" title="Java线程有哪几种状态"></a><strong>Java线程有哪几种状态</strong></h2><p>Java线程状态可以通过<code>Thread.getState()</code> 来获取。<code>Thread.State</code> 是一个枚举类型，共有6大状态。</p>
<ol>
<li><strong>NEW</strong>：线程被创建后，处于该状态，生命周期内只有一次</li>
<li><strong>RUNNABLE</strong>：复合状态，包含两个子状态<ol>
<li><strong>READY</strong>：可被调度，使之处于RUNNING状态</li>
<li><strong>RUNNING</strong>：线程正在运行，即线程对应的run方法正在由处理器执行</li>
<li>执行<code>Thread.yield()</code> ，RUNNING状态线程可能会转换成READY</li>
</ol>
</li>
<li><strong>BLOCKED</strong>：线程发起BIO操作，或者申请一个由其他线程持有的独占资源时，就会处于该状态。处于该状态不会占用处理器资源。当BIO操作完成，或获取了指定资源，又可以转换成RUNNABLE状态。</li>
<li><strong>WAITING</strong>：等待其他线程执行特定操作的状态<ol>
<li>变为WAITING：Object.wait()，Thread.join()，LockSupport.park()</li>
<li>变为RUNNABLE：Object.notify()/notifyAll()，LockSupport.unpark()</li>
</ol>
</li>
<li><strong>TIMED_WAITING</strong>：和WAITING类似，但该状态的等待是有时间限制了，超时后会自动转换为RUNNABLE</li>
<li><strong>TERMINATED</strong>：已经执行结束的线程会处于该状态，由于一个线程实例只能够被启动一次，因此一个线程生命周期内只有一次处于该状态。</li>
</ol>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/xLCHgvdv8ixWWeAKSv6TlKnpdqfISaKu7A7qSkgyIXM.png" alt="image"></p>
<h2 id="Java中创建线程的几种方式"><a href="#Java中创建线程的几种方式" class="headerlink" title="Java中创建线程的几种方式"></a><strong>Java中创建线程的几种方式</strong></h2><ol>
<li><strong>继承Thread类</strong><ol>
<li>继承Thread类，重写run方法</li>
<li>创建对象，调用start方法启动线程</li>
</ol>
</li>
<li><strong>实现Runnable接口</strong><ol>
<li>定义一个类实现Runnable接口，并实现run方法</li>
<li>创建Runnable对象，作为参数传入Thread构造函数</li>
<li>调用start方法启动线程</li>
</ol>
</li>
<li><strong>实现Callable接口</strong><ol>
<li>定义一个类实现Callable接口，并实现call方法</li>
<li>创建Calllable对象，作为参数传入FutureTask构造函数</li>
<li>把FutureTask作为参数传入Thread类构造函数，创建Thread</li>
<li>调用start方法启动线程</li>
</ol>
</li>
<li><strong>通过线程池提交Runnable对象</strong></li>
</ol>
<h2 id="继承Thread类和实现Runaable接口的区别"><a href="#继承Thread类和实现Runaable接口的区别" class="headerlink" title="继承Thread类和实现Runaable接口的区别"></a><strong>继承Thread类和实现Runaable接口的区别</strong></h2><p>通过继承Thread类实现多线程，则必须重写run()方法，其底层实际调用的是Runnable接口中的run()方法。</p>
<h2 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a><strong>wait和sleep的区别</strong></h2><p><strong>wait</strong></p>
<ul>
<li>配合synchronized使用  –》 waitSet</li>
<li><strong>释放其持有的锁</strong></li>
<li>Object类的<strong>非静态方法</strong></li>
<li>通过notify或者notifyAll唤醒</li>
<li>用于线程通信</li>
</ul>
<p><strong>sleep</strong></p>
<ul>
<li>任意地方都可以调用</li>
<li><strong>不会释放当前线程持有的锁</strong></li>
<li>Thread类的<strong>静态方法</strong></li>
<li>用于执行暂停</li>
</ul>
<p><strong>相同点</strong></p>
<ul>
<li><strong>都会让出CPU</strong></li>
<li>都会进入WAITING或者TIMED_WAITING状态</li>
</ul>
<blockquote>
<p>sleep/yeild/wait/join的区别</p>
</blockquote>
<ul>
<li>sleep 不释放锁、释放cpu</li>
<li>join 释放锁、抢占cpu</li>
<li>yiled 不释放锁、释放cpu  –&gt;让出cpu执行权</li>
<li>wait 释放锁、释放cpu</li>
</ul>
<h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a><strong>wait和notify</strong></h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a><strong>wait</strong></h3><ol>
<li>线程调用锁对象的wait方法，那么线程会释放该锁，进入到锁对象的WaitSet中，线程状态变为WAITING/TIMED_WAITING</li>
</ol>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a><strong>notify</strong></h3><ol>
<li>线程调用锁对象的notify，JVM会唤醒WaitSet中的某一个线程，尝试获取锁对象</li>
<li>线程调用锁对象的notifyAll，JVM会唤醒WaitSet中的所有线程，并发获取锁对象</li>
</ol>
<h2 id="start和run方法的作用"><a href="#start和run方法的作用" class="headerlink" title="start和run方法的作用"></a><strong>start和run方法的作用</strong></h2><p> 调用 <code>start()</code> 方法会启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行，会被当成是一个普通方法执行。</p>
<h2 id="线程在什么情况下会中断"><a href="#线程在什么情况下会中断" class="headerlink" title="线程在什么情况下会中断"></a><strong>线程在什么情况下会中断</strong></h2><ul>
<li><p>stop等方法已经弃用，stop会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁。</p>
</li>
<li><p>使用System.exit(int)方法停止线程，目的仅是停止一个线程，但这种做法会让整个程序都停止。</p>
</li>
<li><p>当请求一个线程中断时，可以通过设置目标线程的中断标志位进行操作</p>
</li>
<li><p>使用interrupt()方法</p>
</li>
</ul>
<p>中断在java中主要有3个方法，interrupt(),isInterrupted()和interrupted()。</p>
<ul>
<li>interrupt()，在一个线程中调用另一个线程的interrupt()方法，即会向那个线程发出信号——线程中断状态已被设置。至于那个线程何去何从，由具体的代码实现决定。<ul>
<li>如果一个线程<strong>正在运行中</strong>被打断，打断标记会被置为<strong>true</strong></li>
<li>如果是打断因sleep wait join方法而<strong>被阻塞的线程</strong>，会将打断标记置为<strong>false</strong>,<strong>同时抛出异常</strong></li>
</ul>
</li>
<li>isInterrupted()，用来判断当前线程的中断状态(true or false)。</li>
<li>interrupted()是个Thread的static方法，用来恢复中断状态。</li>
</ul>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a><strong>线程安全问题</strong></h1><h2 id="Java如何保证线程安全（Java多线程的三大特性）"><a href="#Java如何保证线程安全（Java多线程的三大特性）" class="headerlink" title="Java如何保证线程安全（Java多线程的三大特性）"></a><strong>Java如何保证线程安全（Java多线程的三大特性）</strong></h2><p><strong>什么是线程不安全？</strong></p>
<p>如果一个资源多个线程持有，就是<strong>共享资源</strong>。</p>
<p>线程安全问题就是当多个线程<strong>同时读写一个共享资源</strong>，并且<strong>没有任何同步措施</strong>时，导致出现脏数据或者其他不可预见的结果的问题。</p>
<p>一个类如果不是线程安全的，就说它在多线程环境下存在线程安全问题。</p>
<p><strong>线程安全问题体现在三方面。</strong></p>
<ol>
<li><p><strong>原子性</strong><br>对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，也就是具有原子性。<br>Java通过两种方式来实现原子性：</p>
<ol>
<li>悲观锁： 使用synchronized和lock</li>
<li>乐观锁：使用CAS：从处理器和内存层面实现原子性</li>
</ol>
</li>
</ol>
<p>i++ 原子类</p>
<ol start="2">
<li><p><strong>可见性</strong><br>可见性就是说当一个线程修改了共享变量的值时，其他线程能够<strong>立刻得知</strong>这个修改。Java内存模型是通过<strong>在变量修改后将新值同步回主内存</strong>，<strong>在变量读取前从主内存刷新变量值</strong>这种<strong>依赖主内存作为传递媒介</strong>的方式来实现可见性的。<br>Java通过volatile、synchronized、final关键字实现可见性。</p>
<ul>
<li>volatile：volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</li>
<li>synchronized：保证了同步块内的变量的可见性</li>
<li>final：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（没有发生逃逸），那么在其他线程中就能看见final字段的值。</li>
</ul>
</li>
<li><p><strong>有序性</strong><br>因为存在“指令重排序”现象和“工作内存与主内存同步延迟”现象，所以会出现无序性。比如双重校验锁加入volatile解决重排序问题就是解决重排序导致的线程安全问题。<br>Java通过synchronized和volatile来实现有序性。</p>
<ul>
<li>volatile：本身就包含了禁止指令重排序的语义</li>
<li>synchronized：synchronzied修饰的同步块只能串行地进入。</li>
</ul>
</li>
</ol>
<h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a><strong>伪共享问题</strong></h2><p>缓存行对应一块内存区域，<strong>里边可能存有多个变量</strong>。当多个线程同时修改一个缓存行里的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有下降。</p>
<h3 id="如何避免伪共享"><a href="#如何避免伪共享" class="headerlink" title="如何避免伪共享"></a><strong>如何避免伪共享</strong></h3><ol>
<li><strong>字节填充</strong>：填充变量所在缓存行，避免多个变量存放在同一个缓存行内</li>
<li>使用@Contended注解</li>
</ol>
<h2 id="什么是死锁以及排查方式"><a href="#什么是死锁以及排查方式" class="headerlink" title="什么是死锁以及排查方式"></a><strong>什么是死锁以及排查方式</strong></h2><p>如果两个或者更多的线程因相互等待对方而被永远暂停（线程的生命周期状态处于BLCOKED或WAITING），就是发生了死锁。</p>
<p><strong>使用jstack</strong>，查看程序的Thread Dump信息，如果程序出现死锁：</p>
<p>会输出：Found one Java-level deadlock</p>
<p><strong>死锁的4个必要条件</strong></p>
<ol>
<li>互斥条件：请求的资源必须是独占的，每个资源一次只能由一个线程使用</li>
<li>不剥夺条件：资源只能由持有线程主动释放，而无法被其他线程抢夺</li>
<li>持有并等待条件：线程需要请求其他资源，但该资源也被其他线程持有，在等待期间，不释放自身原本持有的资源</li>
<li>环路等待条件：各线程获取资源的顺序形成了环形链</li>
</ol>
<p><strong>规避死锁问题的思路</strong></p>
<ol>
<li>粗锁法：使用粗粒度的锁代替多个锁</li>
<li>锁排序法：相关线程使用全局统一的顺序申请锁</li>
<li>给锁申请的时间设置一个超时时间：例如tryLock()</li>
</ol>
<h2 id="互斥与同步的关系"><a href="#互斥与同步的关系" class="headerlink" title="互斥与同步的关系"></a><strong>互斥与同步的关系</strong></h2><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些， 当使用信号量的时候）线程使用。</p>
<p>而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量 （Mutex）和信号量（Semaphore）都是常见的互斥实现方式。</p>
<p>互斥是因，同步是果；互斥是方法，同步是目的。</p>
<h2 id="为什么要线程同步"><a href="#为什么要线程同步" class="headerlink" title="为什么要线程同步"></a><strong>为什么要线程同步</strong></h2><blockquote>
<p>为什么要使用同步</p>
</blockquote>
<p>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<ol>
<li>使用sychronized或者reentrantlock等加互斥锁的方式实现同步<ol>
<li>代码块或者方法执行过程中，不用执行完，可以使用wait和notify来实现线程之间的顺序执行</li>
</ol>
</li>
<li>采用原子操作–&gt;比如给变量使用volatile修饰，同时在其上面进行原子操作（比如赋值）</li>
<li>使用原子变量</li>
</ol>
<h2 id="有序性-happens-before原则"><a href="#有序性-happens-before原则" class="headerlink" title="有序性-happens-before原则"></a><strong>有序性-happens-before原则</strong></h2><p><strong>对共享变量的写操作,对其它线程的读操作可见</strong></p>
<p>为什么需要happens-before： JVM会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，<strong>需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。</strong></p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作。 </li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。 </li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。 </li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作之前。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。 </li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。</li>
</ul>
<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><strong>synchronized关键字</strong></h1><h2 id="为什么Synchronized是重量级锁"><a href="#为什么Synchronized是重量级锁" class="headerlink" title="为什么Synchronized是重量级锁"></a><strong>为什么Synchronized是重量级锁</strong></h2><p>synchronized 利用对象锁，保证了临界区代码的原子性，可以保证在任何时刻只能有一个线程执行被修饰的方法或者代码块。</p>
<p>在JDK6之前，synchronized使用重量级锁实现，其锁对象的对象头中锁标志位10，同时对象头中还包含了指针指向操作系统的monitor的对象。</p>
<p>monitor可以保证在操作系统层进程/线程想要进入monitor临界区时会互斥。锁对象会与monitor进行关联，对象与其 monitor 之间的关系存在多种实现方式，如monitor可以与对象一起创建销毁，但当一个 monitor 被某个线程持有后，它便处于锁定状态。</p>
<p>在JVM中，monitor是使用ObjectMonitor实现的，其包含三个部分：</p>
<ul>
<li>EntrySet</li>
<li>Owner<ul>
<li>指向持有ObjectMonitor对象的线程</li>
</ul>
</li>
<li>WaitSet</li>
</ul>
<blockquote>
<p>重量级锁加锁过程：</p>
</blockquote>
<ul>
<li>当Thread1访问到synchronized(obj)中的共享资源的时候：（此时共享资源还没有被其他线程使用）<ul>
<li>首先让锁对象中的MarkWord和Monitor对象相关联。</li>
<li>当线程获取到对象的monitor, 将锁对象的对象头中的MarkWord的对象状态从01改为10。</li>
<li>进入ObjectMonitor中的Owner 区域并把monitor中的owner变量设置为当前线程</li>
<li>monitor中的计数器count加1（用来作为重入计数）。</li>
</ul>
</li>
<li>另外一个线程想要获取该对象的对象锁<ul>
<li>它会检查obj是否关联了Montior, 此时已经有关联了</li>
<li>它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2); Thread1也会和该Monitor关联，并进入EntrySet中阻塞;</li>
</ul>
</li>
</ul>
<blockquote>
<p>解锁</p>
</blockquote>
<ul>
<li><p>如果owner线程 调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。</p>
</li>
<li><p>当Thread2执行完临界区代码后, Monitor的Owner(所有者)=null, 此时就会通知Monitor中的EntrySet阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者。</p>
</li>
</ul>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/ujDTPKLOT7i4CG6RgaucGr5WzDRpdRn0PhIFEx8vjO4.png" alt="image"></p>
<h2 id="synchronized代码块底层原理（JVM字节码角度）"><a href="#synchronized代码块底层原理（JVM字节码角度）" class="headerlink" title="synchronized代码块底层原理（JVM字节码角度）"></a><strong>synchronized代码块底层原理（JVM字节码角度）</strong></h2><p>从JVM字节码中可知同步语句块的实现使用的是 monitorenter 和 monitorexit 指令。</p>
<ul>
<li>monitorenter指令指向同步代码块的开始位置</li>
<li>monitorexit指令则指明同步代码块的结束位置</li>
</ul>
<p>当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权：</p>
<ul>
<li>当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。</li>
<li>如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor ，重入时计数器的值也会加 1。</li>
<li>倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕<br>当执行完毕时 monitorexit指令被执行，执行线程将释放 monitor并设置计数器值为0 ，其他线程将有机会持有 monitor 。</li>
</ul>
<p>编译器会自动产生一个异常处理器来保证 monitorenter和monitorexit是成对出现的，即使出现异常也会调用monitorexit。</p>
<h2 id="synchronized方法底层原理（JVM字节码角度）"><a href="#synchronized方法底层原理（JVM字节码角度）" class="headerlink" title="synchronized方法底层原理（JVM字节码角度）"></a><strong>synchronized方法底层原理（JVM字节码角度）</strong></h2><p>方法级的同步是隐式，即无需通过字节码指令monitorenter/monitorexit来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor， 然后再执行方法，最后在方法完成时释放monitor。</p>
<h2 id="重量级锁的缺点"><a href="#重量级锁的缺点" class="headerlink" title="重量级锁的缺点"></a><strong>重量级锁的缺点</strong></h2><p>因为监视器锁（monitor）是依赖于底层的<strong>操作系统</strong>的Mutex Lock来实现的，而操作系统实现线程之间的切换时（比如挂起或者唤醒都需要操作系统帮忙）需要从用户态转换到内核态，非常耗性能。在JDK6的时候, 对synchronized进行了优化，引入了轻量级锁，偏向锁, 它们是<strong>在JVM的层面上进行加锁逻辑，</strong>减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a><strong>锁升级</strong></h2><p>总体上来说锁状态升级流程如下： </p>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/pUeGYMe3BTDrY9B9yBDqyytH7bhSqjg4DVL8Xj23ahk.png" alt="image"></p>
<p>这几种状态会随着竞争逐渐升级，但是不会降级。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h2><p>偏向锁的目的是在无竞争情况，消除同步操作，提高程序的运行性能。偏向锁偏向第一个获取对象锁的线程，在接下来的执行过程，只要该对象锁没被其它线程获取，则持有对象锁的线程永远不需要同步。</p>
<ul>
<li><strong>偏向锁适用于存在同步但一直只有一个线程在使用的情况</strong>。偏向锁可以提高带有同步但无竞争的程序性能。</li>
<li><strong>对于锁竞争比较激烈的场合，偏向锁就失效了</strong>，因为这样场合极有可能每次申请锁的线程都是不相同的，偏向模式就是多余的，其中的CAS操作以及锁撤销操作会带来时耗，反而降低了性能。</li>
</ul>
<p>偏向锁在Java 1.6之后是默认启用的。</p>
<h4 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a><strong>加锁流程</strong></h4><p>当线程访问同步块并获取锁时处理流程如下：</p>
<ol>
<li>检查 <code>mark word</code> 的<code>线程 id</code> 。</li>
<li>如果为空则设置 CAS 替换当前线程 id。如果替换成功则获取锁成功，如果失败则撤销偏向锁。</li>
<li>如果不为空则检查 <code>线程 id</code>为是否为本线程。如果是则获取锁成功，如果失败则撤销偏向锁。</li>
</ol>
<p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，只需比对一下 mark word 的线程 id 是否为本线程，如果是则获取锁成功。</p>
<p>如果发生线程竞争发生 2、3 步失败的情况则需要撤销偏向锁。</p>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><ol>
<li>偏向锁的撤销动作必须等待全局安全点</li>
<li>暂停拥有偏向锁的线程（会有一个stop the word影响性能），判断该线程：<ol>
<li>线程已经退出了同步代码块，或者已经不再存活（因为线程不会主动去释放偏向锁），则直接取消偏向锁，变为无锁状态</li>
<li>线程还在同步代码块中，此时将线程的偏向锁升级为轻量级锁</li>
</ol>
</li>
<li>唤醒暂停的线程</li>
</ol>
<blockquote>
<p>特殊情况：</p>
</blockquote>
<ul>
<li>调用 wait/notify 会导致锁膨胀而使用重量级锁</li>
<li>当调用对象的hashcode方法的时候就会撤销这个对象的偏向锁将其恢复成无锁状态</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p>轻量级锁的使用场景:</p>
<ul>
<li>如果一个对象虽然有多个线程要对它进行加锁，但是<strong>加锁的时间是错开的</strong>，那么可以使用轻量级锁来进行优化。</li>
<li>线程A来操作临界区的资源, 给资源加锁,到执行完临界区代码,释放锁的过程, 没有线程来竞争, 此时就可以使用轻量级锁; 如果这期间有线程来竞争的话, 就会升级为重量级锁</li>
</ul>
<h4 id="加锁流程-1"><a href="#加锁流程-1" class="headerlink" title="加锁流程"></a><strong>加锁流程</strong></h4><p>多个线程竞争偏向锁导致偏向锁升级为轻量级锁</p>
<ol>
<li>JVM 在当前线程的栈帧中创建 Lock Reocrd（锁记录），并将锁对象头中的 Mark Word 复制到 Lock Reocrd 中。（这里并不涉及到竞争，只是关联）</li>
<li>线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向 Lock Reocrd 的指针。<ol>
<li>如果成功则获得锁</li>
<li>如果失败则先检查对象的 Mark Word 是否指向当前线程的栈帧<ol>
<li>如果是则说明已经获取锁</li>
<li>否则说明其它线程竞争，抢夺者线程会进行<strong>自旋等待</strong>占有者线程释放锁，若自旋等待成功，则还是轻量级锁，否则该锁就膨胀为重量级锁。此时对象的MarkWord存储的就是指向Monitor的指针，抢夺者线程进入阻塞状态。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/MJUU31ldtjiMX6OOCZYbQK4ldE00GKu7becOQ0LMOEM.png" alt="image"></p>
<p>替换完成后：</p>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/VvOQua5oFcA0U0dfm-PyY1Fl5_wtvAYpbMfmFN8RQIo.png" alt="image"></p>
<h4 id="解锁流程"><a href="#解锁流程" class="headerlink" title="解锁流程"></a><strong>解锁流程</strong></h4><ol>
<li>使用 CAS 操作将 Mark Word 恢复给对象<ol>
<li>成功则释放完成</li>
<li>失败，表示有竞争，说明轻量级锁已经锁膨胀为了重量级锁，则需要在释放锁（将Monitor中的Owner设置为null）的同时需要唤醒被挂起的线程(Monitor的EntrySet)。</li>
</ol>
</li>
</ol>
<p>锁升级后的图：</p>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/s42xOelrXf7Q0YXTu7CDI-16w03-kldh2kguRy_c92A.png" alt="image"></p>
<hr>
<h2 id="Synchronized关键字的三种使用方式"><a href="#Synchronized关键字的三种使用方式" class="headerlink" title="Synchronized关键字的三种使用方式"></a><strong>Synchronized关键字的三种使用方式</strong></h2><h2 id="synchronized可以锁的内容"><a href="#synchronized可以锁的内容" class="headerlink" title="synchronized可以锁的内容"></a>synchronized可以锁的内容</h2><h2 id="Synchronized锁类对象和this的区别"><a href="#Synchronized锁类对象和this的区别" class="headerlink" title="Synchronized锁类对象和this的区别"></a>Synchronized锁类对象和this的区别</h2><ol>
<li>修饰实例方法（加在实例方法上）: 作用于<strong>当前对象实例加锁</strong>，进入同步代码前要获得 当前对象实例的锁</li>
<li>修饰静态方法（加在静态方法上）: 也就是给<strong>当前类加锁。</strong><ol>
<li>给类对象加锁并不会与给其实例对象加锁互斥</li>
</ol>
</li>
<li>修饰代码块 ：指定加锁对象，<strong>对给定对象/类加锁</strong>。<ol>
<li><code>synchronized(this|object)</code> 表示进入同步代码库前要获得给定对象的锁。—&gt;this锁的跟第一种方法效果一样</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 当前 class 的锁—&gt;跟第2种方法效果一样</li>
</ol>
</li>
</ol>
<h2 id="synchronized是否能防止指令重排序"><a href="#synchronized是否能防止指令重排序" class="headerlink" title="synchronized是否能防止指令重排序"></a><strong>synchronized是否能防止指令重排序</strong></h2><p>不能。只有volatile变量能够禁止指令重排。</p>
<p>synchronized能保证每个时刻只有一个线程执行同步代码块，同步代码块内部是可以发生指令重排的，但是其他线程整个代码块都是原子性的，块与块之间是有序可见的。同时其退出代码块时会刷新变量回主内存。</p>
<p>synchronized发生指令重排序的例子就是懒汉式单例时的Double-Checked。</p>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><strong>volatile关键字</strong></h1><h2 id="volatile关键字的原理与作用"><a href="#volatile关键字的原理与作用" class="headerlink" title="volatile关键字的原理与作用"></a><strong>volatile关键字的原理与作用</strong></h2><p>volatile用于保持<strong>内存可见性</strong>和<strong>防止指令重排序</strong>。</p>
<ul>
<li>内存可见性： 所有线程都能看到共享内存的最新状态。</li>
<li>指令重排序：Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。<ul>
<li>典型案例： 懒汉式单例的Double-Checked Locking</li>
</ul>
</li>
</ul>
<blockquote>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
</blockquote>
<p>lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</li>
</ul>
<h2 id="volatile保证变量可见性"><a href="#volatile保证变量可见性" class="headerlink" title="volatile保证变量可见性"></a><strong>volatile保证变量可见性</strong></h2><p>处理器为了提高执行速度，在内存和cpu之间增加增加了多级缓存来实现。而多级缓存会导致数据不一致问题。Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能<strong>出现线程1改了某个变量的值，但是线程2不可见的情况</strong>。</p>
<p>将该变量声明为volatile变量就可以解决。</p>
<p>但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条<strong>lock前缀的指令</strong>，<strong>将这个缓存中的变量回写到系统主存中。</strong></p>
<p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</p>
<p><strong>缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</strong></p>
<p>所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p>
<h2 id="volatile防止指令重排"><a href="#volatile防止指令重排" class="headerlink" title="volatile防止指令重排"></a><strong>volatile防止指令重排</strong></h2><p>volatile关键字通过<strong>内存屏障</strong>来防止指令被重排序。</p>
<ul>
<li>volatile写之前的操作不会被编译器重排序到volatile写之后—-》 不会因为指令重排而覆盖</li>
<li>volatile读之后的操作不会被编译器重排序到volatile读之前 —》不会因为指令重排而而读到后面的数据</li>
<li>当volatile写发生在volatile读之前时，不能重排序</li>
</ul>
<h2 id="为什么volatile不能保证原子性"><a href="#为什么volatile不能保证原子性" class="headerlink" title="为什么volatile不能保证原子性"></a><strong>为什么volatile不能保证原子性</strong></h2><p><strong>volatile关键字使变量的读、写具有了“原子性”。然而这种原子性仅限于变量（包括引用）的读和写，无法涵盖变量上的任何操作</strong>，比如volatile count是原子的，但是count++不是原子的。</p>
<p>被volatile修饰的变量可以保证读取到的值是最新的，但是在上面增加非原子操作，无法保证其原子性。</p>
<p>比如：</p>
<p>volatile i， 有两个线程要i++，i++包含三步，读取、加1、写入。线程A读取到后没有写入就阻塞了，线程B修改完后，根绝volatile可见性，虽然这个值可以被其他线程看到，但是线程A因为已经读到了，所以第一步已经完成了，所以这个可见性来的有点晚，之后线程A继续进行后两步2，将会覆盖掉之前线程B的结果，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p>
<h3 id="volatile典型应用"><a href="#volatile典型应用" class="headerlink" title="volatile典型应用"></a><strong>volatile典型应用</strong></h3><ol>
<li><strong>使用volatile作为状态标志</strong><br>应用程序的某个状态由一个线程设置，其他线程会读取该状态并以该状态作为计算依据。此时使用volatile作为同步机制，就能够通知另外一个线程某种事件，而这些线程又无须因此而使用锁，从而避免锁开销。<ol start="2">
<li>AQS使用一个volatile int类型的变量来标识同步状态state</li>
</ol>
</li>
<li><strong>使用volatile保障可见性</strong><br>多个线程共享一个可变状态变量，其中一个线程更新了该变量后，其他线程在无须加锁的情况下也能够看到新值。</li>
<li><strong>使用volatile变量替代锁</strong>：当多个线程需要共享一个对象时，可以使用volatile修饰该对象，避免锁的使用—》读与写是原子的</li>
<li><strong>防止指令重排： 懒汉式单例的Double-Check锁使用了volatile，禁止指令重排</strong></li>
</ol>
<h2 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="**说说 synchronized 关键字和 volatile 关键字的区别"></a>**说说 synchronized 关键字和 volatile 关键字的区别</h2><p>**<br>**<br>**<br><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而<strong>不是对立的</strong>。</p>
<ul>
<li><strong>本质不同</strong>： synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题</li>
<li><strong>适用范围不同</strong>：<code> volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块。</li>
<li><strong>是否能保证原子性</strong>：<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。 </li>
<li><strong>作用不同</strong>：<code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性以及指令重排，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。 </li>
</ul>
<h1 id="CAS和乐观锁机制"><a href="#CAS和乐观锁机制" class="headerlink" title="CAS和乐观锁机制"></a><strong>CAS和乐观锁机制</strong></h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a><strong>乐观锁和悲观锁</strong></h2><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。一般使用于多写的场景。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号机制和CAS算法实现</strong>。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a><strong>乐观锁的缺点</strong></h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a><strong>ABA问题</strong></h3><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p>使用AtomicStampedReference的<strong>版本号机制可以解决ABA问题</strong></p>
<p>在进行CAS时，不仅携带预期原值，并且携带上一个版本号，如果有线程进行过修改，即使预期原值的没变，也会由于版本号的不同，判断出ABA问题。</p>
<h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a><strong>循环时间长开销大</strong></h3><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a><strong>只能保证一个共享变量的原子操作</strong></h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h2 id="CAS算法—-gt-CAS操作原理与实现"><a href="#CAS算法—-gt-CAS操作原理与实现" class="headerlink" title="CAS算法—&gt;CAS操作原理与实现"></a><strong>CAS算法—&gt;CAS操作原理与实现</strong></h2><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的<strong>变量同步</strong>，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫<strong>非阻塞同步</strong>（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时（即操作期间旧值没有发生变化），CAS通过原子方式用新值B来更新V的值，否则会通过<strong>自旋操作，即不断的重试。</strong></p>
<p><code>CAS</code> 的底层是 操作系统的lock指令，能够保证<code>原子性</code>。</p>
<p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p>
<p>在AQS中通过一个state成员变量来表示同步状态，该成员变量就是使用的CAS来对其进行修改。</p>
<blockquote>
<p>区分一下：自旋和CAS不是同一个东西，CAS只是保证了比较和交换的原子性，当其失败后，会选择自旋来重试。</p>
</blockquote>
<h2 id="CAS与synchronized区别"><a href="#CAS与synchronized区别" class="headerlink" title="CAS与synchronized区别"></a>CAS与synchronized区别</h2><blockquote>
<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>
</blockquote>
<ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行<strong>加锁解锁以及用户态内核态间的切换</strong>操作额外浪费消耗cpu资源；而CAS基于程序实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而<strong>浪费更多的CPU资源</strong>，效率低于synchronized。</li>
<li>在synchronized<strong>锁升级</strong>的时候，抢夺者线程会进行<strong>自旋</strong>等待占有者线程释放锁，若自旋等待成功，则还是轻量级锁，否则该锁就膨胀为重量级锁。此处的<strong>自旋就用到了CAS机制</strong>。</li>
</ol>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<strong>自旋锁使用CAS实现，核心思想是减少线程切换</strong>。</p>
<p>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting，造成CPU的浪费。</p>
<p>JDK1.6引入了自适应的自旋锁，自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。比如，在B线程请求对象锁之前，有线程刚刚自旋成功获得锁，则认为B线程很有可能自旋成功获得该对象锁，给予更多的自旋时间；反之，若对于该对象，很少自旋成功，则减少自旋时间甚至省略自旋过程。有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h3 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a><strong>自旋锁存在的问题</strong></h3><ul>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。<strong>使用不当会造成CPU使用率极高</strong>。</li>
<li>Java实现的<strong>自旋锁不是公平的</strong>，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</li>
<li><strong>自旋锁无法保证可重入</strong></li>
</ul>
<h3 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a><strong>自旋锁的优点</strong></h3><ul>
<li>自旋锁<strong>不会使线程状态发生切换</strong>，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li>
</ul>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><strong>阻塞队列</strong></h1><h2 id="列举几种阻塞队列并对比分析"><a href="#列举几种阻塞队列并对比分析" class="headerlink" title="列举几种阻塞队列并对比分析"></a><strong>列举几种阻塞队列并对比分析</strong></h2><p>阻塞队列常用于生产者消费者问题中，因为其提供了可阻塞插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>
<p>BlockingQueue 是一个接口有 3 个常见的 <code>BlockingQueue</code> 的实现类：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 、<code>PriorityBlockingQueue</code> 。</p>
<ul>
<li><strong>ArrayBlockingQueue</strong><ul>
<li>基于数组的有界队列，并发控制<strong>采用可重入锁</strong>来控制，不管是插入操作还是读取操作都需要获取锁才能操作</li>
<li>可阻塞式的插入删除数据利用Condition（让生产者或者消费者进入condition），有两个队列，notFull–&gt;没有数据了，notEmpty—&gt;队列满了</li>
<li>不能保证队列的公平性（可以设置）</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong><ul>
<li>基于单向链表的队列，可以是无界队列或者有界队列（可以指定大小）</li>
<li>插入和删除数据分别由两个不同的lock来控制线程安全–&gt;每个lock生成一个Condition（notFull,notEmpty）<ul>
<li>两个lock可以提高并发性（避免阻塞于进入阻塞队列）</li>
</ul>
</li>
</ul>
</li>
<li><strong>PriorityBlockingQueue</strong><ul>
<li>支持优先级的无界阻塞队列，可以通过传入Comparator排序</li>
<li>并发控制使用可重入锁</li>
</ul>
</li>
</ul>
<h2 id="手写阻塞队列"><a href="#手写阻塞队列" class="headerlink" title="手写阻塞队列"></a>手写阻塞队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//源码中也是通过数组的形式实现的队列</span></span><br><span class="line">    Object[] queue;</span><br><span class="line">    <span class="comment">//增加volatile保证变量在各个线程之间的可见性</span></span><br><span class="line">    <span class="comment">//head和tail都是在数组中循环的，删除是head，添加是tail，删除并不是真的删除，而是在添加的时候直接覆盖</span></span><br><span class="line">    <span class="comment">//head表示其前面值全部都是可以覆盖的，tail会追在后面把head覆盖掉</span></span><br><span class="line">    <span class="comment">//怎么样保证我们自己想要的值不会被覆盖掉呢？即怎么保证tail逻辑上一定在head后面</span></span><br><span class="line">    <span class="comment">//通过size，如果size为0了我们就让其阻塞住了，不会让tail超过tail的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="keyword">int</span> head,tail,size;</span><br><span class="line">    <span class="comment">//通过final使其不可更改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockQueue</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = cap;</span><br><span class="line">        queue = <span class="keyword">new</span> Object[cap];</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//在try里面放while也是可以catch到异常的</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(size == cap) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为满了，进入等待&quot;</span>);</span><br><span class="line">                <span class="comment">//没有达到“没有满”的标准，所以等待</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue[tail++] = t;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加完成&quot;</span> + t);</span><br><span class="line">            <span class="comment">//%cap 是为了实现队列的循环，每次都是在逻辑上的最末尾添加元素</span></span><br><span class="line">            tail %= cap;</span><br><span class="line">            size++;</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//注意一定要把unlock放到最后面！不要先释放锁再实现其他逻辑</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T res = <span class="keyword">null</span>;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空，进入等待&quot;</span>);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            res = (T) queue[head++];</span><br><span class="line">            System.out.println(<span class="string">&quot;删除完成&quot;</span> + res);</span><br><span class="line">            <span class="comment">//%cap 是为了实现队列的循环，每次都是在逻辑上的头元素索引位置抛出元素</span></span><br><span class="line">            <span class="comment">//这里并不是把之前的元素删除了，只是下次有值进来的时候，会覆盖掉那个值</span></span><br><span class="line">            head %= cap;</span><br><span class="line">            size--;</span><br><span class="line">            notFull.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockQueue&lt;Integer&gt; blockQueue = <span class="keyword">new</span> BlockQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               blockQueue.offer(id);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//                while (true) &#123;</span></span><br><span class="line"> </span><br><span class="line">                blockQueue.poll();</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><strong>线程池</strong></h1><h2 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a><strong>为什么要用线程池？</strong></h2><ol>
<li><strong>降低资源消耗</strong>：线程创建和销毁都会有资源消耗，通过重用降低消耗</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等待线程创建就执行</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池进行统一分配，调优和监控。</li>
</ol>
<h2 id="Java线程池核心参数与工作流程，拒绝策略"><a href="#Java线程池核心参数与工作流程，拒绝策略" class="headerlink" title="Java线程池核心参数与工作流程，拒绝策略"></a><strong>Java线程池核心参数与工作流程，拒绝策略</strong></h2><p><strong>核心参数</strong></p>
<ul>
<li><strong>corePoolSize</strong>：核心线程数，线程池的基本大小，如果调用了线程池的<code>prestartAllCoreThreads()</code> 方法，线程池会提前创建并启动所有基本流程，<strong>默认不会被回收</strong></li>
<li><strong>maximumPoolSize</strong>：最大线程数<ul>
<li>maximumPoolSize - corePoolSize = （可以开启的）救急线程数</li>
<li>在<strong>没有空闲的核心线程</strong>和<strong>任务队列满了</strong>的情况才使用救急线程</li>
</ul>
</li>
<li><strong>workQueue</strong>：任务队列，用于保存等待执行的任务的阻塞队列<ul>
<li><strong>ArrayBlockQueue</strong>：基于数组结构的有界阻塞队列</li>
<li><strong>LinkedBlockQueue</strong>：基于链表结构的阻塞队列</li>
<li><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，每个插入操作必须等待另一个线程调用移除操作，否则插入操作就一直阻塞</li>
<li><strong>PriorityBlockingQueue</strong>：具有优先级的无界阻塞队列</li>
<li><strong>DelayedWorkerQueue</strong>：实现PriorityBlockingQueue的无界队列，创建元素时，可以指定多久才能从队列中获取当前元素，只有延时期满才能从队列中获取</li>
</ul>
</li>
</ul>
<p><strong>其他参数</strong></p>
<ul>
<li><strong>keepAliveTime</strong>：当线程池中的线程数量大于核心线程数时，如果这时没有新任务提交，<strong>核心线程外的线程</strong>不会立即销毁，而是等待时间超过keepAliveTime才会回收销毁</li>
<li><strong>unit</strong>：keepAliveTime参数的时间单位</li>
<li><strong>threadFactory</strong>：给创建的线程起更有意义的名字</li>
<li><strong>handler</strong>：饱和策略，队列和线程池都满了，说明线程池处于饱和状态，就采用饱和策略处理提交的新任务。<ul>
<li><strong>AbortPolicy</strong>：默认、直接抛出异常</li>
<li><strong>CallerRunsPolicy</strong>：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。</li>
<li><strong>DiscardOldestPolicy</strong>：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。</li>
<li><strong>DiscardPolicy</strong>：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。</li>
</ul>
</li>
</ul>
<p><strong>工作流程</strong></p>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/mIFx8w6MjuJDCk5AfVYM025ug8W9mIiPsHerU4yGL9g.png" alt="image"></p>
<ol>
<li>判断核心线程池是否达到核心线程数<ol>
<li>如果不是，创建工作线程执行任务</li>
<li>如果都在执行任务，则执行下一个流程</li>
</ol>
</li>
<li>判断工作队列是否已经满<ol>
<li>如果没满，则提交进工作队列</li>
<li>否则，执行下一个流程</li>
</ol>
</li>
<li>判断线程池的线程是否达到最大线程数<ol>
<li>如果没满，则创建工作线程</li>
<li>否则，交给饱和策略来处理任务</li>
</ol>
</li>
</ol>
<p>本质上没区别</p>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a><strong>线程池的实现原理</strong></h2><p>执行execute方法的流程</p>
<ol>
<li>如果当前运行的工作线程少于corePoolSize，则创建新线程来执行任务，<strong>这一步骤需要获取全局锁</strong></li>
<li>如果允许的线程大于等于corePoolSize，则任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue，则创建新线程来执行任务，这一步需要全局锁</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法</li>
</ol>
<p>工作线程：线程池创建线程时，会将线程Thread封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列中的任务来执行。</p>
<h2 id="Java自带的4种线程池"><a href="#Java自带的4种线程池" class="headerlink" title="Java自带的4种线程池"></a><strong>Java自带的4种线程池</strong></h2><ul>
<li><strong>FixedThreadPool</strong><ul>
<li><code>newFixedThreadPool(int nThreads)</code> </li>
<li><strong>核心线程数和最大线程数</strong>：nThreads</li>
<li><strong>keepAliveTime</strong>：0</li>
<li><strong>任务队列</strong>：LinkedBlockingQueue<ol>
<li>如果当前运行的线程数小于核心线程数，就创建工作线程</li>
<li>如果核心线程已经满了，就加入阻塞队列</li>
<li>当线程池内工作线程执行完任务后，从阻塞队列获取任务</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li>使用了无界队列，不会拒绝任务，可能会导致OOM</li>
<li>最大线程数和保活时间都是无效参数</li>
</ol>
</li>
</ul>
</li>
<li><strong>SingleThreadExecutor</strong><ul>
<li><code>newSingleThreadExecutor()</code> </li>
<li><strong>核心线程数和最大线程数</strong>：1</li>
<li><strong>任务队列</strong>：LinkedBlockingQueue</li>
<li><strong>keepAliveTime</strong>：0<pre><code>1. 如果没有工作线程，创建工作线程执行任务
2. 否则就加入阻塞队列
3. 工作线程执行完任务，从阻塞队列取任务
</code></pre>
</li>
<li><strong>缺点</strong><ol>
<li>使用无界队列，可能导致OOM</li>
</ol>
</li>
</ul>
</li>
<li><strong>CachedThreadPool</strong><ul>
<li><strong>核心线程数</strong>：0</li>
<li><strong>最大线程数</strong>：Integer.MAX_VALUE，无界</li>
<li><strong>keepAliveTime</strong>：60</li>
<li><strong>任务队列</strong>：SynchronousQueue<ol>
<li>首先执行<code>synchronousQueue.offer(Runnable task)</code> 方法，提交任务到任务队列，如果当前线程池中有空闲线程，则offer操作和工作线程的poll操作配对成功，把任务交给空闲工作线程执行</li>
<li>如果线程池为空或没有空闲线程，会创建一个新的工作线程来执行任务</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li>它的核心线程数为0，且最大线程数是无界的，如果主线程提交任务的速度远高于工作线程处理工作的速度，则会不断创建新线程 ，消耗大量CPU资源和内存资源，造成OOM。</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>SychronousQueue 内部没有容器，如果一个任务来了，没有线程去处理，则会将产生任务得线程阻塞住，直到有线程来处理当前任务。</p>
</blockquote>
<ul>
<li><strong>ScheduledThreadPoolExecutor</strong><ul>
<li>核心线程数：自定义</li>
<li>最大线程数：Integer.MAX_VALUE，无界</li>
<li>keepAliveTime：0</li>
<li>任务队列：DelayedWorkerQueue，是无界队列</li>
<li><code>scheduleAtFixedRate</code>，固定频率周期任务，注意一次任务超时，会持续的影响后续的任务周期；</li>
<li><code>scheduleWithFixedDelay</code>，固定延迟周期任务，即每次任务结束后，超时等待固定时间；</li>
</ul>
</li>
</ul>
<h2 id="最大核心线程数怎么定"><a href="#最大核心线程数怎么定" class="headerlink" title="最大核心线程数怎么定"></a><strong>最大核心线程数怎么定</strong></h2><ol>
<li>IO密集型<br>IO密集型任务并不是一直在执行任务，配置尽可能多的线程，2*CPU</li>
<li>CPU密集型<br>CPU+1</li>
<li>理论方案<br>$N_{CPU}$：CPU数量<br>$U_{CPU}$：目标CPU利用率<br>$W/C$：IO时间和CPU计算时间的比例<br>$N_{threads}=N_{CPU}<em>U_{CPU}</em>(1+W/C)$<br> 这个方案偏理论化，线程计算的时间和等待时间在实际开发中就不好确定。</li>
<li>动态配置（不会影响任务执行）<ol>
<li><code>setCorePoolSize</code> <ol>
<li>覆盖原核心线程数</li>
<li>判断新的核心线程数是否小于当前存活工作线程数<ol>
<li>如果小于，回收空闲的工作线程，多余的正在工作的线程也会在之后空闲了进行回收</li>
<li>否则，就看队列中是否有任务，有任务，则创建工作线程进行执行</li>
</ol>
</li>
</ol>
</li>
<li><code>setMaximumPoolSize</code></li>
</ol>
</li>
</ol>
<h2 id="线程池默认的阻塞队列是什么"><a href="#线程池默认的阻塞队列是什么" class="headerlink" title="线程池默认的阻塞队列是什么"></a><strong>线程池默认的阻塞队列是什么</strong></h2><p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/bPs3CKEBXqtDXKPsvQdOg3NjY16CDqxBcVldrsgfUJg.png" alt="image"></p>
<h2 id="核心线程和非核心线程是否有区别"><a href="#核心线程和非核心线程是否有区别" class="headerlink" title="核心线程和非核心线程是否有区别"></a><strong>核心线程和非核心线程是否有区别</strong></h2><ol>
<li>核心线程由corePoolSize决定，非核心线程由最大线程数和非核心线程数决定</li>
<li>如果任务队列使用无界队列，那么就不会创建非核心线程</li>
<li>因为创建工作线程需要获取全局锁，所以在创建核心线程和非核心线程之间加入了阻塞队列这个步骤进行缓冲，尽可能避免获取全局锁。</li>
<li><strong>空闲</strong>的非核心线程，在超过keepAliveTime后都会被回收。</li>
</ol>
<h2 id="线程池里线程报的异常如何抓取，在线程池外捕获"><a href="#线程池里线程报的异常如何抓取，在线程池外捕获" class="headerlink" title="线程池里线程报的异常如何抓取，在线程池外捕获"></a><strong>线程池里线程报的异常如何抓取，在线程池外捕获</strong></h2><ol>
<li>如果使用execute进行提交，其只能传入Runnable接口，应当尽量在其run方法中使用try catch捕获所有异常，execute会报出异常</li>
<li>重写<code>ThreadPoolExecutor.afterExecute</code>方法，处理传递到<code>afterExecute</code> 方法的异常<br>在调用execute方法时，任务会被Worker对象执行，Worker对象内部封装了Thread对象，worker对象调用runWorker方法执行任务<br>正常情况下，runWorker方法就是不断地从任务队列中取任务然后执行。在runWorker里面，调用task.run之后，会调用线程池的 afterExecute(task, thrown) 方法。<br>可以通过重写afterExecute方法，在该方法内部对异常进行处理。</li>
<li>重写Thread类中的<code>UncaughtExceptionHandler</code> ，如果在线程中出现了异常会被传入这个Handler进行处理<br>为Worker线程设置<code>UncaughtExceptionHandler</code> ，在<code>uncaughtException</code> 方法中处理异常<br><code>UncaughtExceptionHandler</code> 是<code>Thread</code>类一个内部类，也是一个函数式接口。<br>内部的<code>uncaughtException</code>是一个处理线程内发生的异常的方法，参数为线程对象t和异常对象e。<br>这种方法只适用于execute方法提交的任务，因为submit方式提交的任务会被包装成FutureTask对象，它会保存这个异常，而不进一步抛出。</li>
<li>使用submit执行任务，利用返回的Future对象的get方法接收抛出的异常<ol>
<li>使用submit方法执行任务时，submit给线程池提交的是FutureTask对象（Callable和Runnable都被封装成了这个），执行的是FutureTask的run方法，在方法执行时，如果发生异常，会被保存在返回Future对象中，而不是抛出。</li>
</ol>
</li>
</ol>
<h2 id="如何得到线程池的异步处理结果？"><a href="#如何得到线程池的异步处理结果？" class="headerlink" title="如何得到线程池的异步处理结果？"></a><strong>如何得到线程池的异步处理结果？</strong></h2><p>FutureTask实现了Future接口和Runnable接口。</p>
<p>可以通过submit方法返回一个futureTask，然后执行futureTask.get()方法。</p>
<p>FutureTask是基于AQS实现的。</p>
<h2 id="定时任务的实现原理"><a href="#定时任务的实现原理" class="headerlink" title="定时任务的实现原理"></a><strong>定时任务的实现原理</strong></h2><ol>
<li>while+sleep<br>如果有很多定时任务，就会存在大量的定时任务线程，线程切换频繁，性能消耗就很大</li>
<li>Timer<br>Timer会起一个TimerTask线程，并维护一个<strong>任务队列</strong>，任务队列的底层实现是一个<strong>最小堆</strong>，TimerThread会负责判断队头任务是否已经到了执行时间点，如果已经到达，就进行执行。<br>相比于第一个方案，Timer使用TimerThread作为管理线程，减少了线程切换的开销。<br>但是由于TimerThread只有一个，长任务就会阻塞短任务的执行，并且没有容错能力，一旦任务出现故障，会影响后续的任务执行。</li>
<li>ScheduledThreadPoolExecutor<br>每个任务都由线程池进行管理，当任务到达执行时间时，就会分配一个线程进行执行</li>
</ol>
<h2 id="execute和submit的区别"><a href="#execute和submit的区别" class="headerlink" title="execute和submit的区别"></a><strong>execute和submit的区别</strong></h2><ol>
<li>execute方法只能接收Runnable对象，且没有返回值<br>submit方法能接收Runnable、Callable对象，包装成FutureTask对象，并返回一个Future对象。</li>
<li>execute方法执行的任务如果发生了异常，会直接报异常，而submit方法执行的任务不会抛出异常，而是将异常保存在返回的Future对象中。</li>
<li>submit底层调用的还是execute，只不过它将提交的任务封装成了FutureTask对象交给Worker执行</li>
</ol>
<h2 id="为什么不推荐使用Executors创建线程池？"><a href="#为什么不推荐使用Executors创建线程池？" class="headerlink" title="为什么不推荐使用Executors创建线程池？"></a><strong>为什么不推荐使用Executors创建线程池？</strong></h2><p>Executors提供了四种默认线程池：</p>
<ol>
<li><strong>newFixedThreadPool</strong><br>任务队列使用的是无界队列，可能导致OOM</li>
<li><strong>newSingleThreadExecutor</strong><br>任务队列使用的是无界队列，可能导致OOM</li>
<li><strong>newCachedThreadPool</strong><br>最大线程数是Integer.MAX_VALUE，线程过多导致CPU资源耗尽和OOM</li>
<li><strong>newScheduledThreadPool</strong><br>使用无界队列，任务过多导致OOM</li>
</ol>
<p>其次，它们的拒绝策略不能自定义，都统一使用的AbortPolicy。</p>
<ol>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ol>
<h2 id="Java线程池状态与切换"><a href="#Java线程池状态与切换" class="headerlink" title="Java线程池状态与切换"></a><strong>Java线程池状态与切换</strong></h2><p>线程池运行的状态，不是用户显式指定的，而是伴随线程池的运行，由内部来维护。</p>
<p>线程池内部使用一个ctl变量维护两个值：</p>
<ul>
<li>runState：运行状态，高3位存储</li>
<li>workerCount：线程池内有效线程的数量，低29位存储</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>线程池的逻辑中经常要同时出现判断线程池运行状态和线程数量的情况。</p>
<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。</p>
<p>线程池有5种，分别是：</p>
<ul>
<li><strong>RUNNING</strong>：能提交新任务，并且也能处理阻塞队列中的任务</li>
<li><strong>SHUTDOWN</strong>：不再接受新任务，但可以继续处理阻塞队列中的任务</li>
<li><strong>STOP</strong>：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程</li>
<li><strong>TIDYING</strong>：所有的任务都已终止了，有效线程数为0，将运行<code>terminated()</code>方法</li>
<li><strong>TERMINATED</strong>：在<code>terminated()</code> 方法运行完成进入该状态</li>
</ul>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/Zkxj7KXyIcO-hfxIzuMEvwT8LNJIz1N4lF2lmtloQ_A.png" alt="image"></p>
<h2 id="线程池一直拒绝线程任务，如何处理？"><a href="#线程池一直拒绝线程任务，如何处理？" class="headerlink" title="线程池一直拒绝线程任务，如何处理？"></a><strong>线程池一直拒绝线程任务，如何处理？</strong></h2><p>线程池一直拒绝新任务，说明线程池已达到最大线程数，且工作线程处理任务的速度小于提交任务速度。</p>
<ol>
<li>阻塞队列角度：使用无界阻塞队列，但是治标不治本</li>
<li>线程数量角度：可以分析任务特点，根据业务情况动态调整最大线程数</li>
<li>调整拒绝策略</li>
</ol>
<h2 id="线程池的核心线程是否可以被回收，如何回收？"><a href="#线程池的核心线程是否可以被回收，如何回收？" class="headerlink" title="线程池的核心线程是否可以被回收，如何回收？"></a><strong>线程池的核心线程是否可以被回收，如何回收？</strong></h2><p>核心线程默认不会被回收。</p>
<p>线程池的核心线程的回收由<code>allowCoreThreadTimeOut</code>参数控制，默认为false，若开启为true，则此时线程池中不论核心线程还是非核心线程，只要其空闲时间达到keepAliveTime都会被回收。</p>
<p>但如果这样就违背了线程池的初衷（减少线程创建和开销），所以默认该参数为false。</p>
<h2 id="如何关闭线程池"><a href="#如何关闭线程池" class="headerlink" title="如何关闭线程池"></a><strong>如何关闭线程池</strong></h2><ol>
<li><code>shutdown</code> ：线程池的状态变为SHUTDOWN，不再接受新任务，但会处理完队列里的任务，再变成TIDYING状态</li>
<li><code>shutdownNow()</code> ：线程池的状态变为STOP，不再接受新任务，并且调用<code>Thread.interrupt()</code> 中断正在执行任务的线程，将队列中未处理的任务返回给调用者线程。</li>
</ol>
<h2 id="线程池刚刚启动时有没有活跃线程"><a href="#线程池刚刚启动时有没有活跃线程" class="headerlink" title="线程池刚刚启动时有没有活跃线程"></a><strong>线程池刚刚启动时有没有活跃线程</strong></h2><ul>
<li><code>prestartCoreThread</code> ：创一个空闲任务线程等待任务到达</li>
<li><code>prestartAllCoreThreads</code> ：创建核心线程池数量的空闲任务等待任务到达</li>
</ul>
<h1 id="JUC常见类"><a href="#JUC常见类" class="headerlink" title="JUC常见类"></a><strong>JUC常见类</strong></h1><ul>
<li>JUC的atomic包下运用了CAS的AtomicBoolean、AtomicInteger、AtomicReference等原子变量类</li>
<li>JUC的locks包下的AQS以及使用AQS的ReentantLock（显式锁）、ReentrantReadWriteLock</li>
<li>JUC下的一些同步工具类：CountDownLatch（闭锁）、Semaphore（信号量）、CyclicBarrier（栅栏）、FutureTask</li>
<li>JUC下的一些并发容器类：ConcurrentHashMap、CopyOnWriteArrayList</li>
<li>JUC下的一些Executor框架的相关类： <ul>
<li>线程池的工厂类-&gt;Executors  </li>
<li>线程池的实现类-&gt;ThreadPoolExecutor/ForkJoinPool</li>
</ul>
</li>
<li>JUC下的一些阻塞队列实现类：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue</li>
</ul>
<h1 id="Java锁分类和对比"><a href="#Java锁分类和对比" class="headerlink" title="Java锁分类和对比"></a><strong>Java锁分类和对比</strong></h1><h2 id="Java中的锁类型与区别"><a href="#Java中的锁类型与区别" class="headerlink" title="Java中的锁类型与区别"></a><strong>Java中的锁类型与区别</strong></h2><ul>
<li><p>公平锁/非公平锁</p>
<ul>
<li><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p>
</li>
<li><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p>
</li>
<li><p>ReentranLock默认是非公平锁，可以设置为公平锁，sychronized只能是非公平锁</p>
</li>
</ul>
</li>
<li><p>可重入锁</p>
<ul>
<li>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞</li>
</ul>
</li>
<li><p>乐观锁/悲观锁</p>
</li>
<li><p>自旋锁</p>
</li>
<li><p>偏向锁/轻量级锁/重量级锁</p>
</li>
</ul>
<h2 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a><strong>synchronized与Lock的区别</strong></h2><p>两者都是可重入锁</p>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/klFuDatAZhT0Se7g5rwpoI1C9vp_CGSqaIVpSY2H4g0.png" alt="image"></p>
<blockquote>
<p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p>
</blockquote>
<p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，<strong>需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成</strong>），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<h1 id="AQS及其实现类"><a href="#AQS及其实现类" class="headerlink" title="AQS及其实现类"></a><strong>AQS及其实现类</strong></h1><h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a><strong>AQS原理</strong></h2><p>AQS 是一个用来<strong>构建锁和同步器的框架</strong>，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。</p>
<p>具体用法是通过继承AQS，并实现其模板方法，来达到同步状态的管理。</p>
<h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a><strong>AQS核心思想</strong></h3><p>如果被请求的共享资源是空闲的，那么就将当前请求资源的线程<strong>设置为活跃的工作线程</strong>，将共享资源<strong>设置为锁定状态</strong>；如果共享资源被占用了，就需要定制的阻塞、唤醒机制来保证资源的分配。阻塞、唤醒机制是基于CLH队列实现的，<strong>将暂时获取不到锁的线程加入到队列中</strong>进行等待，后续进行<strong>唤醒操作</strong>。</p>
<p><strong>CLH队列</strong></p>
<p>AQS中的队列是基于CLH实现的双链表，AQS将请求共享资源的线程封装成一个节点Node，将暂时获取不到锁的线程加入队列。</p>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/B6zPlj6Bu64XyVBInrdsq6d7eTEu_zsvDBImgfqx72Y.png" alt="image"></p>
<p>AQS使用一个volatile int类型的变量来标识<strong>同步状态state</strong>，<strong>通过维护一个FIFO队列来完成资源获取的排队工作</strong>，<strong>通过CAS来完成对state值的修改。</strong></p>
<p>CLH队列工作流程：</p>
<ul>
<li>线程先去通过tryAcquire方法获取锁，成功则当前线程获得锁<ul>
<li>无论是公平锁还是非公平锁，都不是直接放入队列中的，只是公平锁在CAS获取锁之前会去判断队列中是否有线程等待，如果有，则进入等待队列而不是获取锁，而非公平锁则直接CAS去获取锁。</li>
</ul>
</li>
<li>失败则新建节点 将节点与当前线程保存起来</li>
<li>将新建节点CAS的方式设置为队列的尾部节点</li>
<li>当锁释放时，会去唤醒队头，去tryAcquire</li>
</ul>
<h3 id="AQS定义了两种资源共享方式"><a href="#AQS定义了两种资源共享方式" class="headerlink" title="AQS定义了两种资源共享方式"></a><strong>AQS定义了两种资源共享方式</strong></h3><ul>
<li><strong>共享锁</strong>：CountDownLatch、Semaphore、CylicBarrier、ReadWriteLock</li>
<li><strong>独占锁</strong>：ReetrantLock<ul>
<li><strong>公平锁</strong>：按照排队顺序</li>
<li><strong>非公平锁</strong>：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。<ul>
<li>非公平锁并不是将所有队列中的元素全部叫醒，然后来一起竞争，队列中的线程仍然是一个一个叫醒的，只是在被叫醒的时候，可能会有其他没有进入阻塞队列中的线程（新来的）会来竞争</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在底层实现好了。</p>
<h3 id="AQS使用了模板方法模式"><a href="#AQS使用了模板方法模式" class="headerlink" title="AQS使用了模板方法模式"></a><strong>AQS使用了模板方法模式</strong></h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（<strong>重写方法很简单，无非是对于共享资源 state 的获取和释放</strong>）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a><strong>Condition</strong></h3><p>Reentrantlock 可以结合Condition实现等待/通知机制。它具有很好的灵活性，一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例，线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知。—&gt; 主要方法： await 和 signal</p>
<p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<ul>
<li>await 流程 ：<ul>
<li>开始 线程0 持有锁，conditionObject对象调用 await，在ConditionObject中的等待队列中创建新的节点并关联线程0 ，放入等待队列尾部</li>
<li>释放同步器上的所有的锁 (因为可能线程发生可重入, 锁有很多层)</li>
<li>唤醒等待 队列中最前面的等待的节点</li>
<li>阻塞式线程0</li>
</ul>
</li>
<li>signal 流程<ul>
<li>进入 ConditionObject 中 取得等待队列中第一个 Node</li>
<li>将该 Node 加入 AQS的等待队列尾部</li>
</ul>
</li>
</ul>
<h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a><strong>ReentrantLock原理</strong></h2><p>ReentrantLock可以实现多重功能：</p>
<ul>
<li>支持锁重入</li>
<li>阻塞状态时可以被中断–&gt;采用的是中断锁</li>
<li>设置锁的超时时间（超过则退出阻塞队列，并释放自己拥有的锁）—&gt;防止无限制等待，减少死锁</li>
<li>公平锁或者非公平锁</li>
<li>支持多个条件变量—&gt;避免虚假唤醒</li>
</ul>
<p>首先ReentrantLock基于AQS实现，其内部的Sync类直接继承自AQS，Sync类的子类NonfairSync和FairSync分别实现了非公平和公平策略，<strong>锁资源被表示为同步状态state，表示锁的可重入次数。</strong></p>
<p>ReentrantLock重写了AQS的tryAcquire和tryRelease方法，底层的队列和节点的维护，由AQS的底层方法完成。</p>
<blockquote>
<p>我觉得原理的介绍，主要讲一下AQS的模板模式，然后讲一下CLH队列的工作模式(公平锁与非公平锁)，然后讲一下可重入锁的实现方式、讲一下Reentrantlock与condition的结合</p>
</blockquote>
<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a><strong>可重入原理</strong></h3><p>同一个线程, 锁重入, 会对state进行自增，释放锁的时候, state进行自减，当state自减为0的时候，此时线程才会将锁释放成功, 才会进一步去唤醒其他线程来竞争锁</p>
<h3 id="加锁解锁的流程"><a href="#加锁解锁的流程" class="headerlink" title="加锁解锁的流程"></a><strong>加锁解锁的流程</strong></h3><p>加锁：</p>
<ol>
<li>通过ReentrantLock的lock方法进行加锁操作</li>
<li>调用内部类Sync的lock方法</li>
<li>Lock方法调用acquire方法</li>
<li>acquire方法调用tryAcquire方法，由ReentrantLock自定义同步器进行实现</li>
<li>tryAcquire执行获取锁的逻辑，获取失败后，会执行AQS框架的后续逻辑，和ReentrantLock自定义的内容无关</li>
</ol>
<p>解锁：</p>
<ol>
<li>通过ReentrantLock的unLock方法进行解锁操作</li>
<li>调用内部类的Release方法</li>
<li>Release方法调用tryRelease方法，由AQS自定义同步器进行实现</li>
<li>tryRelease方法执行释放锁的逻辑</li>
<li>释放锁成功后，所有处理由AQS框架完成，与自定义同步器无关</li>
</ol>
<h2 id="ReentrantReadWriteLock读写锁实现方式"><a href="#ReentrantReadWriteLock读写锁实现方式" class="headerlink" title="ReentrantReadWriteLock读写锁实现方式"></a><strong>ReentrantReadWriteLock读写锁实现方式</strong></h2><p>读写锁用于写少读多的场景，<strong>采用了读写分离的策略</strong>。</p>
<p><strong>读写锁内部维护了一个ReadLock和一个WriteLock</strong>，读锁是共享锁，写锁是独占锁，继承自Sync类，Sync类继承自AQS。</p>
<p>state：高16位表示读状态；低16位表示写状态。</p>
<ul>
<li>读-读能共存、读-写不能共存、写-写不能共存</li>
<li>读锁不支持条件变量</li>
<li><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</li>
<li><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁，会释放掉写锁</li>
</ul>
<h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a><strong>写锁</strong></h3><p>写锁是重写了AQS的tryAcquire方法</p>
<p>写锁的获取和释放和ReentrantLock逻辑基本相同，但<strong>在获取写锁前，要首先判断是否存在读锁，如果存在，则写锁不能获取</strong>。</p>
<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a><strong>读锁</strong></h3><p>读锁是重写了AQS的tryAcquireShared方法 ，<strong>加读锁之前会先去看是否已经上了读锁，有分为两种情况：</strong></p>
<ol>
<li>如果有其他线程已经获取了写锁，则当前线程获取读锁失败，进入阻塞状态</li>
<li>如果当前线程之前已获取了写锁，或者写锁还没被获取，则CAS的增加读状态–》锁降级</li>
</ol>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a><strong>锁降级</strong></h3><p>锁降级就是写锁的一种特殊重入机制。通过这种重入，可以减少一步流程：释放写锁后再次获取读锁。</p>
<ol>
<li>线程首先获取到写锁</li>
<li>该线程再获取读锁</li>
<li>然后释放写锁</li>
</ol>
<p>锁降级的作用是释放掉独占锁，提高获取锁的效率，也使其他线程可以获取到读锁，<strong>提高并发性，减少锁竞争，</strong>如果先释放写锁，再获取读锁，势必引起锁的争抢和线程上下文切换，影响性能。</p>
<h2 id="CountDownLatch原理（倒计时器）"><a href="#CountDownLatch原理（倒计时器）" class="headerlink" title="CountDownLatch原理（倒计时器）"></a><strong>CountDownLatch原理（倒计时器）</strong></h2><p><strong>CountDownLatch****允许 <strong><strong>count</strong></strong> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</strong></p>
<p><code>CountDownLatch</code>是<strong>共享锁</strong>的一种实现,<strong>它默认构造 AQS 的 state 值为 count</strong>。当线程使用 <code>countDown()</code>方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 state,直至 state为 0 。当调用 **await()**方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，<code>await()</code>方法就会一直阻塞，也就是说 <code>await()</code>方法之后的语句不会被执行。然后，<code>CountDownLatch</code>会自旋 CAS 判断 state == 0，如果 <code>state == 0</code>的话，就会释放所有等待的线程，<code>await()</code>方法之后的语句得到执行。</p>
<blockquote>
<p>countDownLatch的不足：</p>
</blockquote>
<p>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p>
<p><strong>CountDownLatch 的两种典型用法</strong></p>
<ol>
<li><strong>等待组件加载</strong>：某一线程开始运行前等待n个线程执行完毕。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li><strong>同时唤醒多个线程</strong>：实现多个线程开始执行任务的最大并行性：初始化一个共享的CountDownLatch对象，将计数器初始化为1，多个线程在执行任务前首先await，当主线程调用countDown()时，多个线程被同时唤醒。</li>
</ol>
<h2 id="CyclicBarrier原理（循环栅栏）"><a href="#CyclicBarrier原理（循环栅栏）" class="headerlink" title="CyclicBarrier原理（循环栅栏）"></a><strong>CyclicBarrier原理（循环栅栏）</strong></h2><p>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p>CyclicBarrier基于<strong>独占锁</strong>实现，本质还是AQS。</p>
<p>CyclicBarrier使用parties记录线程个数。</p>
<p>parties就表示线程总数，每当线程调用await，count就减1，count为0时，表示所有线程达到了屏障点，就一起向下执行。</p>
<p><strong>CyclicBarrier维护了count和parties两个变量。parties记录总的线程个数，count作计数器，每当count变为0后，就会将parties赋给count，以实现复用。</strong></p>
<ol>
<li>获取锁， 进行count–操作</li>
<li>判断是否所有线程都到达了屏障点</li>
<li>如果都到了，则执行初始化时传递的任务，然后唤醒其他阻塞的线程</li>
<li>否则，将当前线程放入阻塞队列。</li>
</ol>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><strong>ThreadLocal</strong></h1><h2 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a><strong>ThreadLocal是什么？</strong></h2><p>线程本地变量。当使用ThreadLocal维护变量时，<strong>ThreadLocal为每个使用该变量的线程提供独立的变量副本</strong>，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程。ThreadLocal 变量通常被<code>private static</code>修饰。线程结束以后，这个本地变量也会随着线程消失。</p>
<p>InheritableThreadLocal : 子线程共享父线程的线程副本数据</p>
<h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a><strong>ThreadLocal原理</strong></h2><p><strong>每个线程都有一个ThreadLocalMap，其中Key为ThreadLocal的弱引用，value为对应线程的变量副本</strong>。每个线程往ThreadLocal里面放值都是放到自己的ThreadLocalMap里面，读也是以ThreadLocal为引用在自己的map里面读对应的key，从而实现线程隔离，每次修改就是将之前的值进行覆盖。</p>
<p>ThreadLocalMap与HashMap不同，不是采用的链表的方式应对哈希冲突，而是采用的<strong>开放寻址法</strong>。（原因是链表需要额外空间记录链表指针，在节点规模比较小的情况下，开放寻址法更节省空间）。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><p>ThreadLocal 并不是用来解决共享资源的多线程访问的问题，因为每个线程中的资源只是副本，并不共享。</p>
<p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用。</strong></p>
<p>典型应用场景：</p>
<ul>
<li><strong>全局存储用户信息</strong>：通常用户信息会被保存在Session或者Token中，可以用ThreadLocal来维护Session，以实现当前线程在任何地方如果需要拿到用户信息可以使用ThreadLocal的get方法获得<ul>
<li>在一个线程对一个信息，比如说一个Session，可能会调用一系列方法，进行Session的处理，使用ThreadLocal进行一个Session在整个处理过程中的全局共享，<strong>避免复杂的传值</strong>，进行一个操作的简化。</li>
</ul>
</li>
</ul>
<p>慎用：</p>
<ul>
<li>线程池中的线程调用ThreadLocal，因为线程池中的线程会被复用</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h2><p>弱引用：只要发生垃圾回收，只被弱引用指向的对象会被回收</p>
<p><img src="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/b735fhN9fQkJf5d-lfL6tswXwwTXOcDJZtwUMRZ0uH0.png" alt="image"></p>
<p>内存泄漏产生原因：</p>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value的强引用只有在thread线程结束以后才会被断开，而线程通常是使用线程池来处理的，是存在复用情况的，所以value可能会永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p>
<p>弱引用是只要gc就会被清理掉</p>
<p><strong>解决方案</strong></p>
<p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录（探测式清理和启发式清理）。</p>
<p>当你不需要这个ThreadLocal变量时应该主动调用remove()方法。</p>
<blockquote>
<p>为什么key不能是强引用</p>
</blockquote>
<p>实际开发中，当我们不需要 threadlocal 后，为了 GC 将 threadlocal 变量置为 null，没有任何强引用指向堆中的 threadlocal 对象时，堆中的 threadlocal 对象将会被 GC 回收，假设现在 Key 持有的是 threadlocal 对象的强引用，如果当前线程仍然在运行，那么从当前线程一直到 threadlocal 对象还是存在强引用，由于当前线程仍在运行的原因导致 threadlocal 对象无法被 GC，这就发生了内存泄漏。</p>
<p><strong>使用弱引用，threadlocal对象是会被回收的，只是可能entry会出现内存泄漏。</strong></p>
<blockquote>
<p>value为什么不能是弱引用</p>
</blockquote>
<p>因为一般value的对象只有value这一个引用指向，如果设为弱引用，一次gc后value就没了，无法达到存储线程变量的效果。</p>
<blockquote>
<p>探测式清理</p>
</blockquote>
<p>从前向后遍历整个数组，如果碰到过期Entry就将其设置为null，碰到没过期的就将其重新hash放置</p>
<h2 id="ThreadLocal的扩容"><a href="#ThreadLocal的扩容" class="headerlink" title="ThreadLocal的扩容"></a><strong>ThreadLocal的扩容</strong></h2><p>如果当前散列数组中Entry数量已经达到了扩容阈值，则<strong>首先会进行探测式清理</strong>，如果还不够，则进行扩容，扩容就是扩大数组大小，然后将所有的Entry重新hash放到新的数组中。</p>
<h1 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a><strong>同步模式之顺序控制</strong></h1><blockquote>
<p>其实这些控制最主要的就是要弄个条件去让其他不符合的等待，或者可以让所有的全部等待了，然后再将开启条件放出，然后顺序执行。</p>
</blockquote>
<h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a><strong>交替输出</strong></h2><p>就是弄一个标志位，判断这个标志位是否实现。</p>
<ul>
<li>假如有两个线程, 线程A打印1, 线程B打印2.</li>
<li>要求: <strong>程序先打印2, 再打印1</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 使用wait/notify来实现顺序打印 2, 1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncPrintWaitTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">      <span class="comment">// t2线程释放执行过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> t2Runned = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                  <span class="keyword">while</span> (!t2Runned) &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 进入等待(waitset), 会释放锁</span></span><br><span class="line">                          lock.wait();</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">          Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                  log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                  t2Runned = <span class="keyword">true</span>;</span><br><span class="line">                  lock.notify();</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制台输入字符串，然后开启相同字符顺序输出"><a href="#控制台输入字符串，然后开启相同字符顺序输出" class="headerlink" title="控制台输入字符串，然后开启相同字符顺序输出"></a><strong>控制台输入字符串，然后开启相同字符顺序输出</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> isYourTurn = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字符串&quot;</span>);</span><br><span class="line">        String s = scanner.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length();i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> threadTest(s.charAt(i),i));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">threadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">threadTest</span><span class="params">(<span class="keyword">char</span> ch ,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ch = ch;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(isYourTurn  != flag)&#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(ch);</span><br><span class="line">                isYourTurn++;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交替输出abc"><a href="#交替输出abc" class="headerlink" title="交替输出abc"></a><strong>交替输出abc</strong></h2><p><strong>线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。现在要求输出 abcabcabcabcabcabc</strong></p>
<h3 id="wait-notify版本"><a href="#wait-notify版本" class="headerlink" title="wait/notify版本"></a><strong>wait/notify版本</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       WaitNoitfy waitNoitfy = <span class="keyword">new</span> WaitNoitfy(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">          waitNoitfy.print(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           waitNoitfy.print(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           waitNoitfy.print(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNoitfy</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> loopNumber = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WaitNoitfy</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.flag = flag;</span><br><span class="line">       <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,<span class="keyword">int</span> waitFlag,<span class="keyword">int</span> nextFlag)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; loopNumber;i++) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">while</span>(<span class="keyword">this</span>.flag != waitFlag)&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               System.out.println(str);</span><br><span class="line">               <span class="keyword">this</span>.flag = nextFlag;</span><br><span class="line">               <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="await-signal版本"><a href="#await-signal版本" class="headerlink" title="await/signal版本"></a>await/signal版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">       <span class="comment">//为每种情况配置一个条件变量</span></span><br><span class="line">       Condition aCondition = awaitSignal.newCondition();</span><br><span class="line">       Condition bCondition = awaitSignal.newCondition();</span><br><span class="line">       Condition cCondition = awaitSignal.newCondition();</span><br><span class="line">       <span class="comment">//通过条件变量的改变去交替输出abc，首先进去后，都会被await</span></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           awaitSignal.print(<span class="string">&quot;a&quot;</span>,aCondition,bCondition);</span><br><span class="line">        &#125;,<span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           awaitSignal.print(<span class="string">&quot;b&quot;</span>,bCondition,cCondition);</span><br><span class="line">        &#125;,<span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           awaitSignal.print(<span class="string">&quot;c&quot;</span>,cCondition,aCondition);</span><br><span class="line">        &#125;,<span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">        <span class="comment">//在主线程中首先需要有一个开始，上面通过wait/Notify是通过主线程将flag设置为1</span></span><br><span class="line">       <span class="comment">//而这里是首先让主线程拿到锁，然后将第一个条件变量唤醒，并释放掉锁</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;----开始----&quot;</span>);</span><br><span class="line">       awaitSignal.lock();</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           aCondition.signal();     <span class="comment">//首先唤醒a线程</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> loopNumber = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,Condition condition,Condition next)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; loopNumber;i++)&#123;</span><br><span class="line">         lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//首先所有线程会全部进入阻塞，然后在主线程中会把一个叫醒，然后执行完以后，就会通过next叫醒另一个</span></span><br><span class="line">                 condition.await();</span><br><span class="line">                 System.out.println(str);</span><br><span class="line">                 next.signal(); <span class="comment">//将下一个condition叫醒</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">             unlock();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题三：m个线程将长度为m的字符串打印n次"><a href="#问题三：m个线程将长度为m的字符串打印n次" class="headerlink" title="问题三：m个线程将长度为m的字符串打印n次"></a><strong>问题三：m个线程将长度为m的字符串打印n次</strong></h3><p>输入一个循环次数（次数为n），然后输入一个字符串（长度为m），开启m个线程，然后将字符串打印n次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLockCondition</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> printCount;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition thisCondition;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition nextCondition;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadLockCondition</span><span class="params">(<span class="keyword">int</span> printCount,ReentrantLock reentrantLock, Condition thisCondition, Condition nextCondition, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.printCount = printCount;</span><br><span class="line">       <span class="keyword">this</span>.reentrantLock = reentrantLock;</span><br><span class="line">       <span class="keyword">this</span>.thisCondition = thisCondition;</span><br><span class="line">       <span class="keyword">this</span>.nextCondition = nextCondition;</span><br><span class="line">       <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; printCount; i++) &#123;</span><br><span class="line">           reentrantLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   thisCondition.await();</span><br><span class="line">                   System.out.print(printChar);</span><br><span class="line">                   nextCondition.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//输入打印的字符串长度为m，启动m个线程来打印，打印次数为输入的另外一个参数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入打印次数&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> count = Integer.valueOf(scanner.nextLine());</span><br><span class="line">       System.out.println(<span class="string">&quot;请输入打印的字符串&quot;</span>);</span><br><span class="line">       String s = scanner.nextLine();</span><br><span class="line">       <span class="comment">//如果只有一个字符，只需要开一个线程处理就可以</span></span><br><span class="line">       <span class="keyword">if</span> (s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               System.out.print(s);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果有m个字符，需要m个线程来顺序打印</span></span><br><span class="line">       ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">       List&lt;Condition&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">//创造m个条件变量，并将其放入集合中</span></span><br><span class="line">           Condition condition = lock.newCondition();</span><br><span class="line">           list.add(condition);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> size = list.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="comment">//循环开启各个线程，每个线程里面将要打印的打印count遍（注意是里面在循环，当前只是在开线程）,</span></span><br><span class="line">           <span class="comment">// 输入的是当前的condition和下一个condition，因为要循环，所以要取余size，i+1在最后的时候会使其重新回到第一个值</span></span><br><span class="line">           Thread t =<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLockCondition(count,lock,list.get(i%size),list.get((i+<span class="number">1</span>)%size),s.charAt(i)));</span><br><span class="line">           t.start();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//在main中写开启第一个线程的条件变量</span></span><br><span class="line">       Thread.sleep(<span class="number">100</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;---开始打印---&quot;</span>);</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           list.get(<span class="number">0</span>).signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a><strong>Atomic原子类</strong></h1><p><code>java.util.concurrent.atomic并发包</code>提供了一些并发工具类，这里把它分成五类：</p>
<ul>
<li>基本数据类型<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
</li>
<li>数组类型</li>
<li>引用类型<ul>
<li>AtomicReference 引用类型原子类</li>
</ul>
</li>
<li>字段更新器</li>
<li>原子累加器</li>
</ul>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>AtomicInteger是对int类型的一个封装，提供原子性的访问和更新操作。它采用CAS+volatile实现的。CAS保证了其可以乐观锁的方式对共享变量进行修改。volatile保证了数据的可见性。</p>

    </div>

    
    
    
      

        <div class="reward-container">
  <div>感谢您的支持，这将鼓励我继续努力创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="曾超 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="曾超 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>曾超
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zengc0905.github.io/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JUC知识点整理">http://zengc0905.github.io/2022/01/29/JUC知识点整理/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>

      

      <div>
        
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

        
      </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/juc/" rel="tag"><i class="fa fa-tag"></i></a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/" rel="prev" title="谷粒商城-分布式基础篇">
      <i class="fa fa-chevron-left"></i> 谷粒商城-分布式基础篇
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="操作系统学习笔记">
      操作系统学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-text">Java线程有哪几种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">Java中创建线程的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%92%8C%E5%AE%9E%E7%8E%B0Runaable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">继承Thread类和实现Runaable接口的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">wait和sleep的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait%E5%92%8Cnotify"><span class="nav-text">wait和notify</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait"><span class="nav-text">wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notify"><span class="nav-text">notify</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start%E5%92%8Crun%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">start和run方法的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%B8%AD%E6%96%AD"><span class="nav-text">线程在什么情况下会中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%89"><span class="nav-text">Java如何保证线程安全（Java多线程的三大特性）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="nav-text">伪共享问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="nav-text">如何避免伪共享</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%E4%BB%A5%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%96%B9%E5%BC%8F"><span class="nav-text">什么是死锁以及排查方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">互斥与同步的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">为什么要线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7-happens-before%E5%8E%9F%E5%88%99"><span class="nav-text">有序性-happens-before原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Synchronized%E6%98%AF%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-text">为什么Synchronized是重量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88JVM%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="nav-text">synchronized代码块底层原理（JVM字节码角度）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88JVM%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="nav-text">synchronized方法底层原理（JVM字节码角度）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">重量级锁的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-text">锁升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-text">偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="nav-text">加锁流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="nav-text">偏向锁的撤销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-text">轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B-1"><span class="nav-text">加锁流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="nav-text">解锁流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">Synchronized关键字的三种使用方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%8F%AF%E4%BB%A5%E9%94%81%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-text">synchronized可以锁的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized%E9%94%81%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">Synchronized锁类对象和this的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E6%98%AF%E5%90%A6%E8%83%BD%E9%98%B2%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-text">synchronized是否能防止指令重排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-text">volatile关键字的原理与作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">volatile保证变量可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E9%98%B2%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="nav-text">volatile防止指令重排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88volatile%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-text">为什么volatile不能保证原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-text">volatile典型应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">**说说 synchronized 关键字和 volatile 关键字的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-text">CAS和乐观锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">乐观锁的缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-text">ABA问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="nav-text">循环时间长开销大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E7%AE%97%E6%B3%95%E2%80%94-gt-CAS%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-text">CAS算法—&gt;CAS操作原理与实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E4%B8%8Esynchronized%E5%8C%BA%E5%88%AB"><span class="nav-text">CAS与synchronized区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-text">自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">自旋锁存在的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">自旋锁的优点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E4%B8%BE%E5%87%A0%E7%A7%8D%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%B9%B6%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="nav-text">列举几种阻塞队列并对比分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">手写阻塞队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-text">为什么要用线程池？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%8C%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-text">Java线程池核心参数与工作流程，拒绝策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">线程池的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%87%AA%E5%B8%A6%E7%9A%844%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">Java自带的4种线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%80%8E%E4%B9%88%E5%AE%9A"><span class="nav-text">最大核心线程数怎么定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%BB%98%E8%AE%A4%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">线程池默认的阻塞队列是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%9C%89%E5%8C%BA%E5%88%AB"><span class="nav-text">核心线程和非核心线程是否有区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E7%BA%BF%E7%A8%8B%E6%8A%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E6%8A%93%E5%8F%96%EF%BC%8C%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%96%E6%8D%95%E8%8E%B7"><span class="nav-text">线程池里线程报的异常如何抓取，在线程池外捕获</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="nav-text">如何得到线程池的异步处理结果？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">定时任务的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#execute%E5%92%8Csubmit%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">execute和submit的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-text">为什么不推荐使用Executors创建线程池？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E4%B8%8E%E5%88%87%E6%8D%A2"><span class="nav-text">Java线程池状态与切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%80%E7%9B%B4%E6%8B%92%E7%BB%9D%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">线程池一直拒绝线程任务，如何处理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-text">线程池的核心线程是否可以被回收，如何回收？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">如何关闭线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9A%E5%88%9A%E5%90%AF%E5%8A%A8%E6%97%B6%E6%9C%89%E6%B2%A1%E6%9C%89%E6%B4%BB%E8%B7%83%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程池刚刚启动时有没有活跃线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E5%B8%B8%E8%A7%81%E7%B1%BB"><span class="nav-text">JUC常见类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%94%81%E5%88%86%E7%B1%BB%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="nav-text">Java锁分类和对比</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-text">Java中的锁类型与区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">synchronized与Lock的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">AQS及其实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="nav-text">AQS原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">AQS核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%A4%E7%A7%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-text">AQS定义了两种资源共享方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E4%BD%BF%E7%94%A8%E4%BA%86%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-text">AQS使用了模板方法模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition"><span class="nav-text">Condition</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock%E5%8E%9F%E7%90%86"><span class="nav-text">ReentrantLock原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="nav-text">可重入原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-text">加锁解锁的流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">ReentrantReadWriteLock读写锁实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E9%94%81"><span class="nav-text">写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E9%94%81"><span class="nav-text">读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7"><span class="nav-text">锁降级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch%E5%8E%9F%E7%90%86%EF%BC%88%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89"><span class="nav-text">CountDownLatch原理（倒计时器）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier%E5%8E%9F%E7%90%86%EF%BC%88%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F%EF%BC%89"><span class="nav-text">CyclicBarrier原理（循环栅栏）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">ThreadLocal是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="nav-text">ThreadLocal原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="nav-text">ThreadLocal的扩容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">同步模式之顺序控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="nav-text">交替输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%84%B6%E5%90%8E%E5%BC%80%E5%90%AF%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BA"><span class="nav-text">控制台输入字符串，然后开启相同字符顺序输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BAabc"><span class="nav-text">交替输出abc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-notify%E7%89%88%E6%9C%AC"><span class="nav-text">wait&#x2F;notify版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#await-signal%E7%89%88%E6%9C%AC"><span class="nav-text">await&#x2F;signal版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9Am%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B0%86%E9%95%BF%E5%BA%A6%E4%B8%BAm%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E5%8D%B0n%E6%AC%A1"><span class="nav-text">问题三：m个线程将长度为m的字符串打印n次</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">Atomic原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicInteger"><span class="nav-text">AtomicInteger</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="曾超"
      src="/images/zc1.jpg">
  <p class="site-author-name" itemprop="name">曾超</p>
  <div class="site-description" itemprop="description">天天经过小巷，乱花漫了高墙，贪看蜂狂蝶舞，忘了世态炎凉</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zengc0905" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zengc0905" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_42403109" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42403109" rel="noopener external nofollow noreferrer" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




      
        <div class="links-of-blogroll motion-element links-of-blogroll-block">
          <div class="links-of-blogroll-title">
            <!-- modify icon to fire by szw -->
            <i class="fa fa-history fa-" aria-hidden="true"></i>
            近期文章
          </div>
          <ul class="links-of-blogroll-list">
            
            
              <li>
                <a href="/2022/04/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典" target="_blank">程序员面试金典</a>
              </li>
            
              <li>
                <a href="/2022/04/15/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Netty学习笔记" target="_blank">Netty学习笔记</a>
              </li>
            
              <li>
                <a href="/2022/03/15/ssm%E6%A1%86%E6%9E%B6/" title="ssm框架" target="_blank">ssm框架</a>
              </li>
            
              <li>
                <a href="/2022/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="操作系统学习笔记" target="_blank">操作系统学习笔记</a>
              </li>
            
              <li>
                <a href="/2022/01/29/JUC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="JUC知识点整理" target="_blank">JUC知识点整理</a>
              </li>
            
          </ul>
        </div>
     


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      <!--网易云音乐播放器-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1397105439&auto=1&height=66"></iframe>
    </div> 
  </aside>
 
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">曾超</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">786k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:55</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='250,190,19' opacity='1' zIndex='-1' count='200' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/czqtxhzy1fbjx1x9grskpzvbfeb7kas3.js"></script>







  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'DaPWqMMMhvWr1vm4g7PhVmOg-gzGzoHsz',
      appKey     : 'n6bU0IPWvniadHKWAeJcNV43',
      placeholder: "欢迎大家各抒己见!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<span style="color:#333333">

  
	<script src="/js/cursor/fairyDustCursor.js"></script>
  
  
    <script src="/js/cursor/fireworks.js"></script> 
  
</span>



  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = true;
    document.body.addEventListener('input', POWERMODE);
  </script>



<script type="text/javascript" src="/js/fold_action.js"></script>

<!--   -->

  
    <script src="/js/cursor/fireworks.js"></script>
  



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>

</html>
<!-- 页面点击小红心 -->
<!--<script type="text/javascript" src="/js/src/clicklove.js"></script>-->
